[{"title":"maven使用","date":"2019-04-27T05:12:56.000Z","path":"2019/04/27/maven使用/","text":"安装 下载安装包 配置环境变量MAVEN_HOME 修改系统环境变量PATH，加入%MAVEN_HOME%/bin; 注意：由于maven是使用Java开发的，因此其运行需要jre，因此必须安装jdk，然后配置环境变量JAVA_HOME 测试：在cmd中输入mvn -v查看maven版本 Maven工程目录 maven工程目录 src/main/java 项目源代码 src/main/resources 项目资源文件，比如Spring配置文件 src/main/webapp web项目必备 maven命令 mvn compile 编译src/main中的源文件，输出到target目录下 mvn clean 清除target目录 mvn test 编译src/main中的源文件，编译src/test中的测试类并运行单元测试 mvn pakage 将项目打包 mvn install 将项目打包并发布到本地仓库 修改JDK版本新建maven项目后默认是jre1.5 解决办法： 添加插件，修改pom.xml 步骤1 步骤2 步骤三，在pom.xml中添加jdk版本信息 &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;configuration&gt; &lt;!-- 源码版本 --&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;!-- 编译目标版本 --&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;!-- 指定编码 --&gt; &lt;encoding&gt;utf-8&lt;/encoding&gt; &lt;/configuration&gt;&lt;/plugin&gt; 配置完之后可能工程还是jre1.5，这时只需要maven update一下即可 依赖的作用范围通过标签配置 eg: &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 取值： compile 依赖会用在编译，测试，运行 provided 依赖只有在当JDK或者一个容器已经提供该依赖时使用。provided依赖在编译和测试时需要，在运行时不需要，比如servlet api ，tomcat容器已经提供该jar包 runtime 依赖在运行和测试系统时候需要，但在编译的时候不需要。比如：jdbc的驱动包 test 依赖在编译和运行的时候都不需要，只有在测试编译和测试运行阶段可用，比如junit 使用Maven tomcat 插件运行项目 配置插件 &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;8080&lt;/port&gt; &lt;path&gt;/hello&lt;/path&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;/configuration&gt;&lt;/plugin&gt; 右键点击项目 maven-tomcat插件 运行命令 运行命令 参考：http://my.oschina.net/lilw/blog/168667","tags":[{"name":"maven","slug":"maven","permalink":"https://chsobin.github.io/tags/maven/"}]},{"title":"SpringMVC学习笔记","date":"2019-04-23T12:18:01.000Z","path":"2019/04/23/SpringMVC学习笔记/","text":"入门 创建项目 导入jar包 编写控制类TestController @Controllerpublic class HelloController &#123; @RequestMapping(\"hello\") public ModelAndView hello()&#123; System.out.println(\"hello springmvc....\"); //创建ModelAndView对象 ModelAndView mav = new ModelAndView(); //设置模型数据 mav.addObject(\"msg\", \"hello springmvc...\"); //设置视图名字 mav.setViewName(\"/WEB-INF/jsp/hello.jsp\"); return mav; &#125;&#125; 创建hello.jsp页面 创建配置SpringMVC核心配置文件springmvc.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\"&gt; &lt;!-- 扫描步骤3中被注解@Controller修饰的类 --&gt; &lt;context:component-scan base-package=\"com.example.springmvc.controller\" /&gt;&lt;/beans&gt; 在web.xml中配置前端控制器 &lt;!-- 配置前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 加载springmvc核心配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;!-- 配置拦截路径 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 测试 SpringMVC核心类SpringMVC工作流程 SpringMVC架构 其工作流程为:1、用户发送请求至前端控制器DispatcherServlet2、DispatcherServlet收到请求调用HandlerMapping处理器映射器。3、处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(二者组成HandlerExecutionChain),并将其一并返回给DispatcherServlet。4、DispatcherServlet通过HandlerAdapter处理器适配器调用处理器5、执行处理器(Controller，也叫后端控制器)。6、Controller执行完成返回ModelAndView7、HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet8、DispatcherServlet将ModelAndView传给ViewReslover视图解析器9、ViewReslover解析后返回具体View10、DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。11、DispatcherServlet对用户进行响应 【参考】https://blog.csdn.net/James_shu/article/details/54616120 SpringMVC中的重要组件一、中央控制器(DispatcherServlet) 中央控制器 作用：拦截请求 在web.xml中配置 &lt;!-- 配置前端控制器 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!-- 配置springmvc核心配置文件位置 --&gt; &lt;!-- 看源码发现public class DispatcherServlet extends FrameworkServlet 然后FrameworkServlet 中拥有属性 private String contextConfigLocation; --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 二、处理器映射器(HandlerMapping )和处理器适配器(HandlerAdapter)接口HandlerMapping 处理器映射器 绑定url请求由哪个方法来处理，也就是说根据url可以找到处理这个请求的方法 接口HandlerAdapter 处理器适配器 负责调用url请求所对应的方法 &lt;!-- 处理器映射器 --&gt;&lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"/&gt;&lt;!-- 处理器适配器 --&gt;&lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"/&gt; 或者 &lt;!-- 配置注解驱动，相当于同时使用最新处理器映射器和处理器适配器，对json数据x响应提供支持 --&gt;&lt;mvc:annotation-driven/&gt; 三、视图解析器(ViewResolver)接口ViewResolver 视图解析器 prefix配置路径前缀 suffix配置路径后缀 &lt;!-- 视图解析器 --&gt;&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt; 获取前端传来的参数传统方式默认参数，可以当作方法参数，传递到被@RequestMapping修饰的方法中 HttpServletRequest HttpServletResponse HttpSession /* * * 使用HttpServletRequest传递参数 * 使用HttpServletResponse响应请求 * */@RequestMapping(\"test\")public void itemEdit(HttpServletRequest request, HttpServletResponse response, HttpSession session) throws IOException &#123; String name = request.getParameter(\"name\"); response.setContentType(\"text/html;charset=UTF-8\"); response.setCharacterEncoding(\"utf-8\"); response.getWriter().print(\"前端传过来的参数name=\"+name);&#125; SpringMVC提供的支持1、简单参数的传递：eg:比如请求中有参数 http://localhost:8080/demoe?id=1 （1）在方法中设置Integer id （2）如果参数名不同，需要使用@RequestParam注解 public String itemEdit(Model model, @RequestParam(name=\"id\",required=true,defaultValue=\"1\")Integer num) &#123;&#125; 2、使用实体类来封装请求传过来的参数其中前端传过来的数据的name要和实体类的属性名一致 public class Item &#123; private Integer id; private String name; private Double price; private String detail; private String pic; private Date createtime; // getter() // setter()&#125; public String updateItem(Model model, Item item) &#123;&#125; 3、普通数据类型数组参数注意 参数名（如例子中的 names） 需要与前端一致 @RequestMapping(\"getArray\")public void getArray(String[] names, HttpServletResponse response) throws IOException&#123; response.setContentType(\"text/html;charset=UTF-8\"); response.setCharacterEncoding(\"UTF-8\"); PrintWriter writer = response.getWriter(); for(int i=0;i&lt;names.length;++i) &#123; writer.println(\"第\" + i + \"个参数 = \" + names[i]); &#125; writer.flush();&#125; 4、List参数如果前端 5、日期参数（1）创建转换器，需要实现Converter import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import org.springframework.core.convert.converter.Converter;public class DateConvert implements Converter&lt;String, Date&gt; &#123; public Date convert(String str) &#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); Date date = null; try &#123; date = simpleDateFormat.parse(str); &#125; catch (ParseException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return date; &#125;&#125; （2）配置Converter &lt;!-- 配置注解驱动，相当于同时使用最新处理器映射器和处理器适配器，对json数据x响应提供支持 --&gt;&lt;mvc:annotation-driven conversion-service=\"myConversion\"/&gt; &lt;!-- 注意 需要在此处配置conversion-service--&gt; &lt;!-- 配置自定义转化器 --&gt;&lt;bean id=\"myConversion\" class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\"&gt; &lt;property name=\"converters\"&gt; &lt;set&gt; &lt;!-- 自定义转化器 --&gt; &lt;bean class=\"utils.DateConvert\"/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; 响应请求1、直接返回ModelAndView 设置 数据,即addObject()方法 设置 视图的路径，即setViewName()方法 /** * 显示所有商品 * @return */ @RequestMapping(value= &#123;\"itemList\",\"itemList2\"&#125;,method= &#123;RequestMethod.POST, RequestMethod.GET&#125;) public ModelAndView itemList() &#123; List&lt;Item&gt; itemList = itemService.getItemList(); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(\"itemList\", itemList); modelAndView.setViewName(\"/WEB-INF/itemList.jsp\"); return modelAndView; &#125; 2、直接返回String改造上述方法，该方式就是简化了直接返回ModelAndView 将返回值改为String 不需要使用ModelAndView.setViewName()方法，直接return视图的路径 /** * 显示所有商品 * @return */ @RequestMapping(value= &#123;\"itemList\",\"itemList2\"&#125;,method= &#123;RequestMethod.POST, RequestMethod.GET&#125;) public String itemList() &#123; List&lt;Item&gt; itemList = itemService.getItemList(); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(\"itemList\", itemList); return \"/WEB-INF/itemList.jsp\"; &#125; 3、请求转发return “forward:要转发的路径” @RequestMapping(\"updateItem\")public String updateItem(Model model, Item item) &#123; //model.addAttribute(); return \"forward:itemList.action\";&#125; 4、请求重定向return “redirect:重定向的路径” 注意：redirect会将request作用域的数据清除，但是会将参数加在url后面 redirect请求重定向参数问题 SpringMVC中常用注解1、@Controller在SpringMVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。 在SpringMVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller ，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。 此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。 @Controller 用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。 @Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。单单使用@Controller 标记在一个类上还不能真正意义上的说它就是SpringMVC 的一个控制器类，因为这个时候Spring 还不认识它。那么要如何做Spring 才能认识它呢？这个时候就需要我们把这个控制器类交给Spring 来管理。有两种方式： （1）在SpringMVC 的配置文件中定义MyController 的bean 对象。 （2）在SpringMVC 的配置文件中告诉Spring 该到哪里去找标记为@Controller 的Controller 控制器。 &lt;!--方式一--&gt;&lt;bean class=\"类的全路径\"/&gt;&lt;!--方式二--&gt;&lt; context:component-scan base-package = \"类所在包名\" /&gt; 2、@RequestMapping 在类上 @Controller@RequestMapping(\"example\")public class Controller&#123; @RequstMapping(\"save\") // 访问该方法的路径为 example/save public String save()&#123; &#125; &#125; value属性 指定多个匹配路径 @RequestMapping(value= &#123;\"save\",\"save1\"&#125;) method属性 限制提交方式，不指定时，默认接收全部提交方式 @RequestMapping(method=&#123;RequestMethod.GET, RequestMethod.POST&#125;) consumes 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html; produces 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回； params 指定request中必须包含某些参数值是，才让该方法处理。 headers 指定request中必须包含某些指定的header值，才能让该方法处理请求。 3、@PathVariable用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数。如： @Controller public class TestController &#123; @RequestMapping(value=\"/user/&#123;userId&#125;/roles/&#123;roleId&#125;\",method = RequestMethod.GET) public String getLogin(@PathVariable(\"userId\") String userId, @PathVariable(\"roleId\") String roleId)&#123; System.out.println(\"User Id : \" + userId); System.out.println(\"Role Id : \" + roleId); return \"hello\"; &#125; @RequestMapping(value=\"/product/&#123;productId&#125;\",method = RequestMethod.GET) public String getProduct(@PathVariable(\"productId\") String productId)&#123; System.out.println(\"Product Id : \" + productId); return \"hello\"; &#125; @RequestMapping(value=\"/javabeat/&#123;regexp1:[a-z-]+&#125;\", method = RequestMethod.GET) public String getRegExp(@PathVariable(\"regexp1\") String regexp1)&#123; System.out.println(\"URI Part 1 : \" + regexp1); return \"hello\"; &#125; &#125; 详细可以参考https://blog.csdn.net/qian_ch/article/details/73826663 SpringMVC异常处理 自定义异常处理器，实现接口 public class MyExceptionResolver implements HandlerExceptionResolver &#123; public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(\"msg\", \"系统发生故障，请联系管理员\"); modelAndView.setViewName(\"msg\"); //对应 msg.jsp页面 return modelAndView; &#125;&#125; 在配置文件中配置异常处理器 &lt;!-- 配置异常处理类 --&gt;&lt;bean class=\"MyExceptionResolver\"/&gt; &lt;!--自定义类的全路径--&gt; 文件上传 配置tomcat虚拟目录，也就是设置图片库的路径 方式一 方式二：在tomcat配置文件server的Host标签中添加context标签 &lt;Context docBase=\"D:\\pictures\" path=\"/pic\" reloadable=\"true\" /&gt; 导入上传功能需要的jar包 commons-fileupload-1.2.2.jar commons-io-2.0.1.jar 配置多媒体解析器 &lt;!-- 配置多媒体解析器 --&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\" &gt; &lt;property name=\"defaultEncoding\" value=\"utf-8\"/&gt; &lt;!--限制上传大小为100KB--&gt; &lt;property name=\"maxUploadSize\" value=\"102400\"/&gt; &lt;/bean&gt; 注意id不能改，必须为multipartResolver 前端页面关于文件上传相关配置 注意： (1)method=”POST” (2)enctype=”multipart/form-data” &lt;form action=\"\" method=\"POST\" enctype=\"multipart/form-data\"&gt; &lt;label for=\"file\"&gt;文件&lt;/label&gt; &lt;input type=\"file\" name=\"uploadfile\" /&gt; &lt;p&gt;&lt;button type=\"submit\"&gt;上传&lt;/button&gt;&lt;/p&gt; &lt;/form&gt; 编写文件上传处理代码 注意：方法需要声明参数MultipartFile uploadfile表示文件，其中uploadfile要与前端的name值相对应 @RequestMapping(value = \"uploadFile\")public String uploadFile(Model model, MultipartFile uploadfile) throws Exception &#123; // 文件新名字，这里使用随机数 String name = UUID.randomUUID().toString(); // 文件原名字 String oldName = uploadfile.getOriginalFilename(); // 后缀名 String exeName = oldName.substring(oldName.lastIndexOf(\".\")); File pic = new File(\"H:\\\\pic\\\\\" + name + exeName); // 保存文件到本地磁盘 uploadfile.transferTo(pic); model.addAttribute(\"msg\", \"保存文件成功\"); return \"uploadFile\";&#125; JSON 数据 导入jar包 jackson-annotations-2.4.0.ja jackson-core-2.4.2.jar jackson-databind-2.4.2.jar 发送json数据 使用@ResponseBody @RequestMapping(value=\"getJson\")@ResponseBody // 使用该注解之后，直接返回实体类，不用手动生成json格式数据public Item getJson() &#123; // 创建一个实体类 Item item = new Item(); item.setId(111); item.setName(\"手机\"); item.setPrice(1000d); return item; // 直接返回实体对象&#125; 结果： &#123;\"id\": 111,\"name\": \"手机\",\"price\": 1000,\"detail\": null,\"pic\": null,\"createtime\": null&#125; 接收json数据 使用@RequestBody @RequestMapping(value=\"getFromClient\")@ResponseBodypublic Item getFromClient(@RequestBody Item item) &#123; return item; // 直接返回前端发来的数据&#125; 测试： 请求 POST /SpringMVCMybatis/getFromClient.action HTTP/1.1HOST: localhost:8080content-type: application/jsoncookie: JSESSIONID=97E417BE428C05EDE13D011D8D77CFC6content-length: 82&#123;\"id\":111,\"name\":\"手机\",\"price\":1000,\"detail\":null,\"pic\":null,\"createtime\":null&#125; 返回结果 &#123;\"id\":111,\"name\":\"手机\",\"price\":1000.0,\"detail\":null,\"pic\":null,\"createtime\":null&#125; RESTful/*** RESTful风格演示*///RESTful风格url上的参数通过&#123;&#125;点位符绑定//点位符参数名与方法参数名不一致时，通过@PathVariable绑定@RequestMapping(\"/item/&#123;id&#125;\")public String testRest(@PathVariable(\"id\") Integer ids, Model model) &#123; Item item = itemServices.getItemById(ids); model.addAttribute(\"item\", item); return \"itemEdit\";&#125; 拦截器1. 自定义拦截器，实现接口org.springframework.web.servlet.HandlerInterceptorpublic class MyInterceptor implements HandlerInterceptor &#123; //在Controller方法执行后被执行 //处理异常、记录日志 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object arg2, Exception arg3) throws Exception &#123; System.out.println(\"afterCompletion.....\"); &#125; //在Controller方法执行后，返回ModelAndView之前被执行 //设置或者清理页面共用参数等等 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object arg2, ModelAndView arg3) throws Exception &#123; System.out.println(\"postHandle.......\"); &#125; //在Controller方法执行前被执行 //登录拦截、权限认证等等 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object arg2) throws Exception &#123; return true; // 返回true不拦截，返回false拦截 &#125;&#125; 2.配置文件中配置拦截器&lt;!-- 拦截器 --&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- /**拦截所有请求，包括二级以上目录，/*拦截所有请求，不包括二级以上目录 --&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;!-- 不拦截的请求 --&gt; &lt;!-- &lt;mvc:exclude-mapping path=\"\"/&gt; --&gt; &lt;!-- 自定义拦截器全路径 --&gt; &lt;bean class=\"interceptor.MyInterceptor\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;","tags":[{"name":"Java","slug":"Java","permalink":"https://chsobin.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://chsobin.github.io/tags/Spring/"}]},{"title":"SpringMVC乱码问题总结","date":"2019-04-23T11:02:30.000Z","path":"2019/04/23/SpringMVC乱码问题总结/","text":"SpringMVC乱码问题总结POST请求乱码解决：在web.xml中添加过滤器 解释：CharacterEncodingFilter有两个属性 encoding forceEncoding 源码注释： Default is “false”, i.e. do not modify the encoding if javax.servlet.http.HttpServletRequest.getCharacterEncoding() returns a non-null value. Switch this to “true” to enforce the specified encoding in any case, applying it as default response encoding as well. 中文解释：默认值为false，表示当request.getCharacterEncoding()返回非空时，不修改request的字符集 当设置为true时，强制执行 request.setCharacterEncoding()和 response.setCharacterEncoding(); &lt;!-- 解决post乱码问题 --&gt;&lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; GET请求乱码注意：get请求方式在tomcat7之前处理tomcat服务器都是用ISO-8859-1处理数据，之后的版本默认UTF-8 方法一： 修改tomcat的server.xml配置文件，添加URIEncoding=”utf-8” &lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" URIEncoding=\"utf-8\"/&gt; 方法二： 手动更改： String str = new String(request.getParameter(\"username\").getBytes(\"ISO-8859-1\"),\"UTF-8\"); 返回响应乱码情况一：使用@ResponseBody直接返回对象@RequestMapping(\"testResponseBodyEncoding\")@ResponseBodypublic Item testResponseBodyEncoding() &#123; Item item = new Item(); item.setId(333); item.setCreatetime(new Date()); item.setDetail(\"使用ResponseBody返回json数据会乱码吗\"); item.setName(\"陈松彬\"); item.setPrice(1000d); return item; // 直接返回对象，不需要我们手动转为json格式数据&#125; 上述案例测试不会产生乱码，这是由于使用的转换器默认编码是UTF-8 AbstractJackson2HttpMessageConverter默认编码 情况二：使用@ResponseBody返回字符串@RequestMapping(\"testResponseBodyEncoding\")@ResponseBodypublic String testResponseBodyEncoding() &#123; Item item = new Item(); item.setId(333); item.setCreatetime(new Date()); item.setDetail(\"使用ResponseBody返回json数据会乱码吗\"); item.setName(\"陈松彬\"); item.setPrice(1000d); return item.toString();// 直接返回字符串&#125; 这种情况会产生乱码，这是由于使用的转换器默认编码是ISO-8859-1 StringHttpMessageConverter默认编码 解决办法： 这里提供一个简单的解决办法： 在注解种设置produces的值 @RequestMapping(value=\"testGet\", produces = \"application/json; charset=utf-8\") 其他解决办法https://www.cnblogs.com/striver-zhu/p/7158623.html 情况三：直接使用HttpServletResponse返回数据这种情况需要手动设置 response.setContentType(“text/html;charset=UTF-8”);response.setCharacterEncoding(“UTF-8”); @RequestMapping(\"getArray\")public void getArray(String[] names, HttpServletResponse response) throws IOException&#123; response.setContentType(\"text/html;charset=UTF-8\"); response.setCharacterEncoding(\"UTF-8\"); PrintWriter writer = response.getWriter(); for(int i=0;i&lt;names.length;++i) &#123; writer.println(\"第\" + i + \"个参数 = \" + names[i]); &#125; writer.flush();&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://chsobin.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://chsobin.github.io/tags/Spring/"}]},{"title":"Spring学习笔记","date":"2019-04-15T15:20:43.000Z","path":"2019/04/15/Spring学习笔记/","text":"Spring是什么：如果单独讲概念的话，直接看百科就行。这里主要列出了Spring的两个核心概念： IoC 控制反转 AOP 面向切面编程 IoC控制反转 IoC(Inversion of Control) 控制反转 把创建对象的这个工作，由程序员转交给“容器” 当需要某个对象的时候，不是通过new硬编码实现，而是通过容器获取需要的对象 Ioc不仅仅是创建对象，而且还管理着对象的生命周期 DI(Dependency Injection) 依赖注入 Class A中用到了Class B的对象b，一般情况下，需要在A的代码中显式的new一个B的对象。 采用依赖注入技术之后，A的代码只需要定义一个私有的B对象，不需要直接new来获得这个对象，而是通过相关的容器控制程序来将B对象在外部new出来并注入到A类里的引用中。 什么是依赖： 一个类A的实现需要依赖于类B，也就是要用到类B提供的方法 因为大多数应用程序都是由两个或是更多的类通过彼此的合作来实现企业逻辑，这使得每个对象都需要获取与其合作的对象（也就是它所依赖的对象）的引用 为了更好理解DI，我们先来看看通过硬编码来使用依赖： //Hardcoded dependencypublic class MyClass &#123; private MyDependency myDependency = new MyDependency(); &#125; 再来看看依赖注入的方式： //Injected dependencypublic class MyClass &#123; private MyDependency myDependency; public MyClass(MyDependency myDependency)&#123; this.myDependency = myDependency; &#125;&#125; 我们可以有多种方式实现把依赖注入，常见是通过构造器或者setter方法 IoC和DI 通过IoC容器来创建对象，并自动把相关的依赖对象注入进去，我们程序员只需要定义类之间的依赖即可，依赖注入这件事交给IoC容器即可 public class MyClass1 &#123; @Autowired // IoC容器会自动生成好myClass2对象 private MyClass2 myClass2; public void doSomething()&#123; myClass2.doSomething(); &#125;&#125; public class MyClass2 &#123; @Autowired // IoC容器会自动生成好对象,并将引用赋值给myclass3 private MyClass3 myClass3; @Autowired // IoC容器会自动生成好对象,并将引用赋值给myclass4 private MyClass4 myClass4; public void doSomething()&#123; myClass3.doSomething(); myClass4.doSomething(); &#125;&#125; 个人理解： 一个应用程序一般都是多个类相互合作 （1）传统开发方式：如果类A需要用到类B提供的功能，那么需要在类A中创建类B(也就是new 对象)，如果发生需求变更，也就是现在有了C类，我们发现他能实现和B类一样的功能，但是性能更加出色，于是如果我们想要用C类的功能，那么就需要更改原系统的代码，把那些用到B类的地方，全部换掉。这样很麻烦 （2）现在有了Spring提供的IoC容器，相当于在类A和类B之间加了一个中间层（这里我们称为Container）,由我们的Container利用反射去生成我们需要的对象。现在A类需要B类，那么只需要从Container里面拿。那么如果要用类C替换类B呢，只需要更改Container的配置文件，把B类改为C类，那么容器利用反射，生成的就是C类的对象。这样就可以做到无需要更改源代码。 参考： https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/1158025?fromtitle=%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5&amp;fromid=5177233 https://dzone.com/articles/ioc-vs-di AOP面向切面编程基本概念： 面向对象编程的基本单位是类，而面向切面编程的基本单位是切面 [具体可以看看这篇博文章：Spring AOP就是这么简单]: https://juejin.im/post/5b06bf2df265da0de2574ee1 “Spring AOP就是这么简单” 底层实现：动态代理 JDK动态代理，需要实现接口 Cglib动态代理，通过继承，产生子类 个人理解： （1）比如我们在业务层有多个方法需要开启关闭事务，可以看到以下代码有很多重复代码 &gt; public void service1()&#123;&gt; openTransaction(); // 开启事务&gt; // 业务逻辑代码&gt; closeTransaction(); // 关闭事务&gt; &#125;&gt; public void service2()&#123;&gt; openTransaction(); // 开启事务&gt; // 业务逻辑代码&gt; closeTransaction(); // 关闭事务&gt; &#125;&gt; public void service3()&#123;&gt; openTransaction(); // 开启事务&gt; // 业务逻辑代码&gt; closeTransaction(); // 关闭事务&gt; &#125;&gt; .....&gt; （2）采用面向切面编程，我们将进行横向切割， 把不是业务逻辑的代码抽取出来，形成一个模块，单独进行维护 &gt; class Aspect&#123;&gt; openTransaction()&#123;&gt; &gt; &#125;&gt; closeTransaction()&#123;&gt; &gt; &#125;&gt; &#125;&gt; （3）最后 通过动态代理的方式 将横切出来的逻辑代码，融合到业务逻辑中 使用XML管理BeanBean配置方式将bean交给Spring管理，那么Spring是怎么创建对象的呢？ 三种方法： 无参构造方法的方式 静态工厂实例化的方式:对象通过工厂类的静态方法获得目标对象 实例工厂实例化的方式:需要实例化工厂，调用工厂对象的方法获取目标对象 1.无参构造方法的方式（常用） 编写类Bean public class Bean &#123; public Bean() &#123; System.out.println(\"Bean的构造函数\"); &#125; &#125; 在xml文件中配置 &lt;!-- 通过无参构造函数 获取Bean对象--&gt;&lt;bean id=\"bean1\" class=\"BeanXML.Bean\"/&gt; 测试 @Testpublic void demo1() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"BeanXML.xml\"); Bean bean = (Bean)context.getBean(\"bean1\");&#125; 2.静态工厂实例化的方式 编写工厂类，Bean类同上 /** * 静态工厂 */public class BeanFactory &#123; static public Bean getBean() &#123; System.out.println(\"通过BeanFactory静态方法获取Bean对象\"); return new Bean(); &#125;&#125; 在xml文件中进行配置 &lt;!-- 通过BeanFactory静态方法获取Bean对象 --&gt;&lt;bean id=\"bean2\" class=\"BeanXML.BeanFactory\" factory-method=\"getBean\"/&gt; 3.实例工厂实例化的方式 编写工厂类 /** * 实例工厂 */public class BeanFactory1 &#123; public Bean getBean() &#123; System.out.println(\"先获得BeanFactory1的对象，再调用对象中的方法获得Bean对象\"); return new Bean(); &#125;&#125; 在xml文件需要配置两个bean标签,一个是工厂类对象，一个是Bean类对象 &lt;!-- 先获得BeanFactory1的对象，再调用对象中的方法获得Bean对象 --&gt;&lt;bean id=\"beanFactory1\" class=\"BeanXML.BeanFactory1\" /&gt;&lt;bean id=\"bean3\" class=\"BeanXML.Bean\" factory-bean=\"beanFactory1\" factory-method=\"getBean\"/&gt; 属性注入1. 通过构造方法进行属性注入注意：类person需要实现相应的构造函数 &lt;bean id=\"person\" class=\"pojo.Person\"&gt; &lt;constructor-arg name=\"id\" value=\"1\"/&gt; &lt;constructor-arg name=\"name\" value=\"雄\"/&gt; &lt;constructor-arg name=\"age\" value=\"2\"/&gt;&lt;/bean&gt; 2.Set方法的属性注入注意：类中需要实现相应的setter方法 &lt;!-- name表示对象中的属性名 --&gt;&lt;!-- value注入普通属性 --&gt;&lt;!-- ref注入对象属性，前提是该对象需要交给IoC容器管理 --&gt;&lt;bean id=\"phone\" class=\"pojo.Phone\"&gt; &lt;property name=\"id\" value=\"1\"/&gt; &lt;property name=\"name\" value=\"小米\"/&gt; &lt;property name=\"money\" value=\"1999\"/&gt;&lt;/bean&gt;&lt;bean id=\"person\" class=\"pojo.Person\"&gt; &lt;property name=\"id\" value=\"1\"/&gt; &lt;property name=\"name\" value=\"雄\"/&gt; &lt;property name=\"age\" value=\"2\"/&gt; &lt;property name=\"phone\" ref=\"phone\"/&gt;&lt;/bean&gt; 3.通过引入p名称空间完成属性的注入（1）需要引入p名称空间 写法： 普通属性 p:属性名=”值” 对象属性 p:属性名-ref=”配置bean标签的id” （2）配置如下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" &lt;!-- 引入p名称空间 --&gt; xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;bean id=\"phone\" class=\"pojo.Phone\" p:id=\"1\" p:name=\"小米\" p:money=\"1999\"/&gt;&lt;bean id=\"person\" class=\"pojo.Person\" p:id=\"1\" p:name=\"雄\" p:age=\"2\" p:phone-ref=\"phone\"/&gt;&lt;/beans&gt; 4.SpEL的属性注入（Spring3.0以后）（1）SpEL：Spring Expression Language，Spring的表达式语言 （2）使用见例子： &lt;!-- phoneinfo有个name属性还有一个 calculateMonney()方法--&gt;&lt;bean id=\"phoneinfo\" class=\"pojo.PhoneInfo\"&gt; &lt;property name=\"name\" value=\"小米\"/&gt;&lt;/bean&gt;&lt;!-- 通过SpEL 可以调用其他bean的方法和属性 --&gt; &lt;bean id=\"phone\" class=\"pojo.Phone\"&gt; &lt;property name=\"name\" value=\"#&#123;phoneinfo.name&#125;\"/&gt; &lt;property name=\"money\" value=\"#&#123;phoneinfo.calculateMonney()&#125;\"/&gt;&lt;/bean&gt;&lt;!-- 通过SpEL 也可以注入基本类型数据，字符串用单引号 --&gt; &lt;bean id=\"person\" class=\"pojo.Person\"&gt; &lt;property name=\"name\" value=\"#&#123;'雄'&#125;\"/&gt; &lt;property name=\"age\" value=\"#&#123;2&#125;\"/&gt; &lt;property name=\"phone\" ref=\"phone\"/&gt;&lt;/bean&gt; 5.集合类型属性注入&lt;bean id=\"collectionBean\" class=\"pojo.CollectionBean\"&gt; &lt;!-- 数组类型 --&gt; &lt;property name=\"array\"&gt; &lt;list&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 注入list集合 --&gt; &lt;property name=\"lists\"&gt; &lt;list&gt; &lt;value&gt;雄&lt;/value&gt; &lt;value&gt;俊&lt;/value&gt; &lt;value&gt;彬&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 注入set集合 --&gt; &lt;property name=\"set\"&gt; &lt;set&gt; &lt;value&gt;肥熊雄&lt;/value&gt; &lt;value&gt;肥俊&lt;/value&gt; &lt;value&gt;彬&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- 注入Map集合 --&gt; &lt;property name=\"map\"&gt; &lt;map&gt; &lt;entry key=\"1\" value=\"111\"/&gt; &lt;entry key=\"2\" value=\"222\"/&gt; &lt;entry key=\"3\" value=\"333\"/&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 其他 在一个配置文件中引入其他配置文件 &lt;import resource=\"\"/&gt; bean标签中的其他属性 scope取值： singleton 单例模式（默认） prototype 多例 lazy-init取值： true 使用到bean对象时才创建 false（默认）IoC容器创建好之后，就创建好所有管理的bean对象 init-method ：对象在创建后，执行某个方法 destroy-method： &lt;bean id=\"user\" class=\"User\" scope=\"singleton\" lazy-init=\"true\" init-method=\"\" destroy-method=\"\"/&gt; Spring 中IoC注解方式的使用相关注解： @ComponentScan扫描器 @Configuration表明该类是配置类 @Component 指定把一个对象加入IOC容器—&gt;@Name也可以实现相同的效果【一般少用】 @Repository 作用同@Component； 在持久层使用 @Service 作用同@Component； 在业务逻辑层使用 @Controller 作用同@Component； 在控制层使用 @Resource 依赖关系 如果@Resource不指定值，那么就根据类型来找，相同的类型在IOC容器中不能有两个 如果@Resource指定了值，那么就根据名字来找 直接上例子： （0）配置文件 &lt;!-- 指定包名，spring就会到包里扫描，需要被Spring管理的对象 --&gt;&lt;context:component-scan base-package=\"IoC_annotation\"&gt;&lt;/context:component-scan&gt; &lt;!-- 如果类上没有注解标记被Spring管理，但是需要使用属性注入的相关注解，就设置该注解 --&gt;&lt;context:annotation-config/&gt; （1）接口 public interface UserDao &#123; void save();&#125; public interface UserService &#123; void save();&#125; （2）实现类 @Component(\"userDao\") // 相当于在xml中配置bean标签 其中id为\"userDao\"// @Component修饰一个类，将这个类交给Spring管理public class UserDaoImp implements UserDao &#123; @Value(\"小熊\") // 设置属性值 private String name; private int age; @Value(\"100\") // 也可以在setter方法使用注解设置属性的值 public void setAge(int age) &#123; this.age = age; &#125; @Override public void save() &#123; System.out.println(\"UserDaoImp---save() name=\"+name + \" age=\"+age); &#125;&#125; @Service(\"userService\")public class UserServiceImp implements UserService&#123; // 注入UserDao //@Autowired // 这种方式Spring自动去找符合类型的对象，该对象必须被Spring管理 //private UserDao userDao; @Resource(name=\"userDao\") // 按名称查找对象并注入 private UserDao userDao; @Override public void save() &#123; userDao.save(); System.out.println(\"UserServiceImp.save()\"); &#125;&#125; Spring AOP 利用注解方式 编写目标类（需要被增强的类，也就是被代理的类） // 如果不使用接口，Spring底层会使用Cglib动态代理public class OrderDao &#123; public void save() &#123; System.out.println(\"保存订单\"); &#125; public void delete() &#123; System.out.println(\"删除订单\"); &#125; public void update() &#123; System.out.println(\"更新订单\"); &#125; public void find() &#123; System.out.println(\"查找订单\"); int a = 1/0; // 为了抛出异常 System.out.println(a); &#125;&#125; 配置文件中配置目标类 &lt;!-- 配置目标对象 --&gt;&lt;bean id=\"orderDao\" class=\"aop_annotation.OrderDao\"/&gt; 编写切面类 public class MyAspectAnnotation &#123; &#125; 配置文件中配置切面类 &lt;!-- 配置切面类 --&gt;&lt;bean id=\"myAspect\" class=\"aop_annotation.MyAspectAnnotation\"/&gt; 在配置文件中开启注解的AOP开发 &lt;aop:aspectj-autoproxy/&gt; 在切面类上使用注解 @Aspectpublic class MyAspectAnnotation &#123; // 前置通知 @Before(value=\"execution(* aop_annotation.OrderDao.save(..))\") public void before() &#123; System.out.println(\"前置增强.....\"); &#125; // 后置通知 @AfterReturning(value=\"execution(* aop_annotation.OrderDao.delete(..))\",returning=\"result\") public void after(Object result) &#123; System.out.println(\"后置增强。。。\" + result); &#125; // 环绕通知 @Around(value=\"execution(* aop_annotation.OrderDao.update(..))\") public Object around(ProceedingJoinPoint joinPoint) throws Throwable &#123; System.out.println(\"环绕增强前======\"); Object proceed = joinPoint.proceed(); System.out.println(\"环绕增强后======\"); return proceed; &#125; // 异常抛出通知 @AfterThrowing(value=\"execution(* aop_annotation.OrderDao.find(..))\", throwing=\"e\") public void afterThrowing(Throwable e) &#123; System.out.println(\"#####异常抛出增强\" + e.getMessage()); &#125; // 最终通知 @After(value=\"execution(* aop_annotation.OrderDao.find(..))\") public void finalNotice() &#123; System.out.println(\"最终通知*********\"); &#125;&#125; 注意：如果切入点更改，那么需要改很多处地方。比如OderDao里面的find方法改名了（见下面的代码），改成了search，那么下面代码中的注解都要进行更改 // 异常抛出通知@AfterThrowing(value=\"execution(* aop_annotation.OrderDao.find(..))\", throwing=\"e\")// 最终通知@After(value=\"execution(* aop_annotation.OrderDao.find(..))\") 可以使用注解配置切入点，解决上面的问题 // 异常抛出通知//注意切入点写法:类名.方法名()@AfterThrowing(value=\"MyAspectAnnotation.pointCnt1()\", throwing=\"e\")public void afterThrowing(Throwable e) &#123; System.out.println(\"#####异常抛出增强\" + e.getMessage()); &#125;// 最终通知//注意切入点写法:类名.方法名()@After(value=\"MyAspectAnnotation.pointCnt1()\") public void finalNotice() &#123; System.out.println(\"最终通知*********\");&#125;@Pointcut(value=\"execution(* aop_annotation.OrderDao.find(..))\")private void pointCnt1() &#123;&#125; 测试 /** * @RunWith(SpringJUnit4ClassRunner.class) * @ContextConfiguration(\"classpath:aopAnnotation.xml\") 配置文件路径 * 这两个注解是spring整合JUnit */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:aopAnnotation.xml\")public class Demo &#123; @Resource(name=\"orderDao\") private OrderDao orderDao; @Test public void demo() &#123; orderDao.save(); orderDao.delete(); orderDao.update(); orderDao.find(); &#125;&#125;/* 运行结果：前置增强.....保存订单删除订单后置增强。。。操作员：小雄环绕增强前======更新订单环绕增强后======查找订单最终通知#####异常抛出增强/ by zero*/ Spring AOP xml方式 将需要被增强的对象交给IoC容器管理 public class ProductDaoImp implements ProductDao &#123; @Override public void save() &#123; System.out.println(\"保存商品\"); &#125; @Override public void update() &#123; System.out.println(\"更新商品\"); &#125; @Override public void find() &#123; System.out.println(\"查找商品\"); &#125; @Override public void delete() &#123; System.out.println(\"删除商品\"); &#125;&#125; &lt;!-- 配置被增强的对象 --&gt; &lt;bean id=\"productDao\" class=\"aop.ProductDaoImp\"/&gt; 编写切面类，并将切面类交给IoC容器管理 /** * 切面类 */public class MyAspectXML &#123; /** * 前置通知 * @param joinPoint */ // 可以通过参数里面设置 Joinpoint joinPoint 传入切入点信息 // 切入点就是，我们要增强的方法 public void checkPri(JoinPoint joinPoint) &#123; System.out.println(\"权限检测-----\" + joinPoint); &#125; /** * 后置通知 */ // 可以通过后置通知获取切入点返回的值 public void writeLog() &#123; System.out.println(\"日志记录--------\"); &#125; /** * 环绕通知 * @throws Throwable */ public Object around(ProceedingJoinPoint joinPoint) throws Throwable &#123; System.out.println(\"环绕前通知-----\"); Object object = joinPoint.proceed(); System.out.println(\"环绕后通知-----\"); return object; &#125; &#125; &lt;!-- 将切面交给Spring管理 --&gt;&lt;bean id=\"myAspect\" class=\"aop.MyAspectXML\"/&gt; 在xml中进行aop配置 &lt;!-- 通过AOP配置，完成对目标类产生代理 --&gt;&lt;!-- expression 配置哪些类的哪些方法需要增强 --&gt;&lt;aop:config&gt; &lt;!-- 切面 --&gt; &lt;aop:aspect ref=\"myAspect\"&gt; &lt;!-- 切入点 --&gt; &lt;aop:pointcut expression=\"execution(* aop.ProductDaoImp.save(..))\" id=\"pointcut1\"/&gt; &lt;!-- 前置通知 --&gt; &lt;aop:before method=\"checkPri\" pointcut-ref=\"pointcut1\"/&gt; &lt;!-- 切入点 --&gt; &lt;aop:pointcut expression=\"execution(* aop.ProductDaoImp.update(..))\" id=\"pointcut2\"/&gt; &lt;!-- 后置通知 --&gt; &lt;!-- 如果后置通知需要获取返回值，那么需要在 method里设置参数Object retVal --&gt; &lt;aop:after-returning method=\"writeLog\" pointcut-ref=\"pointcut2\" returning=\"retVal\"/&gt; &lt;!-- 切入点 --&gt; &lt;aop:pointcut expression=\"execution(* aop.ProductDaoImp.find(..))\" id=\"pointcut3\"/&gt; &lt;!-- 环绕通知 --&gt; &lt;aop:around method=\"around\" pointcut-ref=\"pointcut3\" /&gt; &lt;/aop:a spect&gt;&lt;/aop:config&gt; Spring的JDBC模板使用/** * Spring JDBC模板的使用 * @author Saber * */public class JDBCDemo1 &#123; @Test // JDBC模板的使用类似JbUtil public void demo1() &#123; // 创建连接池 DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\"); dataSource.setUsername(\"root\"); dataSource.setPassword(\"123456\"); dataSource.setUrl(\"jdbc:mysql:///aa\"); // 创建jdbc模板 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); jdbcTemplate.update(\"insert into person values (null, ?, ?)\", \"雄\", 10); &#125;&#125; 我们观察上面的代码发现：DriverManagerDataSource和JdbcTemplate这两个类需要我们自己创建，我们可以将他们交给Spring容器管理 (1)配置文件 spring_jdbc.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns = \"http://www.springframework.org/schema/beans\" xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop = \"http://www.springframework.org/schema/aop\" xsi:schemaLocation = \" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 将Spring内置的JDBC连接池(org.springframework.jdbc.datasource.DriverManagerDataSource)交给Spring管理 --&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;!-- dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\"); dataSource.setUsername(\"root\"); dataSource.setPassword(\"123456\"); dataSource.setUrl(\"jdbc:mysql:///aa\"); 依赖注入 --&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///aa\"/&gt; &lt;/bean&gt; &lt;!-- 将org.springframework.jdbc.core.JdbcTemplate交由Spring容器管理 --&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt;&lt;/beans&gt; (2)测试代码 @Test// 使用IoC修改demo1public void demo2() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"spring_jdbc.xml\"); // 从Spring容器中获取jdbc模板对象 JdbcTemplate jdbcTemplate = (JdbcTemplate)context.getBean(\"jdbcTemplate\"); jdbcTemplate.update(\"insert into person values (null, ?, ?)\", \"肥雄\", 100);&#125; 使用第三方连接池 常用第三方连接池有dbcp 和 c3p0，下面以dbcp为例子 引入jar包 配置文件中配置 &lt;!-- 如果需要使用dpcp连接池 --&gt;&lt;bean id=\"dbcpDataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///aa\"/&gt;&lt;/bean&gt;&lt;!-- 将org.springframework.jdbc.core.JdbcTemplate交由Spring容器管理 --&gt;&lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dbcpDataSource\"/&gt;&lt;/bean&gt; 测试代码 @Testpublic void demo2() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"spring_jdbc.xml\"); // 从Spring容器中获取jdbc模板对象 JdbcTemplate jdbcTemplate = (JdbcTemplate)context.getBean(\"jdbcTemplate\"); jdbcTemplate.update(\"insert into person values (null, ?, ?)\", \"大肥雄\", 1000);&#125; 观察上方配置文件中的对连接池对象的属性注入，如果配置有多个连接池，如果要对username这个属性进行更改，那么需要改很多处地方。 解决办法：引入外部属性文件 创建一个属性文件 jdbc.properties jdbc.driverClass=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql:///aajdbc.username=rootjdbc.password=123456 在spring配置文件中引入属性文件 &lt;!-- 引入属性文件================================== --&gt; &lt;!-- 第一种方式通过一个bean标签引入的（很少） --&gt;&lt;!-- &lt;bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;property name=\"location\" value=\"classpath:jdbc.properties\"/&gt; &lt;/bean&gt; --&gt; &lt;!-- 第二种方式通过context标签引入的 --&gt; &lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt; 通过${key} 就可以获取属性文件中的value值 &lt;!-- 配置C3P0连接池=============================== --&gt;&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driverClass&#125;\"/&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;!-- 注意C3p0的url有些不同 --&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt;&lt;/bean&gt; CRUD操作 创建数据库表 CREATE TABLE `person` ( `id` BIGINT PRIMARY KEY AUTO_INCREMENT, `name` VARCHAR(50), `age` INT) 整合JUnit 和 Spring，方便进行测试 @RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:spring_jdbc.xml\")public class CRUD &#123; @Resource(name=\"jdbcTemplate\") private JdbcTemplate jdbcTemplate; @Test public void demo() &#123; // 直接使用jdbcTemplate进行测试 &#125; &#125; 保存操作 @Test// 保存操作public void demo1() &#123; jdbcTemplate.update(\"insert into person values(null, ?, ?)\", \"西伯利亚雄\", 2);&#125; 修改操作 @Test// 修改操作public void demo2() &#123; jdbcTemplate.update(\"update person set name = ? where id = ?\", \"希伯里\", 1);&#125; 删除操作 @Test// 删除操作public void demo3()&#123; jdbcTemplate.update(\"delete from person where id = ?\", 1);&#125; 查询某个字段，并把结果进行封装成相应的对象 @Test// 查询操作public void demo4()&#123; Long count = jdbcTemplate.queryForObject(\"select count(*) from person\", Long.class); System.out.println(count);&#125; 查询一条记录，将结果封装到实体类中，需要实现RowMapper接口，将结果集的字段与对象属性对应 @Test// 封装到一个对象中public void demo5()&#123; // 自定义的RowMapper，具有一定的通用性 MyRowMapper&lt;Person&gt; rowMapper = new MyRowMapper&lt;&gt;(Person.class); Person person = (Person) jdbcTemplate.queryForObject(\"select * from person where id = ?\", rowMapper,2); System.out.println(person);&#125; RowMapper 通用实现，利用反射 public class MyRowMapper&lt;T&gt; implements RowMapper&lt;T&gt;&#123; private Class&lt;?&gt; targetClazz; // 保存属性名与Field对象的映射，方便从数据库字段名定位Field对象 private Map&lt;String, Field&gt; fieldMap; // 构造方法 public MyRowMapper(Class&lt;?&gt; targetClazz)&#123; this.targetClazz = targetClazz; fieldMap = new HashMap&lt;String, Field&gt;(); // 获取类的全部属性，包括私有属性 Field[] declaredFields = this.targetClazz.getDeclaredFields(); for(int i=0;i&lt;declaredFields.length;++i) &#123; // 存储时，将属性名称全部化为小写，方便比较 String name = declaredFields[i].getName().toLowerCase(); fieldMap.put(name, declaredFields[i]); &#125; &#125; @Override public T mapRow(ResultSet rs, int rowNumber) throws SQLException &#123; ResultSetMetaData metaData = rs.getMetaData(); int columnCount = metaData.getColumnCount(); Object obj = null; try &#123; obj = targetClazz.newInstance(); for(int i=0;i&lt;columnCount;++i) &#123; String colName = metaData.getColumnName(i+1);// ColumnName下标从1开始 // 去除数据库字段名的下划线 colName = colName.replaceAll(\"_\", \"\"); // 转化为小写 colName = colName.toLowerCase(); Field field = fieldMap.get(colName); field.setAccessible(true); field.set(obj, rs.getObject(i+1)); // 下标从1开始 field.setAccessible(false); &#125; &#125; catch (InstantiationException | IllegalAccessException e) &#123; e.printStackTrace(); &#125; return (T)obj; &#125;&#125; 查询多条记录 @Test// 查询多条记录public void demo6() &#123; MyRowMapper&lt;Person&gt; rowMapper = new MyRowMapper&lt;&gt;(Person.class); List&lt;Person&gt; persons = jdbcTemplate.query(\"select * from person\", rowMapper); System.out.println(persons);&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://chsobin.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://chsobin.github.io/tags/Spring/"}]},{"title":"JVM内存划分","date":"2019-04-08T15:25:21.000Z","path":"2019/04/08/JVM内存划分/","text":"本文是笔者阅读《深入理解Java虚拟机》的读书笔记 Java虚拟机规范根据Java虚拟机规范，运行时数据区域可以划分为如下： 由所有线程共享的数据区： 方法区 堆 线程隔离的数据区： 虚拟机栈 本地方法栈 程序计数器 规范是这样划分的，但具体的虚拟机实现不一样，不同版本的虚拟机也不一样 下面以JDK8的HotSpot虚拟机为例，进行划分 HotSpot虚拟机内存划分 jvm内存划分 程序计数器记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。 Java 虚拟机栈是什么？ Java方法执行的内存模型 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。 从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。 如何设置大小？ # 设置一个线程的栈大小java -Xss128K Class文件 该区域可能抛出以下异常： 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常； 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。 堆所有对象都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）。 # 可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。java -Xms1M -Xmx2M HackTheJava 注意： 永久代是HotSpot对方法区的实现 永久代物理是是堆的一部分，和新生代，老年代地址是连续的 HotSpot在1.8之后取消了永久代，改为元空间 元空间使用本地内存 元空间存储类的元信息 静态变量和常量池等并入堆中 相当于永久代的数据被分到了堆和元空间中。 HotSpot虚拟机对象对象内存布局 堆对象内存布局 对象头 Mark Word 这部分数据长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit 对象需要存储的运行时数据很多，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储更多的信息 也就是说，对象在不同的状态下，这个Mark Word各个字段代表的意思也会跟着改变 eg:下面举个例子说明，具体应该结合jvm中锁的实现来理解 // (1)normal object正常对象 // hash:25bit age:4bit biased_lock:1bit lock:2bit// (2)biased object// JavaThread*:23bit epoch:2bit age:4bit biased_lock:1bit lock:2bit// 还有其他状态的对象 具体可以参考https://blog.csdn.net/zhoufanyang_china/article/details/54601311 https://www.cnblogs.com/duanxz/p/4967042.html 类型指针 指向对象所属类的元数据，（如果是使用句柄的方式定位对象，则不需要） 下文会具体展开通过句柄来定位对象在堆中的位置 如果对象是一个数组，那么对象头还需要存储数组的大小 实例数据各种类型字段的内容，也就是类的普通属性成员 对齐填充由于HotSpot VM 的自动内存管理系统要求对象起始地址必须是8字节的整数倍，因此需要将对象大小补充为8的倍数 对象的访问定位我们一般使用的是对象的引用，那么引用是如何定位堆中的对象的呢？ 通过句柄访问对象 通过直接指针访问对象 对比 使用句柄，应用类型存储的是稳定的句柄地址，在垃圾回收时，对象被移动，不用更改引用类型的值 使用直接指针，速度更快，减少了一次指针定位的开销","tags":[{"name":"Java","slug":"Java","permalink":"https://chsobin.github.io/tags/Java/"},{"name":"jvm","slug":"jvm","permalink":"https://chsobin.github.io/tags/jvm/"}]},{"title":"hexo搭建博客遇到的问题汇总","date":"2019-04-03T01:31:11.000Z","path":"2019/04/03/hexo搭建博客遇到的问题汇总/","text":"代码块必须指明语言，不然运行hexo g 命令会报错： TypeError: Cannot set property ‘lastIndex’ of undefined解决方法： 在 _config.yml 中设置 auto_detect: false 确保你的代码块有指定语言: 为了找到是哪一个post产生问题，可以移除所有的post,一个个添加回去，然后运行”hexo g”,看是否会报错 markdown 中的表格，开头不能有空格，不然会渲染失败 这个问题，我提过issue，后来发现问题就关闭了，详情可以看： https://github.com/yscoder/hexo-theme-indigo/issues/467","tags":[{"name":"hexo","slug":"hexo","permalink":"https://chsobin.github.io/tags/hexo/"}]},{"title":"Java知识点总结","date":"2019-04-02T14:01:21.000Z","path":"2019/04/02/Java知识点总结/","text":"前言 这篇文章是对Java相关知识点的简要总结，主要记录了我个人之前所忽略的知识点 对于每个工具类的使用，这里不做详细探讨，具体可以参照官方文档，https://docs.oracle.com/javase/8/docs/api/ 入门基础 Java程序运行机制 编译和解释结合 *.java 源文件 编译成 *.class 字节码文件jvm解释执行字节码文件 面试题：Java是解释执行的，对吗？ 解答： Java引进JIT技术之后，能将一些热点代码直接编译成机器语言 JIT 是 just in time 的缩写, 也就是即时编译编译器。使用即时编译器技术，能够加速 Java 程序的执行速度。下面，就对该编译器技术做个简单的讲解。 首先，我们大家都知道，通常通过 javac 将程序源代码编译，转换成 java 字节码，JVM 通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢很多。为了提高执行速度，引入了 JIT 技术。 在运行时 JIT 会把翻译过的机器码保存起来，以备下次使用，因此从理论上来说，采用该 JIT 技术可以接近以前纯编译技术。 jvm、jre、jdk jar 包 就是一些字节码文件进行打包 成员变量 与 局部变量 成员变量会自动初始化为默认值；局部变量必须先赋值才能使用 常量命名规范：大写+下划线 如 MAX_VALUE int范围 -2^31 到 2^31-1 java浮点常量 可以用科学计数法表示 eg: 314e2=31400 314E2=31400 314E-2=3.14 switch语句中case标签在JDK1.5之前必须是整数(long类型除外)或者枚举，不能是字符串，在JDK1.7之后允许使用字符串(String)。 重载：方法名相同，参数类型，个数，顺序不同 面向对象基础 java 内存模型 - 静态导入 jdk5之后的新特性 其作用是用于导入指定类的静态属性，这样我们可以直接使用静态属性。 import static java.lang.Math.*;//导入Math类的所有静态属性import static java.lang.Math.PI;//导入Math类的PI属性 方法的重写需要符合下面的三个要点： ​ 1.“==”： 方法名、形参列表相同。 ​ 2.“≤”：返回值类型和声明异常类型，子类小于等于父类。 ​ 3.“≥”： 访问权限，子类大于等于父类。 访问权限修饰符 修饰符 同一个类 同一个包 子类 所有类 private Y 不可访问 不可访问 不可访问 default Y Y 不可访问 不可访问 protected Y Y Y 不可访问 public Y Y Y Y 抽象类 有抽象方法的类，abstract关键字修饰 接口 interface可以继承多个接口，class可以实现多个接口 接口所有方法都是抽象，默认是 public abstract 接口里面的变量，默认都是 public static final,(也即是接口里面只能定义常量) 匿名内部类 不会生成.class文件。只能使用一次 匿名内部类中不能存在任何的静态成员变量和静态方法。 匿名内部类没有构造器，可以使用构造代码块代替 异常机制 –- Exception和Error的区别：Exception能被程序本身可以处理，Error是程序无法处理- 需要注意的是，一旦某个catch捕获到匹配的异常类型，将进入异常处理代码。一经处理结束，就意味着整个try-catch语句结束。其他的catch子句不再有匹配和捕获异常类型的机会。package exception;public class Demo &#123; public static void checkZero()&#123; for(int i=3;i&gt;=-1;--i)&#123; int ans = 10/i; System.out.println(\"i=\" + i); &#125; &#125; public static void main(String[] args) &#123; try &#123; checkZero(); // 一个异常只会被一个catch捕捉 &#125;catch (ArithmeticException mathException)&#123; System.out.println(\"catch ArithmeticException\"); &#125;catch (Exception exception)&#123; System.out.println(\"catch Exception\"); &#125;finally &#123; System.out.print(\"finally\"); &#125; &#125;&#125;/** * 执行结果： * i=3 * i=2 * i=1 * catch ArithmeticException * finally */ 容器 Java集合 Java集合框架图 1、所有集合类都位于java.util包下。Java的集合类主要由两个接口派生而出：Collection和Map，Collection和Map是Java集合框架的根接口，这两个接口又包含了一些子接口或实现类。 2、集合接口：6个接口（短虚线表示），表示不同集合类型，是集合框架的基础。 3、抽象类：5个抽象类（长虚线表示），对集合接口的部分实现。可扩展为自定义集合类。 4、实现类：8个实现类（实线表示），对接口的具体实现。 5、Collection 接口是一组允许重复的对象。 6、Set 接口继承 Collection，集合元素不重复。 7、List 接口继承 Collection，允许重复，维护元素插入顺序。 8、Map接口是键－值对象，与Collection接口没有什么关系。 9、Set、List和Map可以看做集合的三大类： List集合是有序集合，集合中的元素可以重复，访问集合中的元素可以根据元素的索引来访问。 Set集合是无序集合，集合中的元素不可以重复，访问集合中的元素只能根据元素本身来访问（也是集合里元素不允许重复的原因）。 Map集合中保存Key-value对形式的元素，访问时只能根据每项元素的key来访问其value。 IO流技术 如何理解流？ 流是个抽象的概念，是对输入输出设备的抽象，Java程序中，对于数据的输入/输出操作都是以“流”的方式进行。设备可以是文件，网络，内存等。 摘自Oracle官方文档：https://docs.oracle.com/javase/tutorial/essential/io/streams.html An I/O Stream represents an input source or an output destination. A stream can represent many different kinds of sources and destinations, including disk files, devices, other programs, and memory arrays. Streams support many different kinds of data, including simple bytes, primitive data types, localized characters, and objects. Some streams simply pass on data; others manipulate and transform the data in useful ways. No matter how they work internally, all streams present the same simple model to programs that use them: A stream is a sequence of data. 常用类 （学习使用的最好方法就是jdk api 文档） File 表示数据源 //文件路径建议String path = \"D:/dir/a.txt\"// 或者String path2 = \"D:\" + File.separator + \"dir\" + File.separator + \"a.txt\"; 四大抽象类 InputStream OutputStream Reader Writer FileInputStream FileOutputStream 文件字节流 ，数据在硬盘 ByteArrayInputStream ByteArrayOutputStream 字节数组流，数据源在虚拟机内存 解码、编码 编码： 字符 ——– 使用特定字符集（如UTF-8 ）——-&gt; 字节 解码： 字节 ———-使用特定字符集 ———&gt;字符 出现乱码的原因 String msg = \"你好啊\";byte[] datas = msg.getBytes(); // 默认使用工程的字符集进行编码，此处假设为UTF-8//(1) 字节数不够msg = new String(datas, 0, datas.length-1, \"utf8\");System.out.println(msg);//(2) 编码解码的字符集不同msg = new String(datas, \"gbk\");System.out.println(msg); IO操作基本步骤 选择数据源 选择数据流 读或者写操作 释放资源 IO相关类 很多利用了 装饰者模式 FileInputStream fis = new FileInputStream(src);BufferedInputStream bis = new BufferedInputStream(fis);// 将FileInputStream对象作为参数传入 多线程 java多线程三种实现方法 继承Thread类 实现Runnable接口 实现Callable接口 实现Runnable接口这种方式用到了静态代理这个设计模式 new Thread(实现了Runnable接口的对象).start(); 静态代理设计模式： 代理模式主要包含三个角色，即抽象主题角色(Subject)、委托类角色(被代理角色，Proxied)以及代理类角色(Proxy)，如上图所示： 抽象主题角色:可以是接口，也可以是抽象类；委托类角色：真实主题角色，业务逻辑的具体执行者；代理类角色：内部含有对真实对象RealSubject的引用，负责对真实主题角色的调用，并在真实主题角色处理前后做预处理和后处理。 // 接口interface Driverable&#123; void drive();&#125;// 被代理角色class Car implements Driverable&#123; @Override public void drive() &#123; System.out.println(\"moving...\"); &#125;&#125;// 代理角色class SmartCar implements Driverable&#123; private Driverable target; // 持有被代理对象 public SmartCar(Driverable target) &#123; this.target = target; &#125; @Override public void drive() &#123; begin(); // 增强功能 target.drive(); end(); // 增强功能 &#125; private void begin() &#123; System.out.println(\"启动智能系统\"); &#125; private void end() &#123; System.out.println(\"关闭智能系统\"); &#125;&#125; 线程五种状态 新建状态(New) : 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。 就绪状态(Runnable): 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。 运行状态(Running): 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。 阻塞状态(Blocked) : 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种： （1） 等待阻塞 – 通过调用线程的wait()方法，让线程等待某工作的完成。 （2） 同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。 （3）其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。 死亡状态(Dead) : 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 同步块 // obj称之为同步监视器synchronized(obj)&#123; 代码 &#125; obj可以是任何对象，推荐使用共享资源作为同步监视器 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this(即该对象本身)，或class(即类的模子) 注解 是什么： Java注解又称Java标注 Java语言中的类、方法、变量、参数和包等都可以被标注。 和Javadoc不同，Java标注可以通过反射获取标注内容。 在编译器生成类文件时，标注可以被嵌入到字节码中。Java虚拟机可以保留标注内容，在运行时可以获取到标注内容。 元注解 是用于修饰注解的注解，通常用在注解的定义上，例如： @Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125; @Target：注解的作用目标 @Retention：注解的生命周期 @Documented：注解是否应当被包含在 JavaDoc 文档中 @Inherited：是否允许子类继承该注解 自定义注解 定义一个用于数据库表的注解 注解里面可以定义注解元素，格式为类型 元素名() [default 元素值] 如果不指明default值，使用时必须传入元素值 @Target(ElementType.TYPE)//只能应用于类上@Retention(RetentionPolicy.RUNTIME)//保存到运行时public @interface DBTable &#123; String name() default \"\"; &#125; //在类上使用该注解@DBTable(name = \"user\")public class User &#123; // javabean&#125; 包装类 自动装箱，自动拆箱 Integer a = 1; // 自动装箱，编译器会转化为 Integer a = Integer.valueOf(1)int b = a; // 自动拆箱 int b = a.intValue(); 缓存机制，缓存[-128, 127]之间的数字，具体查看Integer.valueOf()源码 Integer x = -128;Integer y = Integer.valueOf(-128);System.out.println(x==y); // trueSystem.out.println(x.equals(y));// true 字符串相关类 StringBuffer 线程安全 StringBuilder 线程不安全 时间处理相关类 时间日期相关类 时间处理类之间的关系 DateFormat 抽象类 与 SimpleDateFormat 使用 public static void main(String[] args) throws ParseException &#123; // new出SimpleDateFormat对象 SimpleDateFormat s1 = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\"); // 将时间对象转换成字符串 String daytime = s1.format(new Date()); System.out.println(daytime); // 将符合指定格式的字符串转成成时间对象.字符串格式需要和指定格式一致。 String time = \"2007-10-7 20:15:30\"; Date date = s1.parse(time); System.out.println(date);&#125; 文件类 常用方法 File f = new File(\"d:/c.txt\");f.createNewFile(); // 会在d盘下面生成c.txt文件f.delete(); // 将该文件或目录从硬盘上删除System.out.println(\"File是否存在：\"+f.exists());System.out.println(\"File是否是目录：\"+f.isDirectory());System.out.println(\"File是否是文件：\"+f.isFile());System.out.println(\"File最后修改时间：\"+new Date(f.lastModified()));System.out.println(\"File的大小：\"+f.length());System.out.println(\"File的文件名：\"+f.getName());System.out.println(\"File的目录路径：\"+f.getPath()); 创建目录 mkdir File f2 = new File(\"d:/电影/华语/大陆\");boolean flag = f2.mkdir(); //目录结构中有一个不存在，则不会创建整个目录树System.out.println(flag);//创建失败 mkdirs File f2 = new File(\"d:/电影/华语/大陆\");boolean flag = f2.mkdirs();//目录结构中有一个不存在也没关系；创建整个目录树System.out.println(flag);//创建成功 枚举 所有的枚举类型隐性地继承自 java.lang.Enum。 枚举实质上还是类，而每个被枚举的成员实质就是一个枚举类型的实例，他们默认都是public static final修饰的。可以直接通过枚举类型名使用它们。 /**季节*/enum Season &#123; SPRING, SUMMER, AUTUMN, WINDTER&#125;/**星期*/enum Week &#123; 星期一, 星期二, 星期三, 星期四, 星期五, 星期六, 星期日&#125; 如何去学习框架 是什么 为什么用 怎么做 小实例，最好跟着官方文档的示例做 框架提供的api ( 相关类的使用 ) 框架相关配置文件 个人理解，配置文件使得我们的系统解耦 一旦需求有变，只需要修改配置文件即可，无需更改源代码 以上为快速入门一个框架，说到底就是先学会怎么用工具，但是仅仅学会用是不够的。在会用的基础上，要站在高位去审视整个框架，去理解框架的架构，去更好地利用框架。如果框架本身提供的功能不能满足我们的需求，我们完全可以修改框架或者创造一个框架出来 高级主题 反射 动态代理 jdbc 网络 多线程 JVM 设计模式 对于高级主题推荐的书籍： 《java 并发编程实战》 《深入理解 java 虚拟机》 《mysql 必知必会》 《大话设计模式》 计算机网络：《TCP/IP详解卷一：协议》","tags":[{"name":"Java","slug":"Java","permalink":"https://chsobin.github.io/tags/Java/"}]},{"title":"测试代码块缩进问题","date":"2019-04-01T18:28:30.000Z","path":"2019/04/02/代码块缩进问题/","text":"问题：使用Typora写文章时，发现从eclipse粘贴过来的代码经过hexo转化之后，缩进出现了错误 如下：明明是四个空格，却显示了8个 public class Demo &#123; @Test public void demo() &#123; Session session = HibernateUtil.openSession(); Transaction tx = session.beginTransaction(); tx.begin(); Customer customer1 = new Customer(); // 新建一个客户对象 customer1.setCust_name(\"客户1\"); LinkMan linkman1_1 = new LinkMan(); // 新建一个联系人 linkman1_1.setLkm_name(\"联系人1，属于客户1\"); linkman1_1.setCustomer(customer1); LinkMan linkMan1_2 = new LinkMan(); // 新建一个联系人 linkMan1_2.setLkm_name(\"联系人2，属于客户1\"); linkMan1_2.setCustomer(customer1); customer1.getLinkMans().add(linkman1_1); customer1.getLinkMans().add(linkMan1_2); // 联系人和客户对象都需要保存 session.save(customer1); session.save(linkman1_1); session.save(linkMan1_2); tx.commit(); session.close(); &#125;&#125; 解决详情参考：https://blog.csdn.net/qq_37932863/article/details/73611785 解决之后，再次粘贴代码：可以看到缩进正常了 public class Demo &#123; @Test public void demo() &#123; Session session = HibernateUtil.openSession(); Transaction tx = session.beginTransaction(); tx.begin(); Customer customer1 = new Customer(); // 新建一个客户对象 customer1.setCust_name(\"客户1\"); LinkMan linkman1_1 = new LinkMan(); // 新建一个联系人 linkman1_1.setLkm_name(\"联系人1，属于客户1\"); linkman1_1.setCustomer(customer1); LinkMan linkMan1_2 = new LinkMan(); // 新建一个联系人 linkMan1_2.setLkm_name(\"联系人2，属于客户1\"); linkMan1_2.setCustomer(customer1); customer1.getLinkMans().add(linkman1_1); customer1.getLinkMans().add(linkMan1_2); // 联系人和客户对象都需要保存 session.save(customer1); session.save(linkman1_1); session.save(linkMan1_2); tx.commit(); session.close(); &#125;&#125;","tags":[{"name":"hexo","slug":"hexo","permalink":"https://chsobin.github.io/tags/hexo/"}]},{"title":"Hibernate学习笔记","date":"2019-04-01T15:52:36.000Z","path":"2019/04/01/Hibernate学习笔记/","text":"是什么 Hibernate是一种ORM(Object Relational Mapping ）框架 它对JDBC进行了非常轻量级的对象封装 hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库 为什么要用 传统基于JDBC的开发，代码重复性过多 使用Hibernate框架，简化了Dao层的编码工作，不用我们写很多繁琐的SQL语句 快速上手注意：此案例基于hibernate-release-5.0.7.Final （1）下载Hibernate 开发环境，解压后有三个主要文件夹 documentation :Hibernate开发的文档 lib :Hibernate开发包 required :Hibernate开发的必须的依赖 optional :Hibernate开发的可选的jar包 project :Hibernate提供的项目 （2）创建一个项目，引入jar包 数据库驱动包 mysql-connector-java-5.1.7-bin.jar Hibernate开发的必须的jar包。 步骤1中required中所有的包 日志记录包 （3）创建表 CREATE TABLE `cst_customer` ( `cust_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '客户编号(主键)', `cust_name` varchar(32) NOT NULL COMMENT '客户名称(公司名称)', `cust_source` varchar(32) DEFAULT NULL COMMENT '客户信息来源', `cust_industry` varchar(32) DEFAULT NULL COMMENT '客户所属行业', `cust_level` varchar(32) DEFAULT NULL COMMENT '客户级别', `cust_phone` varchar(64) DEFAULT NULL COMMENT '固定电话', `cust_mobile` varchar(16) DEFAULT NULL COMMENT '移动电话', PRIMARY KEY (`cust_id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; （4）创建实体类 ​ com.example.hibernate.demo1.Customer.java public class Customer &#123; private Long cust_id; private String cust_name; private String cust_source; private String cust_industry; private String cust_level; private String cust_phone; private String cust_mobile; // 省略getter setter&#125; （5）创建实体类Customer 与表cst_customer的映射 src/com/example/hibernate/demo1/Customer.hbm.xml 命名格式一般为：类名.hbm.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;&lt;hibernate-mapping&gt; &lt;!-- 建立类与表的映射 --&gt; &lt;class name=\"com.example.hibernate.demo1.Customer\" table=\"cst_customer\"&gt; &lt;!-- 建立类中的属性与表中的主键对应 --&gt; &lt;id name=\"cust_id\" column=\"cust_id\" &gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;!-- 建立类中的普通的属性和表的字段的对应 --&gt; &lt;property name=\"cust_name\" column=\"cust_name\" length=\"32\" /&gt; &lt;property name=\"cust_source\" column=\"cust_source\" length=\"32\"/&gt; &lt;property name=\"cust_industry\" column=\"cust_industry\"/&gt; &lt;property name=\"cust_level\" column=\"cust_level\"/&gt; &lt;property name=\"cust_phone\" column=\"cust_phone\"/&gt; &lt;property name=\"cust_mobile\" column=\"cust_mobile\"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 注意： (1)该配置文件的DTD 在hibernate-core-5.0.7.Final.jar包下的/org/hibernate/hibernate-mapping-3.0.dtd (2)在eclipse中设置xml自动提示，需要告诉eclipse相应的DTD文件位置具体设置可以自行百度 （6）创建Hibernate的核心配置文件 Hibernate的核心配置文件的名称：hibernate.cfg.xml 放置在src目录下 该配置文件的DTD 在hibernate-core-5.0.7.Final.jar包下的/org/hibernate/hibernate-configuration-3.0.dtd 具体怎么写可以参考步骤1中project文件夹下的/etc/hibernate.properties &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 连接数据库的基本参数 --&gt; &lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql:///hibernate&lt;/property&gt; &lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt; &lt;property name=\"hibernate.connection.password\"&gt;123456&lt;/property&gt; &lt;!-- 配置Hibernate的方言 --&gt; &lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 可选配置================ --&gt; &lt;!-- 打印SQL --&gt; &lt;property name=\"hibernate.show_sql\"&gt;true&lt;/property&gt; &lt;!-- 格式化SQL ，使得打印出来的SQL语句更加美观--&gt; &lt;property name=\"hibernate.format_sql\"&gt;true&lt;/property&gt; &lt;!-- 映射文件 --&gt; &lt;mapping resource=\"com/example/hibernate/demo1/Customer.hbm.xml\"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; （7）编写测试代码 public class Example &#123; @Test // 保存客户的案例 public void test()&#123; // 1.加载Hibernate的核心配置文件 Configuration configuration = new Configuration().configure(); // 手动加载映射 // configuration.addResource(\"com/example/hibernate/demo1/Customer.hbm.xml\"); // 2.创建一个SessionFactory对象：类似于JDBC中连接池 SessionFactory sessionFactory = configuration.buildSessionFactory(); // 3.通过SessionFactory获取到Session对象：类似于JDBC中Connection Session session = sessionFactory.openSession(); // 4.手动开启事务： Transaction transaction = session.beginTransaction(); // 5.编写代码 Customer customer = new Customer(); customer.setCust_name(\"王西\"); session.save(customer); // 6.事务提交 transaction.commit(); // 7.资源释放 session.close(); sessionFactory.close(); &#125;&#125; 映射的配置 【class标签的配置】建立类与表的映射关系 属性： name ：类的全路径 table ：表名（类名与表名一致，table可以省略） catalog ：数据库名 【id标签的配置】类中的属性与表中的主键的对应关系 属性： name ：类中的属性名 column ：表中的字段名（类中的属性名和表中的字段名如果一致，column可以省略） length ：长度 type ：类型 【property标签的配置】类中的普通属性与表的字段的对应关系 属性： name ：类中的属性名 column ：表中的字段名 length ：长度 type ：类型 not-null ：设置非空 unique ：设置唯一 核心配置// 加载Hibernate的核心配置文件Configuration configuration = new Configuration().configure();// 该语句默认会到src/hibernate.cfg.xml加载核心配置文件 必须的配置 连接数据库的基本的参数 驱动类 url路径 用户名 密码 方言 可选的配置 显示SQL ：hibernate.show_sql 格式化SQL ：hibernate.format_sql 自动建表 ：hibernate.hbm2ddl.auto none ：不使用hibernate的自动建表 create ：如果数据库中已经有表，删除原有表，重新创建，如果没有表，新建表。（测试） create-drop ：如果数据库中已经有表，删除原有表，执行操作，删除这个表。如果没有表，新建一个，使用完了删除该表。（测试） update ：如果数据库中有表，使用原有表，如果没有表，创建新表（更新表结构） validate ：如果没有表，不会创建表。只会使用数据库中原有的表。（校验映射和表结构）。 映射文件的引入 引入映射文件的位置 &lt;mapping resource=\"com/example/hibernate/demo1/Customer.hbm.xml\"/&gt; 例子： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 连接数据库的基本参数 --&gt; &lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql:///hibernate&lt;/property&gt; &lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt; &lt;property name=\"hibernate.connection.password\"&gt;123456&lt;/property&gt; &lt;!-- 配置Hibernate的方言 --&gt; &lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 可选配置================ --&gt; &lt;!-- 打印SQL --&gt; &lt;property name=\"hibernate.show_sql\"&gt;true&lt;/property&gt; &lt;!-- 格式化SQL ，使得打印出来的SQL语句更加美观--&gt; &lt;property name=\"hibernate.format_sql\"&gt;true&lt;/property&gt; &lt;property name=\"hibernate.format_sql\"&gt;true&lt;/property&gt; &lt;!-- 自动创建表 --&gt; &lt;property name=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/property&gt; &lt;!-- 映射文件 --&gt; &lt;mapping resource=\"com/example/hibernate/demo1/Customer.hbm.xml\"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 常用API Configuration 用来加载配置文件 SessionFactory 用来创建Session 内部维护连接池 比较重量级，一般一个应用只创建一个对象 线程安全 Session 与数据库进行交互 线程不安全 Transaction ​ 事务commit() rollback() 主键生成策略 主键的分类 自然主键：主键本身就是表中的一个字段 eg:学生表中，学号就是自然属性 代理主键：不是表的字段，比如设置一个自增长的id字段 尽量使用代理主键 hibernate主键生成策略 increment :hibernate中提供的自动增长机制 实现原理，首先发送一条语句select max(id) from 表，然后以id+1作为下一条记录的主键 线程不安全，原因见实现原理 indentity 使用数据库底层的自动增长机制 Oracle不支持自动增长机制 sequence 采用序列的方式 Oracle支持，但MySQL不支持 uuid 适用于字符串类型的主键 与上述三种进行区分，上述increment ，indentity ，sequence适用于short,int,long类型的主键 native 会根据底层数据库自动选择identity 或者 sequence assigened 该生成策略的主键值来自程序员手工设置，即通过setId()方法设置。属性类型可以是String、Int，但一般为String。此生成策略用于业务相关主键。例如学号、身份证号做主键 持久化类的三种状态 瞬时态（transient）没有唯一的标识OID,没有被session管理 持久态（persister）有唯一标识OID,被session管理 托管态（detached）有唯一标识OID,没有被session管理 public class Demo1 &#123; @Test public void demo() &#123; Session session = HibernateUtil.openSession();// 自定义工具类 Transaction transaction = session.beginTransaction(); Customer customer = new Customer(); // 瞬时态对象 customer.setCust_name(\"小明\"); session.save(customer); // 持久态对象 customer.setCust_mobile(\"110\"); // 持久态对象，对customer的更改会同时更改数据库 transaction.commit(); session.close(); System.out.println(customer); // 脱管态对象 &#125;&#125; 一级缓存 为了减少与数据库交互的次数，session内部维护了一个缓存 所有对javabean的更改，不会立即发送sql语句到数据库，而是先更改一级缓存 跟session一样的生命周期 ———- 事务 事务的四个特性 原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。 一致性（Consistency）：保证事务只能把数据库从一个有效（正确）的状态“转移”到另一个有效（正确）的状态 那么，什么是数据库的有效(正确）的状态？满足给这个数据库pred-defined的一些规则的状态都是 valid 的。这些规则有哪些呢，比如说constraints, cascade,triggers及它们的组合等。具体到某个表的某个字段，比如你在定义表的时候，给这个字段的类型是number类型，并且它的值不能小于0，那么你在某个 transaction 中给这个字段插入（更改）为一个 String 值或者是负值是不可以的，这不是一个“合法”的transaction，也就是说它不满足我们给数据库定义的一些规则（约束条件）。 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。 持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中。 并发事务会产生的问题 丢失更新 第一类丢失更新 ​ 定义：A事务撤销时，把已经提交的B事务的更新数据覆盖了。 第二类丢失更新 ​ 定义： A事务提交时，把已经提交的B事务的更新数据覆盖了。（属于不可重复读的一个特例） 脏读：读到未提交更新的数据 不可重复读：读到已经提交更新的数据，但一个事务范围内两个相同的查询却返回了不同数据。 幻读：读到已提交插入数据，幻读与不可重复读类似，幻读是查询到了另一个事务已提交的新插入数据，而不可重复读是查询到了另一个事务已提交的更新数据。 隔离级别 未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据 提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读) 可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读 串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞 隔离级别与并发问题 隔离级别 脏读 不可重复读 幻读 SERIALIZABLE （串行化） 不会发生 不会发生 不会发生 REPEATABLE READ（可重复读） 不会发生 不会发生 可能发生 READ COMMITTED （读已提交） 不会发生 可能发生 可能发生 READ UNCOMMITTED（读未提交） 可能发生 可能发生 可能发生 Hibernate 一对多关系以一个例子来说明： 两个实体类：一个客户可以有多个联系人 客户表 // sql语句CREATE TABLE `cst_customer` ( `cust_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '客户编号(主键)', `cust_name` varchar(32) NOT NULL COMMENT '客户名称(公司名称)', `cust_source` varchar(32) DEFAULT NULL COMMENT '客户信息来源', `cust_industry` varchar(32) DEFAULT NULL COMMENT '客户所属行业', `cust_level` varchar(32) DEFAULT NULL COMMENT '客户级别', `cust_phone` varchar(64) DEFAULT NULL COMMENT '固定电话', `cust_mobile` varchar(16) DEFAULT NULL COMMENT '移动电话', PRIMARY KEY (`cust_id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; Customer实体类 /** * 客户的实体 */public class Customer &#123; private Long cust_id; private String cust_name; private String cust_source; private String cust_industry; private String cust_level; private String cust_phone; private String cust_mobile; // 通过ORM方式表示：一个客户对应多个联系人。 // 放置的多的一方的集合。Hibernate默认使用的是Set集合。 private Set&lt;LinkMan&gt; linkMans = new HashSet&lt;LinkMan&gt;(); //省略getter,setter方法&#125; 客户表和客户类映射文件 Customer.hbm.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;&lt;hibernate-mapping&gt; &lt;class name=\"com.example.hibernate.domain.Customer\" table=\"cst_customer\"&gt; &lt;!-- 建立OID与主键映射 --&gt; &lt;id name=\"cust_id\" column=\"cust_id\"&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;!-- 建立普通属性与数据库表字段映射 --&gt; &lt;property name=\"cust_name\" column=\"cust_name\" /&gt; &lt;property name=\"cust_source\" column=\"cust_source\"/&gt; &lt;property name=\"cust_industry\" column=\"cust_industry\"/&gt; &lt;property name=\"cust_level\" column=\"cust_level\"/&gt; &lt;property name=\"cust_phone\" column=\"cust_phone\"/&gt; &lt;property name=\"cust_mobile\" column=\"cust_mobile\"/&gt; &lt;!-- 配置一对多的映射：放置的多的一方的集合 --&gt; &lt;!-- set标签 ： * name ：多的一方的对象集合的属性名称。 --&gt; &lt;set name=\"linkMans\"&gt; &lt;!-- key标签 * column：多的一方的外键的名称。 --&gt; &lt;key column=\"lkm_cust_id\"/&gt; &lt;!-- one-to-many标签 * class :多的一方的类的全路径 --&gt; &lt;one-to-many class=\"com.example.hibernate.domain.LinkMan\"/&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; LinkMan实体类 public class LinkMan &#123; private Long lkm_id; private String lkm_name; private String lkm_gender; private String lkm_phone; private String lkm_mobile; private String lkm_email; private String lkm_qq; private String lkm_position; private String lkm_memo; // 通过ORM方式表示：一个联系人只能属于某一个客户。 // 放置的是一的一方的对象。 private Customer customer; // 省略getter,setter方法&#125; 联系人表 CREATE TABLE `cst_linkman` ( `lkm_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '联系人编号(主键)', `lkm_name` varchar(16) DEFAULT NULL COMMENT '联系人姓名', `lkm_cust_id` bigint(32) NOT NULL COMMENT '客户id', `lkm_gender` char(1) DEFAULT NULL COMMENT '联系人性别', `lkm_phone` varchar(16) DEFAULT NULL COMMENT '联系人办公电话', `lkm_mobile` varchar(16) DEFAULT NULL COMMENT '联系人手机', `lkm_email` varchar(64) DEFAULT NULL COMMENT '联系人邮箱', `lkm_qq` varchar(16) DEFAULT NULL COMMENT '联系人qq', `lkm_position` varchar(16) DEFAULT NULL COMMENT '联系人职位', `lkm_memo` varchar(512) DEFAULT NULL COMMENT '联系人备注', PRIMARY KEY (`lkm_id`), KEY `FK_cst_linkman_lkm_cust_id` (`lkm_cust_id`), CONSTRAINT `FK_cst_linkman_lkm_cust_id` FOREIGN KEY (`lkm_cust_id`) REFERENCES `cst_customer` (`cust_id`) ON DELETE NO ACTION ON UPDATE NO ACTION) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 联系人表和联系人实体类映射文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;&lt;hibernate-mapping&gt; &lt;class name=\"com.example.hibernate.domain.LinkMan\" table=\"cst_linkman\"&gt; &lt;!-- 建立OID与主键映射 --&gt; &lt;id name=\"lkm_id\" column=\"lkm_id\"&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;!-- 建立普通属性与表字段映射 --&gt; &lt;property name=\"lkm_name\"/&gt; &lt;property name=\"lkm_gender\"/&gt; &lt;property name=\"lkm_phone\"/&gt; &lt;property name=\"lkm_mobile\"/&gt; &lt;property name=\"lkm_email\"/&gt; &lt;property name=\"lkm_qq\"/&gt; &lt;property name=\"lkm_position\"/&gt; &lt;property name=\"lkm_memo\"/&gt; &lt;!-- 配置多对一的关系：放置的是一的一方的对象 --&gt; &lt;!-- many-to-one标签 * name :一的一方的对象的属性名称。 * class :一的一方的类的全路径。 * column :在多的一方的表的外键的名称。 --&gt; &lt;many-to-one name=\"customer\" class=\"com.example.hibernate.domain.Customer\" column=\"lkm_cust_id\"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 测试代码 public void demo() &#123; Session session = HibernateUtil.openSession(); Transaction tx = session.beginTransaction(); tx.begin(); Customer customer1 = new Customer(); // 新建一个客户对象 customer1.setCust_name(\"客户1\"); LinkMan linkman1_1 = new LinkMan(); // 新建一个联系人 linkman1_1.setLkm_name(\"联系人1，属于客户1\"); linkman1_1.setCustomer(customer1); LinkMan linkMan1_2 = new LinkMan(); // 新建一个联系人 linkMan1_2.setLkm_name(\"联系人2，属于客户1\"); linkMan1_2.setCustomer(customer1); customer1.getLinkMans().add(linkman1_1); customer1.getLinkMans().add(linkMan1_2); // 联系人和客户对象都需要保存 session.save(customer1); session.save(linkman1_1); session.save(linkMan1_2); tx.commit(); session.close(); &#125; 一对多级联操作 什么叫级联：​ 级联指的是，操作一个对象的时候，是否会同时操作其关联的对象。 级联是有方向性 操作一的一方的时候，是否操作到多的一方 操作多的一方的时候，是否操作到一的一方 级联保存或者更新 保存客户级联联系人,需要在Customer.hbm.xml进行配置 配置映射文件Customer.hbm.xml &lt;!--cascade = \"save-update\"--&gt;&lt;set name=\"linkMans\" cascade=\"save-update\"&gt; &lt;key column=\"lkm_cust_id\"/&gt; &lt;one-to-many class=\"com.example.hibernate.domain.LinkMan\"/&gt;&lt;/set&gt; 测试 public void demo() &#123; Session session = HibernateUtil.openSession(); Transaction tx = session.beginTransaction(); Customer customer = new Customer(); customer.setCust_name(\"阿里巴巴\"); LinkMan linkman1 = new LinkMan(); linkman1.setLkm_name(\"阿里巴巴技术总监\"); LinkMan linkman2 = new LinkMan(); linkman2.setLkm_name(\"阿里巴巴开发组长\"); // 保存一边 customer.getLinkMans().add(linkman1); customer.getLinkMans().add(linkman2); // 保存一边 session.save(customer); tx.commit(); session.close();&#125; 保存联系人级联客户 与上述差不多的操作 修改LinkMan.hbm.xml &lt;many-to-one name=\"customer\" cascade=\"save-update\" class=\"com.example.hibernate.domain.Customer\" column=\"lkm_cust_id\"/&gt; 级联删除 级联删除：删除一边的时候，同时将另一方的数据也一并删除。 下面以一个具体的例子来说明： 1、删除客户，级联删除联系人 第一步，修改映射文件Customer.hbm.xml &lt;set name=\"linkMans\" cascade=\"delete\"&gt; 第二步，编写测试代码 @Testpublic void demo1()&#123; Session session = HibernateUtil.openSession(); Transaction tx = session.beginTransaction(); /** * (1)级联删除 * &lt;set name=\"linkMans\" cascade=\"delete\"&gt; */ Customer customer1 = session.get(Customer.class, 1L); session.delete(customer1); /** * (2)如果没有设置cascade=\"delete\" * 运行下面的结果为：只删除了一的一方，多的一方不会被删除 * 但是多的一方的外键会被设置为null */ Customer customer2 = session.get(Customer.class, 2L); session.delete(customer2); /** * (3)如果customer不是持久态度 * 这种方式不会删除多的一方 * 但是会把多的一方的外键设置为null */ Customer customer3 = new Customer(); customer3.setCust_id(3L); session.delete(customer3); tx.commit(); session.close();&#125; 删除联系人，级联删除客户 在一对多中一般不会出现这种情况：没有说删除多的一方，然后把一的一方删除的，因此下面只是测试使用 第一步,修改映射文件LinkMan.hbm.xml &lt;many-to-one name=\"customer\" cascade=\"delete\" class=\"com.example.hibernate.domain.Customer\" column=\"lkm_cust_id\"/&gt; 第二步,编写测试代码 @Testpublic void demo2()&#123; Session session = HibernateUtil.openSession(); Transaction tx = session.beginTransaction(); /** * 删除联系人，级联删除客户 * 在多的一方设置cascade=\"delete\" * &lt;many-to-one name=\"customer\" cascade=\"delete\" class=\"com.example.hibernate.domain.Customer\" column=\"lkm_cust_id\"/&gt; * * 运行结果： * 联系人和联系人关联的客户均被删除 * 和客户有关联的其他联系人的外键被设置为null */ LinkMan linkMan = session.get(LinkMan.class, 1L); session.delete(linkMan); tx.commit(); session.close();&#125; cascade 和 inverse cascade:级联 save update save-update delete inverse : 外键维护权 true 放弃外键维护权 false 拥有外键维护权，默认值","tags":[{"name":"Java","slug":"Java","permalink":"https://chsobin.github.io/tags/Java/"}]}]