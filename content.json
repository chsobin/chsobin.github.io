[{"title":"hexo搭建博客遇到的问题汇总","date":"2019-04-03T01:31:11.000Z","path":"2019/04/03/hexo搭建博客遇到的问题汇总/","text":"代码块必须指明语言，不然运行hexo g 命令会报错： TypeError: Cannot set property ‘lastIndex’ of undefined解决方法： 在 _config.yml 中设置 auto_detect: false 确保你的代码块有指定语言: ​```java /*此处一定要指明语言*/ // code here​ ` 为了找到是哪一个post产生问题，可以移除所有的post,一个个添加回去，然后运行”hexo g”,看是否会报错 markdown 中的表格，开头不能有空格，不然会渲染失败 这个问题，我提过issue，后来发现问题就关闭了，详情可以看： https://github.com/yscoder/hexo-theme-indigo/issues/467","tags":[{"name":"hexo","slug":"hexo","permalink":"https://chsobin.github.io/tags/hexo/"}]},{"title":"Java知识点总结","date":"2019-04-02T14:01:21.000Z","path":"2019/04/02/Java知识点总结/","text":"前言 这篇文章是对Java相关知识点的简要总结，主要记录了我个人之前所忽略的知识点 对于每个工具类的使用，这里不做详细探讨，具体可以参照官方文档，https://docs.oracle.com/javase/8/docs/api/ 入门基础 Java程序运行机制 编译和解释结合 *.java 源文件 编译成 *.class 字节码文件jvm解释执行字节码文件 面试题：Java是解释执行的，对吗？ 解答： Java引进JIT技术之后，能将一些热点代码直接编译成机器语言 JIT 是 just in time 的缩写, 也就是即时编译编译器。使用即时编译器技术，能够加速 Java 程序的执行速度。下面，就对该编译器技术做个简单的讲解。 首先，我们大家都知道，通常通过 javac 将程序源代码编译，转换成 java 字节码，JVM 通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢很多。为了提高执行速度，引入了 JIT 技术。 在运行时 JIT 会把翻译过的机器码保存起来，以备下次使用，因此从理论上来说，采用该 JIT 技术可以接近以前纯编译技术。 jvm、jre、jdk jar 包 就是一些字节码文件进行打包 成员变量 与 局部变量 成员变量会自动初始化为默认值；局部变量必须先赋值才能使用 常量命名规范：大写+下划线 如 MAX_VALUE int范围 -2^31 到 2^31-1 java浮点常量 可以用科学计数法表示 eg: 314e2=31400 314E2=31400 314E-2=3.14 switch语句中case标签在JDK1.5之前必须是整数(long类型除外)或者枚举，不能是字符串，在JDK1.7之后允许使用字符串(String)。 重载：方法名相同，参数类型，个数，顺序不同 面向对象基础 java 内存模型 - 静态导入 jdk5之后的新特性 其作用是用于导入指定类的静态属性，这样我们可以直接使用静态属性。 import static java.lang.Math.*;//导入Math类的所有静态属性import static java.lang.Math.PI;//导入Math类的PI属性 方法的重写需要符合下面的三个要点： ​ 1.“==”： 方法名、形参列表相同。 ​ 2.“≤”：返回值类型和声明异常类型，子类小于等于父类。 ​ 3.“≥”： 访问权限，子类大于等于父类。 访问权限修饰符 修饰符 同一个类 同一个包 子类 所有类 private Y 不可访问 不可访问 不可访问 default Y Y 不可访问 不可访问 protected Y Y Y 不可访问 public Y Y Y Y 抽象类 有抽象方法的类，abstract关键字修饰 接口 interface可以继承多个接口，class可以实现多个接口 接口所有方法都是抽象，默认是 public abstract 接口里面的变量，默认都是 public static final,(也即是接口里面只能定义常量) 匿名内部类 不会生成.class文件。只能使用一次 匿名内部类中不能存在任何的静态成员变量和静态方法。 匿名内部类没有构造器，可以使用构造代码块代替 异常机制 –- Exception和Error的区别：Exception能被程序本身可以处理，Error是程序无法处理- 需要注意的是，一旦某个catch捕获到匹配的异常类型，将进入异常处理代码。一经处理结束，就意味着整个try-catch语句结束。其他的catch子句不再有匹配和捕获异常类型的机会。package exception;public class Demo &#123; public static void checkZero()&#123; for(int i=3;i&gt;=-1;--i)&#123; int ans = 10/i; System.out.println(\"i=\" + i); &#125; &#125; public static void main(String[] args) &#123; try &#123; checkZero(); // 一个异常只会被一个catch捕捉 &#125;catch (ArithmeticException mathException)&#123; System.out.println(\"catch ArithmeticException\"); &#125;catch (Exception exception)&#123; System.out.println(\"catch Exception\"); &#125;finally &#123; System.out.print(\"finally\"); &#125; &#125;&#125;/** * 执行结果： * i=3 * i=2 * i=1 * catch ArithmeticException * finally */ 容器 Java集合 Java集合框架图 1、所有集合类都位于java.util包下。Java的集合类主要由两个接口派生而出：Collection和Map，Collection和Map是Java集合框架的根接口，这两个接口又包含了一些子接口或实现类。 2、集合接口：6个接口（短虚线表示），表示不同集合类型，是集合框架的基础。 3、抽象类：5个抽象类（长虚线表示），对集合接口的部分实现。可扩展为自定义集合类。 4、实现类：8个实现类（实线表示），对接口的具体实现。 5、Collection 接口是一组允许重复的对象。 6、Set 接口继承 Collection，集合元素不重复。 7、List 接口继承 Collection，允许重复，维护元素插入顺序。 8、Map接口是键－值对象，与Collection接口没有什么关系。 9、Set、List和Map可以看做集合的三大类： List集合是有序集合，集合中的元素可以重复，访问集合中的元素可以根据元素的索引来访问。 Set集合是无序集合，集合中的元素不可以重复，访问集合中的元素只能根据元素本身来访问（也是集合里元素不允许重复的原因）。 Map集合中保存Key-value对形式的元素，访问时只能根据每项元素的key来访问其value。 IO流技术 如何理解流？ 流是个抽象的概念，是对输入输出设备的抽象，Java程序中，对于数据的输入/输出操作都是以“流”的方式进行。设备可以是文件，网络，内存等。 摘自Oracle官方文档：https://docs.oracle.com/javase/tutorial/essential/io/streams.html An I/O Stream represents an input source or an output destination. A stream can represent many different kinds of sources and destinations, including disk files, devices, other programs, and memory arrays. Streams support many different kinds of data, including simple bytes, primitive data types, localized characters, and objects. Some streams simply pass on data; others manipulate and transform the data in useful ways. No matter how they work internally, all streams present the same simple model to programs that use them: A stream is a sequence of data. 常用类 （学习使用的最好方法就是jdk api 文档） File 表示数据源 //文件路径建议String path = \"D:/dir/a.txt\"// 或者String path2 = \"D:\" + File.separator + \"dir\" + File.separator + \"a.txt\"; 四大抽象类 InputStream OutputStream Reader Writer FileInputStream FileOutputStream 文件字节流 ，数据在硬盘 ByteArrayInputStream ByteArrayOutputStream 字节数组流，数据源在虚拟机内存 解码、编码 编码： 字符 ——– 使用特定字符集（如UTF-8 ）——-&gt; 字节 解码： 字节 ———-使用特定字符集 ———&gt;字符 出现乱码的原因 String msg = \"你好啊\";byte[] datas = msg.getBytes(); // 默认使用工程的字符集进行编码，此处假设为UTF-8//(1) 字节数不够msg = new String(datas, 0, datas.length-1, \"utf8\");System.out.println(msg);//(2) 编码解码的字符集不同msg = new String(datas, \"gbk\");System.out.println(msg); IO操作基本步骤 选择数据源 选择数据流 读或者写操作 释放资源 IO相关类 很多利用了 装饰者模式 FileInputStream fis = new FileInputStream(src);BufferedInputStream bis = new BufferedInputStream(fis);// 将FileInputStream对象作为参数传入 多线程 java多线程三种实现方法 继承Thread类 实现Runnable接口 实现Callable接口 实现Runnable接口这种方式用到了静态代理这个设计模式 new Thread(实现了Runnable接口的对象).start(); 静态代理设计模式： 代理模式主要包含三个角色，即抽象主题角色(Subject)、委托类角色(被代理角色，Proxied)以及代理类角色(Proxy)，如上图所示： 抽象主题角色:可以是接口，也可以是抽象类；委托类角色：真实主题角色，业务逻辑的具体执行者；代理类角色：内部含有对真实对象RealSubject的引用，负责对真实主题角色的调用，并在真实主题角色处理前后做预处理和后处理。 // 接口interface Driverable&#123; void drive();&#125;// 被代理角色class Car implements Driverable&#123; @Override public void drive() &#123; System.out.println(\"moving...\"); &#125;&#125;// 代理角色class SmartCar implements Driverable&#123; private Driverable target; // 持有被代理对象 public SmartCar(Driverable target) &#123; this.target = target; &#125; @Override public void drive() &#123; begin(); // 增强功能 target.drive(); end(); // 增强功能 &#125; private void begin() &#123; System.out.println(\"启动智能系统\"); &#125; private void end() &#123; System.out.println(\"关闭智能系统\"); &#125;&#125; 线程五种状态 新建状态(New) : 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。 就绪状态(Runnable): 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。 运行状态(Running): 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。 阻塞状态(Blocked) : 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种： （1） 等待阻塞 – 通过调用线程的wait()方法，让线程等待某工作的完成。 （2） 同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。 （3）其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。 死亡状态(Dead) : 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 同步块 // obj称之为同步监视器synchronized(obj)&#123; 代码 &#125; obj可以是任何对象，推荐使用共享资源作为同步监视器 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this(即该对象本身)，或class(即类的模子) 注解 是什么： Java注解又称Java标注 Java语言中的类、方法、变量、参数和包等都可以被标注。 和Javadoc不同，Java标注可以通过反射获取标注内容。 在编译器生成类文件时，标注可以被嵌入到字节码中。Java虚拟机可以保留标注内容，在运行时可以获取到标注内容。 元注解 是用于修饰注解的注解，通常用在注解的定义上，例如： @Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125; @Target：注解的作用目标 @Retention：注解的生命周期 @Documented：注解是否应当被包含在 JavaDoc 文档中 @Inherited：是否允许子类继承该注解 自定义注解 定义一个用于数据库表的注解 注解里面可以定义注解元素，格式为类型 元素名() [default 元素值] 如果不指明default值，使用时必须传入元素值 @Target(ElementType.TYPE)//只能应用于类上@Retention(RetentionPolicy.RUNTIME)//保存到运行时public @interface DBTable &#123; String name() default \"\"; &#125; //在类上使用该注解@DBTable(name = \"user\")public class User &#123; // javabean&#125; 包装类 自动装箱，自动拆箱 Integer a = 1; // 自动装箱，编译器会转化为 Integer a = Integer.valueOf(1)int b = a; // 自动拆箱 int b = a.intValue(); 缓存机制，缓存[-128, 127]之间的数字，具体查看Integer.valueOf()源码 Integer x = -128;Integer y = Integer.valueOf(-128);System.out.println(x==y); // trueSystem.out.println(x.equals(y));// true 字符串相关类 StringBuffer 线程安全 StringBuilder 线程不安全 时间处理相关类 时间日期相关类 时间处理类之间的关系 DateFormat 抽象类 与 SimpleDateFormat 使用 public static void main(String[] args) throws ParseException &#123; // new出SimpleDateFormat对象 SimpleDateFormat s1 = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\"); // 将时间对象转换成字符串 String daytime = s1.format(new Date()); System.out.println(daytime); // 将符合指定格式的字符串转成成时间对象.字符串格式需要和指定格式一致。 String time = \"2007-10-7 20:15:30\"; Date date = s1.parse(time); System.out.println(date);&#125; 文件类 常用方法 File f = new File(\"d:/c.txt\");f.createNewFile(); // 会在d盘下面生成c.txt文件f.delete(); // 将该文件或目录从硬盘上删除System.out.println(\"File是否存在：\"+f.exists());System.out.println(\"File是否是目录：\"+f.isDirectory());System.out.println(\"File是否是文件：\"+f.isFile());System.out.println(\"File最后修改时间：\"+new Date(f.lastModified()));System.out.println(\"File的大小：\"+f.length());System.out.println(\"File的文件名：\"+f.getName());System.out.println(\"File的目录路径：\"+f.getPath()); 创建目录 mkdir File f2 = new File(\"d:/电影/华语/大陆\");boolean flag = f2.mkdir(); //目录结构中有一个不存在，则不会创建整个目录树System.out.println(flag);//创建失败 mkdirs File f2 = new File(\"d:/电影/华语/大陆\");boolean flag = f2.mkdirs();//目录结构中有一个不存在也没关系；创建整个目录树System.out.println(flag);//创建成功 枚举 所有的枚举类型隐性地继承自 java.lang.Enum。 枚举实质上还是类，而每个被枚举的成员实质就是一个枚举类型的实例，他们默认都是public static final修饰的。可以直接通过枚举类型名使用它们。 /**季节*/enum Season &#123; SPRING, SUMMER, AUTUMN, WINDTER&#125;/**星期*/enum Week &#123; 星期一, 星期二, 星期三, 星期四, 星期五, 星期六, 星期日&#125; 如何去学习框架 是什么 为什么用 怎么做 小实例，最好跟着官方文档的示例做 框架提供的api ( 相关类的使用 ) 框架相关配置文件 个人理解，配置文件使得我们的系统解耦 一旦需求有变，只需要修改配置文件即可，无需更改源代码 以上为快速入门一个框架，说到底就是先学会怎么用工具，但是仅仅学会用是不够的。在会用的基础上，要站在高位去审视整个框架，去理解框架的架构，去更好地利用框架。如果框架本身提供的功能不能满足我们的需求，我们完全可以修改框架或者创造一个框架出来 高级主题 反射 动态代理 jdbc 网络 多线程 JVM 设计模式 对于高级主题推荐的书籍： 《java 并发编程实战》 《深入理解 java 虚拟机》 《mysql 必知必会》 《大话设计模式》 计算机网络：《TCP/IP详解卷一：协议》","tags":[{"name":"Java","slug":"Java","permalink":"https://chsobin.github.io/tags/Java/"}]},{"title":"测试代码块缩进问题","date":"2019-04-01T18:28:30.000Z","path":"2019/04/02/代码块缩进问题/","text":"问题：使用Typora写文章时，发现从eclipse粘贴过来的代码经过hexo转化之后，缩进出现了错误 如下：明明是四个空格，却显示了8个 public class Demo &#123; @Test public void demo() &#123; Session session = HibernateUtil.openSession(); Transaction tx = session.beginTransaction(); tx.begin(); Customer customer1 = new Customer(); // 新建一个客户对象 customer1.setCust_name(\"客户1\"); LinkMan linkman1_1 = new LinkMan(); // 新建一个联系人 linkman1_1.setLkm_name(\"联系人1，属于客户1\"); linkman1_1.setCustomer(customer1); LinkMan linkMan1_2 = new LinkMan(); // 新建一个联系人 linkMan1_2.setLkm_name(\"联系人2，属于客户1\"); linkMan1_2.setCustomer(customer1); customer1.getLinkMans().add(linkman1_1); customer1.getLinkMans().add(linkMan1_2); // 联系人和客户对象都需要保存 session.save(customer1); session.save(linkman1_1); session.save(linkMan1_2); tx.commit(); session.close(); &#125;&#125; 解决详情参考：https://blog.csdn.net/qq_37932863/article/details/73611785 解决之后，再次粘贴代码：可以看到缩进正常了 public class Demo &#123; @Test public void demo() &#123; Session session = HibernateUtil.openSession(); Transaction tx = session.beginTransaction(); tx.begin(); Customer customer1 = new Customer(); // 新建一个客户对象 customer1.setCust_name(\"客户1\"); LinkMan linkman1_1 = new LinkMan(); // 新建一个联系人 linkman1_1.setLkm_name(\"联系人1，属于客户1\"); linkman1_1.setCustomer(customer1); LinkMan linkMan1_2 = new LinkMan(); // 新建一个联系人 linkMan1_2.setLkm_name(\"联系人2，属于客户1\"); linkMan1_2.setCustomer(customer1); customer1.getLinkMans().add(linkman1_1); customer1.getLinkMans().add(linkMan1_2); // 联系人和客户对象都需要保存 session.save(customer1); session.save(linkman1_1); session.save(linkMan1_2); tx.commit(); session.close(); &#125;&#125;","tags":[{"name":"hexo","slug":"hexo","permalink":"https://chsobin.github.io/tags/hexo/"}]},{"title":"Hibernate学习笔记","date":"2019-04-01T15:52:36.000Z","path":"2019/04/01/Hibernate学习笔记/","text":"是什么 Hibernate是一种ORM(Object Relational Mapping ）框架 它对JDBC进行了非常轻量级的对象封装 hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库 为什么要用 传统基于JDBC的开发，代码重复性过多 使用Hibernate框架，简化了Dao层的编码工作，不用我们写很多繁琐的SQL语句 快速上手注意：此案例基于hibernate-release-5.0.7.Final （1）下载Hibernate 开发环境，解压后有三个主要文件夹 documentation :Hibernate开发的文档 lib :Hibernate开发包 required :Hibernate开发的必须的依赖 optional :Hibernate开发的可选的jar包 project :Hibernate提供的项目 （2）创建一个项目，引入jar包 数据库驱动包 mysql-connector-java-5.1.7-bin.jar Hibernate开发的必须的jar包。 步骤1中required中所有的包 日志记录包 （3）创建表 CREATE TABLE `cst_customer` ( `cust_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '客户编号(主键)', `cust_name` varchar(32) NOT NULL COMMENT '客户名称(公司名称)', `cust_source` varchar(32) DEFAULT NULL COMMENT '客户信息来源', `cust_industry` varchar(32) DEFAULT NULL COMMENT '客户所属行业', `cust_level` varchar(32) DEFAULT NULL COMMENT '客户级别', `cust_phone` varchar(64) DEFAULT NULL COMMENT '固定电话', `cust_mobile` varchar(16) DEFAULT NULL COMMENT '移动电话', PRIMARY KEY (`cust_id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; （4）创建实体类 ​ com.example.hibernate.demo1.Customer.java public class Customer &#123; private Long cust_id; private String cust_name; private String cust_source; private String cust_industry; private String cust_level; private String cust_phone; private String cust_mobile; // 省略getter setter&#125; （5）创建实体类Customer 与表cst_customer的映射 src/com/example/hibernate/demo1/Customer.hbm.xml 命名格式一般为：类名.hbm.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;&lt;hibernate-mapping&gt; &lt;!-- 建立类与表的映射 --&gt; &lt;class name=\"com.example.hibernate.demo1.Customer\" table=\"cst_customer\"&gt; &lt;!-- 建立类中的属性与表中的主键对应 --&gt; &lt;id name=\"cust_id\" column=\"cust_id\" &gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;!-- 建立类中的普通的属性和表的字段的对应 --&gt; &lt;property name=\"cust_name\" column=\"cust_name\" length=\"32\" /&gt; &lt;property name=\"cust_source\" column=\"cust_source\" length=\"32\"/&gt; &lt;property name=\"cust_industry\" column=\"cust_industry\"/&gt; &lt;property name=\"cust_level\" column=\"cust_level\"/&gt; &lt;property name=\"cust_phone\" column=\"cust_phone\"/&gt; &lt;property name=\"cust_mobile\" column=\"cust_mobile\"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 注意： (1)该配置文件的DTD 在hibernate-core-5.0.7.Final.jar包下的/org/hibernate/hibernate-mapping-3.0.dtd (2)在eclipse中设置xml自动提示，需要告诉eclipse相应的DTD文件位置具体设置可以自行百度 （6）创建Hibernate的核心配置文件 Hibernate的核心配置文件的名称：hibernate.cfg.xml 放置在src目录下 该配置文件的DTD 在hibernate-core-5.0.7.Final.jar包下的/org/hibernate/hibernate-configuration-3.0.dtd 具体怎么写可以参考步骤1中project文件夹下的/etc/hibernate.properties &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 连接数据库的基本参数 --&gt; &lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql:///hibernate&lt;/property&gt; &lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt; &lt;property name=\"hibernate.connection.password\"&gt;123456&lt;/property&gt; &lt;!-- 配置Hibernate的方言 --&gt; &lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 可选配置================ --&gt; &lt;!-- 打印SQL --&gt; &lt;property name=\"hibernate.show_sql\"&gt;true&lt;/property&gt; &lt;!-- 格式化SQL ，使得打印出来的SQL语句更加美观--&gt; &lt;property name=\"hibernate.format_sql\"&gt;true&lt;/property&gt; &lt;!-- 映射文件 --&gt; &lt;mapping resource=\"com/example/hibernate/demo1/Customer.hbm.xml\"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; （7）编写测试代码 public class Example &#123; @Test // 保存客户的案例 public void test()&#123; // 1.加载Hibernate的核心配置文件 Configuration configuration = new Configuration().configure(); // 手动加载映射 // configuration.addResource(\"com/example/hibernate/demo1/Customer.hbm.xml\"); // 2.创建一个SessionFactory对象：类似于JDBC中连接池 SessionFactory sessionFactory = configuration.buildSessionFactory(); // 3.通过SessionFactory获取到Session对象：类似于JDBC中Connection Session session = sessionFactory.openSession(); // 4.手动开启事务： Transaction transaction = session.beginTransaction(); // 5.编写代码 Customer customer = new Customer(); customer.setCust_name(\"王西\"); session.save(customer); // 6.事务提交 transaction.commit(); // 7.资源释放 session.close(); sessionFactory.close(); &#125;&#125; 映射的配置 【class标签的配置】建立类与表的映射关系 属性： name ：类的全路径 table ：表名（类名与表名一致，table可以省略） catalog ：数据库名 【id标签的配置】类中的属性与表中的主键的对应关系 属性： name ：类中的属性名 column ：表中的字段名（类中的属性名和表中的字段名如果一致，column可以省略） length ：长度 type ：类型 【property标签的配置】类中的普通属性与表的字段的对应关系 属性： name ：类中的属性名 column ：表中的字段名 length ：长度 type ：类型 not-null ：设置非空 unique ：设置唯一 核心配置// 加载Hibernate的核心配置文件Configuration configuration = new Configuration().configure();// 该语句默认会到src/hibernate.cfg.xml加载核心配置文件 必须的配置 连接数据库的基本的参数 驱动类 url路径 用户名 密码 方言 可选的配置 显示SQL ：hibernate.show_sql 格式化SQL ：hibernate.format_sql 自动建表 ：hibernate.hbm2ddl.auto none ：不使用hibernate的自动建表 create ：如果数据库中已经有表，删除原有表，重新创建，如果没有表，新建表。（测试） create-drop ：如果数据库中已经有表，删除原有表，执行操作，删除这个表。如果没有表，新建一个，使用完了删除该表。（测试） update ：如果数据库中有表，使用原有表，如果没有表，创建新表（更新表结构） validate ：如果没有表，不会创建表。只会使用数据库中原有的表。（校验映射和表结构）。 映射文件的引入 引入映射文件的位置 &lt;mapping resource=\"com/example/hibernate/demo1/Customer.hbm.xml\"/&gt; 例子： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 连接数据库的基本参数 --&gt; &lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql:///hibernate&lt;/property&gt; &lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt; &lt;property name=\"hibernate.connection.password\"&gt;123456&lt;/property&gt; &lt;!-- 配置Hibernate的方言 --&gt; &lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 可选配置================ --&gt; &lt;!-- 打印SQL --&gt; &lt;property name=\"hibernate.show_sql\"&gt;true&lt;/property&gt; &lt;!-- 格式化SQL ，使得打印出来的SQL语句更加美观--&gt; &lt;property name=\"hibernate.format_sql\"&gt;true&lt;/property&gt; &lt;property name=\"hibernate.format_sql\"&gt;true&lt;/property&gt; &lt;!-- 自动创建表 --&gt; &lt;property name=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/property&gt; &lt;!-- 映射文件 --&gt; &lt;mapping resource=\"com/example/hibernate/demo1/Customer.hbm.xml\"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 常用API Configuration 用来加载配置文件 SessionFactory 用来创建Session 内部维护连接池 比较重量级，一般一个应用只创建一个对象 线程安全 Session 与数据库进行交互 线程不安全 Transaction ​ 事务commit() rollback() 主键生成策略 主键的分类 自然主键：主键本身就是表中的一个字段 eg:学生表中，学号就是自然属性 代理主键：不是表的字段，比如设置一个自增长的id字段 尽量使用代理主键 hibernate主键生成策略 increment :hibernate中提供的自动增长机制 实现原理，首先发送一条语句select max(id) from 表，然后以id+1作为下一条记录的主键 线程不安全，原因见实现原理 indentity 使用数据库底层的自动增长机制 Oracle不支持自动增长机制 sequence 采用序列的方式 Oracle支持，但MySQL不支持 uuid 适用于字符串类型的主键 与上述三种进行区分，上述increment ，indentity ，sequence适用于short,int,long类型的主键 native 会根据底层数据库自动选择identity 或者 sequence assigened 该生成策略的主键值来自程序员手工设置，即通过setId()方法设置。属性类型可以是String、Int，但一般为String。此生成策略用于业务相关主键。例如学号、身份证号做主键 持久化类的三种状态 瞬时态（transient）没有唯一的标识OID,没有被session管理 持久态（persister）有唯一标识OID,被session管理 托管态（detached）有唯一标识OID,没有被session管理 public class Demo1 &#123; @Test public void demo() &#123; Session session = HibernateUtil.openSession();// 自定义工具类 Transaction transaction = session.beginTransaction(); Customer customer = new Customer(); // 瞬时态对象 customer.setCust_name(\"小明\"); session.save(customer); // 持久态对象 customer.setCust_mobile(\"110\"); // 持久态对象，对customer的更改会同时更改数据库 transaction.commit(); session.close(); System.out.println(customer); // 脱管态对象 &#125;&#125; 一级缓存 为了减少与数据库交互的次数，session内部维护了一个缓存 所有对javabean的更改，不会立即发送sql语句到数据库，而是先更改一级缓存 跟session一样的生命周期 ———- 事务 事务的四个特性 原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。 一致性（Consistency）：保证事务只能把数据库从一个有效（正确）的状态“转移”到另一个有效（正确）的状态 那么，什么是数据库的有效(正确）的状态？满足给这个数据库pred-defined的一些规则的状态都是 valid 的。这些规则有哪些呢，比如说constraints, cascade,triggers及它们的组合等。具体到某个表的某个字段，比如你在定义表的时候，给这个字段的类型是number类型，并且它的值不能小于0，那么你在某个 transaction 中给这个字段插入（更改）为一个 String 值或者是负值是不可以的，这不是一个“合法”的transaction，也就是说它不满足我们给数据库定义的一些规则（约束条件）。 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。 持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中。 并发事务会产生的问题 丢失更新 第一类丢失更新 ​ 定义：A事务撤销时，把已经提交的B事务的更新数据覆盖了。 第二类丢失更新 ​ 定义： A事务提交时，把已经提交的B事务的更新数据覆盖了。（属于不可重复读的一个特例） 脏读：读到未提交更新的数据 不可重复读：读到已经提交更新的数据，但一个事务范围内两个相同的查询却返回了不同数据。 幻读：读到已提交插入数据，幻读与不可重复读类似，幻读是查询到了另一个事务已提交的新插入数据，而不可重复读是查询到了另一个事务已提交的更新数据。 隔离级别 未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据 提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读) 可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读 串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞 隔离级别与并发问题| 隔离级别 | 脏读 | 不可重复读 | 幻读 || —————————- | ——– | ———- | ——– || SERIALIZABLE （串行化） | 不会发生 | 不会发生 | 不会发生 || REPEATABLE READ（可重复读） | 不会发生 | 不会发生 | 可能发生 || READ COMMITTED （读已提交） | 不会发生 | 可能发生 | 可能发生 || READ UNCOMMITTED（读未提交） | 可能发生 | 可能发生 | 可能发生 | Hibernate 一对多关系以一个例子来说明： 两个实体类：一个客户可以有多个联系人 客户表 // sql语句CREATE TABLE `cst_customer` ( `cust_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '客户编号(主键)', `cust_name` varchar(32) NOT NULL COMMENT '客户名称(公司名称)', `cust_source` varchar(32) DEFAULT NULL COMMENT '客户信息来源', `cust_industry` varchar(32) DEFAULT NULL COMMENT '客户所属行业', `cust_level` varchar(32) DEFAULT NULL COMMENT '客户级别', `cust_phone` varchar(64) DEFAULT NULL COMMENT '固定电话', `cust_mobile` varchar(16) DEFAULT NULL COMMENT '移动电话', PRIMARY KEY (`cust_id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; Customer实体类 /** * 客户的实体 */public class Customer &#123; private Long cust_id; private String cust_name; private String cust_source; private String cust_industry; private String cust_level; private String cust_phone; private String cust_mobile; // 通过ORM方式表示：一个客户对应多个联系人。 // 放置的多的一方的集合。Hibernate默认使用的是Set集合。 private Set&lt;LinkMan&gt; linkMans = new HashSet&lt;LinkMan&gt;(); //省略getter,setter方法&#125; 客户表和客户类映射文件 Customer.hbm.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;&lt;hibernate-mapping&gt; &lt;class name=\"com.example.hibernate.domain.Customer\" table=\"cst_customer\"&gt; &lt;!-- 建立OID与主键映射 --&gt; &lt;id name=\"cust_id\" column=\"cust_id\"&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;!-- 建立普通属性与数据库表字段映射 --&gt; &lt;property name=\"cust_name\" column=\"cust_name\" /&gt; &lt;property name=\"cust_source\" column=\"cust_source\"/&gt; &lt;property name=\"cust_industry\" column=\"cust_industry\"/&gt; &lt;property name=\"cust_level\" column=\"cust_level\"/&gt; &lt;property name=\"cust_phone\" column=\"cust_phone\"/&gt; &lt;property name=\"cust_mobile\" column=\"cust_mobile\"/&gt; &lt;!-- 配置一对多的映射：放置的多的一方的集合 --&gt; &lt;!-- set标签 ： * name ：多的一方的对象集合的属性名称。 --&gt; &lt;set name=\"linkMans\"&gt; &lt;!-- key标签 * column：多的一方的外键的名称。 --&gt; &lt;key column=\"lkm_cust_id\"/&gt; &lt;!-- one-to-many标签 * class :多的一方的类的全路径 --&gt; &lt;one-to-many class=\"com.example.hibernate.domain.LinkMan\"/&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; LinkMan实体类 public class LinkMan &#123; private Long lkm_id; private String lkm_name; private String lkm_gender; private String lkm_phone; private String lkm_mobile; private String lkm_email; private String lkm_qq; private String lkm_position; private String lkm_memo; // 通过ORM方式表示：一个联系人只能属于某一个客户。 // 放置的是一的一方的对象。 private Customer customer; // 省略getter,setter方法&#125; 联系人表 CREATE TABLE `cst_linkman` ( `lkm_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '联系人编号(主键)', `lkm_name` varchar(16) DEFAULT NULL COMMENT '联系人姓名', `lkm_cust_id` bigint(32) NOT NULL COMMENT '客户id', `lkm_gender` char(1) DEFAULT NULL COMMENT '联系人性别', `lkm_phone` varchar(16) DEFAULT NULL COMMENT '联系人办公电话', `lkm_mobile` varchar(16) DEFAULT NULL COMMENT '联系人手机', `lkm_email` varchar(64) DEFAULT NULL COMMENT '联系人邮箱', `lkm_qq` varchar(16) DEFAULT NULL COMMENT '联系人qq', `lkm_position` varchar(16) DEFAULT NULL COMMENT '联系人职位', `lkm_memo` varchar(512) DEFAULT NULL COMMENT '联系人备注', PRIMARY KEY (`lkm_id`), KEY `FK_cst_linkman_lkm_cust_id` (`lkm_cust_id`), CONSTRAINT `FK_cst_linkman_lkm_cust_id` FOREIGN KEY (`lkm_cust_id`) REFERENCES `cst_customer` (`cust_id`) ON DELETE NO ACTION ON UPDATE NO ACTION) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 联系人表和联系人实体类映射文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;&lt;hibernate-mapping&gt; &lt;class name=\"com.example.hibernate.domain.LinkMan\" table=\"cst_linkman\"&gt; &lt;!-- 建立OID与主键映射 --&gt; &lt;id name=\"lkm_id\" column=\"lkm_id\"&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;!-- 建立普通属性与表字段映射 --&gt; &lt;property name=\"lkm_name\"/&gt; &lt;property name=\"lkm_gender\"/&gt; &lt;property name=\"lkm_phone\"/&gt; &lt;property name=\"lkm_mobile\"/&gt; &lt;property name=\"lkm_email\"/&gt; &lt;property name=\"lkm_qq\"/&gt; &lt;property name=\"lkm_position\"/&gt; &lt;property name=\"lkm_memo\"/&gt; &lt;!-- 配置多对一的关系：放置的是一的一方的对象 --&gt; &lt;!-- many-to-one标签 * name :一的一方的对象的属性名称。 * class :一的一方的类的全路径。 * column :在多的一方的表的外键的名称。 --&gt; &lt;many-to-one name=\"customer\" class=\"com.example.hibernate.domain.Customer\" column=\"lkm_cust_id\"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 测试代码 public void demo() &#123; Session session = HibernateUtil.openSession(); Transaction tx = session.beginTransaction(); tx.begin(); Customer customer1 = new Customer(); // 新建一个客户对象 customer1.setCust_name(\"客户1\"); LinkMan linkman1_1 = new LinkMan(); // 新建一个联系人 linkman1_1.setLkm_name(\"联系人1，属于客户1\"); linkman1_1.setCustomer(customer1); LinkMan linkMan1_2 = new LinkMan(); // 新建一个联系人 linkMan1_2.setLkm_name(\"联系人2，属于客户1\"); linkMan1_2.setCustomer(customer1); customer1.getLinkMans().add(linkman1_1); customer1.getLinkMans().add(linkMan1_2); // 联系人和客户对象都需要保存 session.save(customer1); session.save(linkman1_1); session.save(linkMan1_2); tx.commit(); session.close(); &#125; 一对多级联操作 什么叫级联：​ 级联指的是，操作一个对象的时候，是否会同时操作其关联的对象。 级联是有方向性 操作一的一方的时候，是否操作到多的一方 操作多的一方的时候，是否操作到一的一方 级联保存或者更新 保存客户级联联系人,需要在Customer.hbm.xml进行配置 配置映射文件Customer.hbm.xml &lt;!--cascade = \"save-update\"--&gt;&lt;set name=\"linkMans\" cascade=\"save-update\"&gt; &lt;key column=\"lkm_cust_id\"/&gt; &lt;one-to-many class=\"com.example.hibernate.domain.LinkMan\"/&gt;&lt;/set&gt; 测试 public void demo() &#123; Session session = HibernateUtil.openSession(); Transaction tx = session.beginTransaction(); Customer customer = new Customer(); customer.setCust_name(\"阿里巴巴\"); LinkMan linkman1 = new LinkMan(); linkman1.setLkm_name(\"阿里巴巴技术总监\"); LinkMan linkman2 = new LinkMan(); linkman2.setLkm_name(\"阿里巴巴开发组长\"); // 保存一边 customer.getLinkMans().add(linkman1); customer.getLinkMans().add(linkman2); // 保存一边 session.save(customer); tx.commit(); session.close();&#125; 保存联系人级联客户 与上述差不多的操作 修改LinkMan.hbm.xml &lt;many-to-one name=\"customer\" cascade=\"save-update\" class=\"com.example.hibernate.domain.Customer\" column=\"lkm_cust_id\"/&gt; 级联删除 级联删除：删除一边的时候，同时将另一方的数据也一并删除。 下面以一个具体的例子来说明： 1、删除客户，级联删除联系人 第一步，修改映射文件Customer.hbm.xml &lt;set name=\"linkMans\" cascade=\"delete\"&gt; 第二步，编写测试代码 @Testpublic void demo1()&#123; Session session = HibernateUtil.openSession(); Transaction tx = session.beginTransaction(); /** * (1)级联删除 * &lt;set name=\"linkMans\" cascade=\"delete\"&gt; */ Customer customer1 = session.get(Customer.class, 1L); session.delete(customer1); /** * (2)如果没有设置cascade=\"delete\" * 运行下面的结果为：只删除了一的一方，多的一方不会被删除 * 但是多的一方的外键会被设置为null */ Customer customer2 = session.get(Customer.class, 2L); session.delete(customer2); /** * (3)如果customer不是持久态度 * 这种方式不会删除多的一方 * 但是会把多的一方的外键设置为null */ Customer customer3 = new Customer(); customer3.setCust_id(3L); session.delete(customer3); tx.commit(); session.close();&#125; 删除联系人，级联删除客户 在一对多中一般不会出现这种情况：没有说删除多的一方，然后把一的一方删除的，因此下面只是测试使用 第一步,修改映射文件LinkMan.hbm.xml &lt;many-to-one name=\"customer\" cascade=\"delete\" class=\"com.example.hibernate.domain.Customer\" column=\"lkm_cust_id\"/&gt; 第二步,编写测试代码 @Testpublic void demo2()&#123; Session session = HibernateUtil.openSession(); Transaction tx = session.beginTransaction(); /** * 删除联系人，级联删除客户 * 在多的一方设置cascade=\"delete\" * &lt;many-to-one name=\"customer\" cascade=\"delete\" class=\"com.example.hibernate.domain.Customer\" column=\"lkm_cust_id\"/&gt; * * 运行结果： * 联系人和联系人关联的客户均被删除 * 和客户有关联的其他联系人的外键被设置为null */ LinkMan linkMan = session.get(LinkMan.class, 1L); session.delete(linkMan); tx.commit(); session.close();&#125; cascade 和 inverse cascade:级联 save update save-update delete inverse : 外键维护权 true 放弃外键维护权 false 拥有外键维护权，默认值","tags":[{"name":"Java","slug":"Java","permalink":"https://chsobin.github.io/tags/Java/"}]}]