<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>chsobin&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/0c2c72616bf80099b623b68335f8b810</icon>
  <subtitle>coding</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chsobin.github.io/"/>
  <updated>2019-04-02T14:21:27.518Z</updated>
  <id>https://chsobin.github.io/</id>
  
  <author>
    <name>陈松彬</name>
    <email>1748681439@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java知识点总结</title>
    <link href="https://chsobin.github.io/2019/04/02/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://chsobin.github.io/2019/04/02/Java知识点总结/</id>
    <published>2019-04-02T14:01:21.000Z</published>
    <updated>2019-04-02T14:21:27.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>这篇文章是对Java相关知识点的简要总结，主要记录了我个人之前所忽略的知识点</p></li><li><p>对于每个工具类的使用，这里不做详细探讨，具体可以参照官方文档，<a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/</a></p></li></ul><h1 id="入门基础"><a href="#入门基础" class="headerlink" title="入门基础"></a>入门基础</h1><ul><li><p><strong>Java程序运行机制</strong></p><p>编译和解释结合</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">*<span class="selector-class">.java</span> 源文件   编译成  *<span class="selector-class">.class</span> 字节码文件</span><br><span class="line"></span><br><span class="line">jvm解释执行字节码文件</span><br></pre></td></tr></table></figure><blockquote><p>面试题：Java是解释执行的，对吗？</p><p>解答：</p><p>Java引进JIT技术之后，能将一些热点代码直接编译成机器语言</p><p>JIT 是 just in time 的缩写, 也就是即时编译编译器。使用即时编译器技术，能够加速 Java 程序的执行速度。下面，就对该编译器技术做个简单的讲解。</p><p>首先，我们大家都知道，通常通过 javac 将程序源代码编译，转换成 java 字节码，JVM 通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢很多。为了提高执行速度，引入了 JIT 技术。</p><p>在运行时 JIT 会把翻译过的机器码保存起来，以备下次使用，因此从理论上来说，采用该 JIT 技术可以接近以前纯编译技术。</p></blockquote></li><li><p><strong>jvm、jre、jdk</strong></p><p><img src="jdk.png" alt="jdk"></p></li><li><p>jar 包 就是一些字节码文件进行打包    </p></li><li><p><strong>成员变量 与 局部变量</strong></p><p>成员变量会自动初始化为默认值；局部变量必须先赋值才能使用</p></li><li><p><strong>常量命名规范</strong>：大写+下划线 如 MAX_VALUE</p></li><li><p><strong>int范围</strong>  -2^31 到 2^31-1</p></li><li><p><strong>java浮点常量 可以用科学计数法表示</strong></p><p>eg: 314e2=31400 </p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">314E2</span>=<span class="number">31400</span> </span><br><span class="line">  </span><br><span class="line"><span class="attr">314E-2</span>=<span class="number">3.14</span></span><br></pre></td></tr></table></figure></li><li><p><strong>switch语句中case标签</strong>在JDK1.5之前必须是整数(long类型除外)或者枚举，不能是字符串，在JDK1.7之后允许使用字符串(String)。 </p></li><li><p><strong>重载</strong>：方法名相同，参数类型，个数，顺序不同</p></li></ul><h1 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h1><ul><li><p>java 内存模型</p><p><img src="jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="1551831947938">-</p></li><li><p><strong>静态导入</strong></p><p>jdk5之后的新特性 </p><p>其作用是用于导入指定类的静态属性，这样我们可以直接使用静态属性。 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;<span class="comment">//导入Math类的所有静态属性</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.PI;<span class="comment">//导入Math类的PI属性</span></span><br></pre></td></tr></table></figure></li><li><p><strong>方法的重写需要符合下面的三个要点：</strong></p><p>​      1.“==”： 方法名、形参列表相同。</p><p>​      2.“≤”：返回值类型和声明异常类型，子类小于等于父类。</p><p>​      3.“≥”： 访问权限，子类大于等于父类。</p></li><li><p><strong>访问权限修饰符 </strong></p><p>| 修饰符    | 同一个类 | 同一个包 | 子类 | 所有类 |<br>| ——— | ——– | ——– | —- | —— |<br>| private   | <em>        |          |      |        |<br>| default   | </em>        | <em>        |      |        |<br>| protected | </em>        | <em>        | </em>    |        |<br>| public    | <em>        | </em>        | <em>    | </em>      |</p><p>| 修饰符 | 同一个类 | 同一个包 | 子类 | 所有类 |<br>| - | - | - | - | - |<br>| private | <em> | | | |<br>| default | </em> | <em> | | |<br>| protected | </em> | <em> | </em> | |<br>| public | <em> | </em> | <em> | </em> |</p><p>| Table Header 1 | Table Header 2 | Table Header 3 |<br>| - | - | - |<br>| Division 1 | Division 2 | Division 3 |<br>| Division 1 | Division 2 | Division 3 |<br>| Division 1 | Division 2 | Division 3 |</p></li><li><p><strong>抽象类</strong></p><p>有抽象方法的类，abstract关键字修饰</p></li><li><p><strong>接口</strong></p><ul><li>interface可以继承多个接口，class可以实现多个接口</li><li>接口所有方法都是抽象，默认是 public abstract</li><li>接口里面的变量，默认都是 public static final,(也即是接口里面只能定义常量)</li></ul></li><li><p><strong>匿名内部类</strong></p><ul><li>不会生成.class文件。只能使用一次</li><li>匿名内部类中不能存在任何的静态成员变量和静态方法。</li><li>匿名内部类没有<em>构造器</em>，可以使用<em>构造代码块</em>代替</li></ul></li></ul><h1 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="Java异常类层次结构图.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>–<br><br>- Exception和Error的区别：Exception能被程序本身可以处理，Error是程序无法处理<br><br>- 需要注意的是，一旦某个catch捕获到匹配的异常类型，将进入异常处理代码。一经处理结束，就意味着整个try-catch语句结束。其他的catch子句不再有匹配和捕获异常类型的机会。<br><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkZero</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&gt;=-<span class="number">1</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">10</span>/i;</span><br><span class="line">            System.out.println(<span class="string">"i="</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkZero();    <span class="comment">// 一个异常只会被一个catch捕捉</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (ArithmeticException mathException)&#123;</span><br><span class="line">            System.out.println(<span class="string">"catch ArithmeticException"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception exception)&#123;</span><br><span class="line">            System.out.println(<span class="string">"catch Exception"</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.print(<span class="string">"finally"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行结果：</span></span><br><span class="line"><span class="comment"> * i=3</span></span><br><span class="line"><span class="comment"> * i=2</span></span><br><span class="line"><span class="comment"> * i=1</span></span><br><span class="line"><span class="comment"> * catch ArithmeticException</span></span><br><span class="line"><span class="comment"> * finally</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="Java%E9%9B%86%E5%90%88.webp" alt="Java集合" title>                </div>                <div class="image-caption">Java集合</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%9B%BE.webp" alt="Java集合框架图" title>                </div>                <div class="image-caption">Java集合框架图</div>            </figure><p>1、所有集合类都位于<code>java.util</code>包下。Java的集合类主要由两个接口派生而出：Collection和Map，Collection和Map是Java集合框架的根接口，这两个接口又包含了一些子接口或实现类。</p><p>2、集合接口：6个接口（短虚线表示），表示不同集合类型，是集合框架的基础。</p><p>3、抽象类：5个抽象类（长虚线表示），对集合接口的部分实现。可扩展为自定义集合类。</p><p>4、实现类：8个实现类（实线表示），对接口的具体实现。</p><p>5、Collection 接口是一组允许重复的对象。</p><p>6、Set 接口继承 Collection，集合元素不重复。</p><p>7、List 接口继承 Collection，允许重复，维护元素插入顺序。</p><p>8、Map接口是键－值对象，与Collection接口没有什么关系。</p><p>9、Set、List和Map可以看做集合的三大类：</p><ul><li>List集合是有序集合，集合中的元素可以重复，访问集合中的元素可以根据元素的索引来访问。</li><li>Set集合是无序集合，集合中的元素不可以重复，访问集合中的元素只能根据元素本身来访问（也是集合里元素不允许重复的原因）。</li><li>Map集合中保存Key-value对形式的元素，访问时只能根据每项元素的key来访问其value。</li></ul><h1 id="IO流技术"><a href="#IO流技术" class="headerlink" title="IO流技术"></a>IO流技术</h1><ul><li><p><strong>如何理解流？</strong></p><blockquote><p>流是个抽象的概念，是对输入输出设备的抽象，Java程序中，对于数据的输入/输出操作都是以“流”的方式进行。设备可以是文件，网络，内存等。</p></blockquote><blockquote><p>摘自Oracle官方文档：<a href="https://docs.oracle.com/javase/tutorial/essential/io/streams.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/essential/io/streams.html</a></p><p>An <em>I/O Stream</em> represents an input source or an output destination. A stream can represent many different kinds of sources and destinations, including disk files, devices, other programs, and memory arrays.</p><p>Streams support many different kinds of data, including simple bytes, primitive data types, localized characters, and objects. Some streams simply pass on data; others manipulate and transform the data in useful ways.</p><p>No matter how they work internally, all streams present the same simple model to programs that use them: A stream is a sequence of data. </p></blockquote></li><li><p><strong>常用类</strong> （学习使用的最好方法就是jdk api 文档）</p><ul><li><p>File 表示数据源</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文件路径建议</span></span><br><span class="line">String path = <span class="string">"D:/dir/a.txt"</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">String path2 = <span class="string">"D:"</span> + File.separator + <span class="string">"dir"</span> + File.separator + <span class="string">"a.txt"</span>;</span><br></pre></td></tr></table></figure></li><li><p>四大抽象类</p><ul><li>InputStream</li><li>OutputStream</li><li>Reader</li><li>Writer</li></ul></li><li><p>FileInputStream FileOutputStream 文件字节流 ，数据在硬盘</p></li><li><p>ByteArrayInputStream ByteArrayOutputStream 字节数组流，数据源在虚拟机内存</p></li></ul></li><li><p><strong>解码、编码</strong></p><ul><li>编码： 字符  ——– 使用特定字符集（如UTF-8 ）——-&gt; 字节 </li><li>解码： 字节 ———-使用特定字符集 ———&gt;字符</li><li>出现乱码的原因</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String msg = <span class="string">"你好啊"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] datas = msg.getBytes();<span class="comment">// 默认使用工程的字符集进行编码，此处假设为UTF-8</span></span><br><span class="line"><span class="comment">//(1) 字节数不够</span></span><br><span class="line">msg = <span class="keyword">new</span> String(datas, <span class="number">0</span>, datas.length-<span class="number">1</span>, <span class="string">"utf8"</span>);</span><br><span class="line">System.out.println(msg);</span><br><span class="line"><span class="comment">//(2) 编码解码的字符集不同</span></span><br><span class="line">msg = <span class="keyword">new</span> String(datas, <span class="string">"gbk"</span>);</span><br><span class="line">System.out.println(msg);</span><br></pre></td></tr></table></figure></li><li><p>IO操作基本步骤</p><ul><li>选择数据源</li><li>选择数据流</li><li>读或者写操作</li><li>释放资源</li></ul></li><li><p>IO相关类 很多利用了 装饰者模式</p><p><img src="%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F.JPG" alt></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);<span class="comment">// 将FileInputStream对象作为参数传入</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><ul><li><p>java多线程三种实现方法</p><ul><li>继承Thread类</li><li>实现Runnable接口</li><li>实现Callable接口</li></ul></li><li><p>实现Runnable接口这种方式用到了<strong>静态代理</strong>这个设计模式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(实现了Runnable接口的对象).start();</span><br></pre></td></tr></table></figure></li><li><p><strong>静态代理设计模式</strong>：</p><p><img src="静态代理.png" alt="静态代理"></p><p>代理模式主要包含三个角色，即抽象主题角色(Subject)、委托类角色(被代理角色，Proxied)以及代理类角色(Proxy)，如上图所示：</p><p>抽象主题角色:可以是接口，也可以是抽象类；<br>委托类角色：真实主题角色，业务逻辑的具体执行者；<br>代理类角色：内部含有对真实对象RealSubject的引用，负责对真实主题角色的调用，并在真实主题角色处理<strong>前后</strong>做预处理和后处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Driverable</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 被代理角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Driverable</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"moving..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartCar</span> <span class="keyword">implements</span> <span class="title">Driverable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Driverable target;<span class="comment">// 持有被代理对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SmartCar</span><span class="params">(Driverable target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.target = target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">begin(); <span class="comment">// 增强功能</span></span><br><span class="line">target.drive();</span><br><span class="line">end();<span class="comment">// 增强功能</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"启动智能系统"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"关闭智能系统"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>线程五种状态</strong></p><p><img src="线程五种状态.jpg" alt="线程五种状态"></p><ol><li><p>新建状态(New) : 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。</p></li><li><p>就绪状态(Runnable): 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。 </p></li><li><p>运行状态(Running): 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。 </p></li><li><p>阻塞状态(Blocked)  : 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：   </p><p>（1） 等待阻塞 – 通过调用线程的wait()方法，让线程等待某工作的完成。    </p><p>（2） 同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。     </p><pre><code>（3）其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。 </code></pre></li><li><p>死亡状态(Dead)    : 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 </p></li></ol></li><li><p><strong>同步块</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// obj称之为同步监视器</span></span><br><span class="line"><span class="keyword">synchronized</span>(obj)&#123; 代码 &#125;</span><br></pre></td></tr></table></figure><ul><li>obj可以是任何对象，推荐使用共享资源作为同步监视器</li><li>同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this(即该对象本身)，或class(即类的模子)</li></ul></li></ul><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><ul><li><p>是什么：</p><p>Java注解又称Java标注 </p><p>Java语言中的类、方法、变量、参数和包等都可以被标注。</p><p>和Javadoc不同，Java标注可以通过反射获取标注内容。</p><p>在编译器生成类文件时，标注可以被嵌入到字节码中。Java虚拟机可以保留标注内容，在运行时可以获取到标注内容。</p></li><li><p>元注解</p><ul><li><p>是用于修饰注解的注解，通常用在注解的定义上，例如： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@Target：注解的作用目标</li><li>@Retention：注解的生命周期</li><li>@Documented：注解是否应当被包含在 JavaDoc 文档中</li><li>@Inherited：是否允许子类继承该注解</li></ul></li></ul></li><li><p>自定义注解</p><ul><li>定义一个用于数据库表的注解</li><li>注解里面可以定义注解元素，格式为类型 元素名() [default 元素值] </li><li>如果不指明default值，使用时必须传入元素值</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)<span class="comment">//只能应用于类上</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="comment">//保存到运行时</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DBTable &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在类上使用该注解</span></span><br><span class="line"><span class="meta">@DBTable</span>(name = <span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">// javabean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><ul><li><p>自动装箱，自动拆箱</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a = <span class="number">1</span>; <span class="comment">// 自动装箱，编译器会转化为 Integer a = Integer.valueOf(1)</span></span><br><span class="line"><span class="keyword">int</span> b = a; <span class="comment">// 自动拆箱 int b = a.intValue();</span></span><br></pre></td></tr></table></figure></li><li><p>缓存机制，缓存[-128, 127]之间的数字，具体查看Integer.valueOf()源码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer x = -<span class="number">128</span>;</span><br><span class="line">Integer y = Integer.valueOf(-<span class="number">128</span>);</span><br><span class="line">System.out.println(x==y);<span class="comment">// true</span></span><br><span class="line">System.out.println(x.equals(y));<span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="字符串相关类"><a href="#字符串相关类" class="headerlink" title="字符串相关类"></a>字符串相关类</h1><ul><li>StringBuffer  线程安全</li><li>StringBuilder 线程不安全</li></ul><h1 id="时间处理相关类"><a href="#时间处理相关类" class="headerlink" title="时间处理相关类"></a>时间处理相关类</h1><ul><li><p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3%E7%B1%BB.png" alt="时间日期相关类" title>                </div>                <div class="image-caption">时间日期相关类</div>            </figure>时间处理类之间的关系</p></li><li><p>DateFormat 抽象类 与 SimpleDateFormat 使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">    <span class="comment">// new出SimpleDateFormat对象</span></span><br><span class="line">    SimpleDateFormat s1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>);</span><br><span class="line">    <span class="comment">// 将时间对象转换成字符串</span></span><br><span class="line">    String daytime = s1.format(<span class="keyword">new</span> Date());</span><br><span class="line">    System.out.println(daytime);</span><br><span class="line">    <span class="comment">// 将符合指定格式的字符串转成成时间对象.字符串格式需要和指定格式一致。</span></span><br><span class="line">    String time = <span class="string">"2007-10-7 20:15:30"</span>;</span><br><span class="line">    Date date = s1.parse(time);</span><br><span class="line">    System.out.println(date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="文件类"><a href="#文件类" class="headerlink" title="文件类"></a>文件类</h1><ul><li><p>常用方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">"d:/c.txt"</span>);</span><br><span class="line">f.createNewFile(); <span class="comment">// 会在d盘下面生成c.txt文件</span></span><br><span class="line">f.delete(); <span class="comment">// 将该文件或目录从硬盘上删除</span></span><br><span class="line">System.out.println(<span class="string">"File是否存在："</span>+f.exists());</span><br><span class="line">System.out.println(<span class="string">"File是否是目录："</span>+f.isDirectory());</span><br><span class="line">System.out.println(<span class="string">"File是否是文件："</span>+f.isFile());</span><br><span class="line">System.out.println(<span class="string">"File最后修改时间："</span>+<span class="keyword">new</span> Date(f.lastModified()));</span><br><span class="line">System.out.println(<span class="string">"File的大小："</span>+f.length());</span><br><span class="line">System.out.println(<span class="string">"File的文件名："</span>+f.getName());</span><br><span class="line">System.out.println(<span class="string">"File的目录路径："</span>+f.getPath());</span><br></pre></td></tr></table></figure></li><li><p>创建目录</p><ul><li><p>mkdir</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File f2 = <span class="keyword">new</span> File(<span class="string">"d:/电影/华语/大陆"</span>);</span><br><span class="line"><span class="keyword">boolean</span> flag = f2.mkdir(); <span class="comment">//目录结构中有一个不存在，则不会创建整个目录树</span></span><br><span class="line">System.out.println(flag);<span class="comment">//创建失败</span></span><br></pre></td></tr></table></figure></li><li><p>mkdirs</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File f2 = <span class="keyword">new</span> File(<span class="string">"d:/电影/华语/大陆"</span>);</span><br><span class="line"><span class="keyword">boolean</span> flag = f2.mkdirs();<span class="comment">//目录结构中有一个不存在也没关系；创建整个目录树</span></span><br><span class="line">System.out.println(flag);<span class="comment">//创建成功</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><ul><li><p>所有的枚举类型隐性地继承自 java.lang.Enum。</p></li><li><p>枚举实质上还是类，而每个被枚举的成员实质就是一个枚举类型的实例，他们默认都是public static final修饰的。可以直接通过枚举类型名使用它们。 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**季节*/</span></span><br><span class="line"><span class="keyword">enum</span> Season &#123;</span><br><span class="line">    SPRING, SUMMER, AUTUMN, WINDTER</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**星期*/</span></span><br><span class="line"><span class="keyword">enum</span> Week &#123;</span><br><span class="line">    星期一, 星期二, 星期三, 星期四, 星期五, 星期六, 星期日</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="如何去学习框架"><a href="#如何去学习框架" class="headerlink" title="如何去学习框架"></a>如何去学习框架</h1><ul><li><p>是什么</p></li><li><p>为什么用</p></li><li><p>怎么做  小实例，最好跟着官方文档的示例做</p></li><li><p>框架提供的api ( 相关类的使用 )</p></li><li><p>框架相关配置文件</p><blockquote><p>个人理解，配置文件使得我们的系统解耦</p><p>一旦需求有变，只需要修改配置文件即可，无需更改源代码</p></blockquote></li></ul><p>以上为快速入门一个框架，说到底就是先学会怎么用工具，但是仅仅学会用是不够的。在会用的基础上，要站在高位去审视整个框架，去理解框架的架构，去更好地利用框架。如果框架本身提供的功能不能满足我们的需求，我们完全可以修改框架或者创造一个框架出来</p><h1 id="高级主题"><a href="#高级主题" class="headerlink" title="高级主题"></a>高级主题</h1><ul><li>反射<ul><li>动态代理</li></ul></li><li>jdbc</li><li>网络</li><li>多线程</li><li>JVM</li><li>设计模式</li></ul><p>对于高级主题推荐的书籍：</p><p>《java 并发编程实战》</p><p>《深入理解 java 虚拟机》</p><p>《mysql 必知必会》</p><p>《大话设计模式》</p><p>计算机网络：《TCP/IP详解卷一：协议》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;这篇文章是对Java相关知识点的简要总结，主要记录了我个人之前所忽略的知识点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于每个工
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://chsobin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://chsobin.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>测试代码块缩进问题</title>
    <link href="https://chsobin.github.io/2019/04/02/%E4%BB%A3%E7%A0%81%E5%9D%97%E7%BC%A9%E8%BF%9B%E9%97%AE%E9%A2%98/"/>
    <id>https://chsobin.github.io/2019/04/02/代码块缩进问题/</id>
    <published>2019-04-01T18:28:30.000Z</published>
    <updated>2019-04-01T19:19:38.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><p>使用Typora写文章时，发现从eclipse粘贴过来的代码经过hexo转化之后，缩进出现了错误</p><p>如下：明明是四个空格，却显示了8个</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Session session = HibernateUtil.openSession();</span><br><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line">tx.begin();</span><br><span class="line"></span><br><span class="line">Customer customer1 = <span class="keyword">new</span> Customer(); <span class="comment">// 新建一个客户对象</span></span><br><span class="line">customer1.setCust_name(<span class="string">"客户1"</span>);</span><br><span class="line"></span><br><span class="line">LinkMan linkman1_1 = <span class="keyword">new</span> LinkMan();<span class="comment">// 新建一个联系人</span></span><br><span class="line">linkman1_1.setLkm_name(<span class="string">"联系人1，属于客户1"</span>);</span><br><span class="line">linkman1_1.setCustomer(customer1);</span><br><span class="line"></span><br><span class="line">LinkMan linkMan1_2 = <span class="keyword">new</span> LinkMan();<span class="comment">// 新建一个联系人</span></span><br><span class="line">linkMan1_2.setLkm_name(<span class="string">"联系人2，属于客户1"</span>);</span><br><span class="line">linkMan1_2.setCustomer(customer1);</span><br><span class="line"></span><br><span class="line">customer1.getLinkMans().add(linkman1_1);</span><br><span class="line">customer1.getLinkMans().add(linkMan1_2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联系人和客户对象都需要保存</span></span><br><span class="line">session.save(customer1);</span><br><span class="line">session.save(linkman1_1);</span><br><span class="line">session.save(linkMan1_2);</span><br><span class="line"></span><br><span class="line">tx.commit();</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>详情参考：<a href="https://blog.csdn.net/qq_37932863/article/details/73611785" target="_blank" rel="noopener">https://blog.csdn.net/qq_37932863/article/details/73611785</a></p><p>解决之后，再次粘贴代码：可以看到缩进正常了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Session session = HibernateUtil.openSession();</span><br><span class="line">        Transaction tx = session.beginTransaction();</span><br><span class="line">        tx.begin();</span><br><span class="line">        </span><br><span class="line">        Customer customer1 = <span class="keyword">new</span> Customer(); <span class="comment">// 新建一个客户对象</span></span><br><span class="line">        customer1.setCust_name(<span class="string">"客户1"</span>);</span><br><span class="line">        </span><br><span class="line">        LinkMan linkman1_1 = <span class="keyword">new</span> LinkMan(); <span class="comment">// 新建一个联系人</span></span><br><span class="line">        linkman1_1.setLkm_name(<span class="string">"联系人1，属于客户1"</span>);</span><br><span class="line">        linkman1_1.setCustomer(customer1);</span><br><span class="line">        </span><br><span class="line">        LinkMan linkMan1_2 = <span class="keyword">new</span> LinkMan(); <span class="comment">// 新建一个联系人</span></span><br><span class="line">        linkMan1_2.setLkm_name(<span class="string">"联系人2，属于客户1"</span>);</span><br><span class="line">        linkMan1_2.setCustomer(customer1);</span><br><span class="line">        </span><br><span class="line">        customer1.getLinkMans().add(linkman1_1);</span><br><span class="line">        customer1.getLinkMans().add(linkMan1_2);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 联系人和客户对象都需要保存</span></span><br><span class="line">        session.save(customer1);</span><br><span class="line">        session.save(linkman1_1);</span><br><span class="line">        session.save(linkMan1_2);</span><br><span class="line">        </span><br><span class="line">        tx.commit();</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题：&quot;&gt;&lt;a href=&quot;#问题：&quot; class=&quot;headerlink&quot; title=&quot;问题：&quot;&gt;&lt;/a&gt;问题：&lt;/h1&gt;&lt;p&gt;使用Typora写文章时，发现从eclipse粘贴过来的代码经过hexo转化之后，缩进出现了错误&lt;/p&gt;
&lt;p&gt;如下：明明是四个空格
      
    
    </summary>
    
      <category term="问题集" scheme="https://chsobin.github.io/categories/%E9%97%AE%E9%A2%98%E9%9B%86/"/>
    
    
      <category term="hexo" scheme="https://chsobin.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate学习笔记</title>
    <link href="https://chsobin.github.io/2019/04/01/Hibernate%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://chsobin.github.io/2019/04/01/Hibernate学习笔记/</id>
    <published>2019-04-01T15:52:36.000Z</published>
    <updated>2019-04-01T18:28:57.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><ul><li>Hibernate是一种ORM(Object Relational Mapping ）框架</li><li>它对JDBC进行了非常轻量级的对象封装 </li><li>hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库 </li></ul><a id="more"></a><h2 id="为什么要用"><a href="#为什么要用" class="headerlink" title="为什么要用"></a>为什么要用</h2><ul><li>传统基于JDBC的开发，代码重复性过多</li><li>使用Hibernate框架，简化了Dao层的编码工作，不用我们写很多繁琐的SQL语句</li></ul><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>注意：此案例基于hibernate-release-5.0.7.Final</p><p><strong>（1）下载Hibernate 开发环境，解压后有三个主要文件夹</strong></p><ul><li>documentation          :Hibernate开发的文档</li><li>lib                                  :Hibernate开发包<ul><li>required                       :Hibernate开发的必须的依赖</li><li>optional                         :Hibernate开发的可选的jar包</li></ul></li><li>project                          :Hibernate提供的项目</li></ul><p><strong>（2）创建一个项目，引入jar包</strong></p><ul><li>数据库驱动包  mysql-connector-java-5.1.7-bin.jar</li><li>Hibernate开发的必须的jar包。  步骤1中required中所有的包</li><li>日志记录包<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="log4j.png" alt title>                </div>                <div class="image-caption"></div>            </figure></li></ul><p><strong>（3）创建表</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`cst_customer`</span> (</span><br><span class="line">  <span class="string">`cust_id`</span> <span class="built_in">bigint</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'客户编号(主键)'</span>,</span><br><span class="line">  <span class="string">`cust_name`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'客户名称(公司名称)'</span>,</span><br><span class="line">  <span class="string">`cust_source`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'客户信息来源'</span>,</span><br><span class="line">  <span class="string">`cust_industry`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'客户所属行业'</span>,</span><br><span class="line">  <span class="string">`cust_level`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'客户级别'</span>,</span><br><span class="line">  <span class="string">`cust_phone`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'固定电话'</span>,</span><br><span class="line">  <span class="string">`cust_mobile`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'移动电话'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`cust_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><p><strong>（4）创建实体类</strong></p><p>​    com.example.hibernate.demo1.Customer.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Long cust_id;</span><br><span class="line"><span class="keyword">private</span> String cust_name;</span><br><span class="line"><span class="keyword">private</span> String cust_source;</span><br><span class="line"><span class="keyword">private</span> String cust_industry;</span><br><span class="line"><span class="keyword">private</span> String cust_level;</span><br><span class="line"><span class="keyword">private</span> String cust_phone;</span><br><span class="line"><span class="keyword">private</span> String cust_mobile;</span><br><span class="line"><span class="comment">// 省略getter setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（5）创建实体类Customer 与表cst_customer的映射</strong></p><p>src/com/example/hibernate/demo1/Customer.hbm.xml</p><p>命名格式一般为：类名.hbm.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC </span></span><br><span class="line"><span class="meta">    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 建立类与表的映射 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"com.example.hibernate.demo1.Customer"</span> <span class="attr">table</span>=<span class="string">"cst_customer"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 建立类中的属性与表中的主键对应 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"cust_id"</span> <span class="attr">column</span>=<span class="string">"cust_id"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 建立类中的普通的属性和表的字段的对应 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_name"</span> <span class="attr">column</span>=<span class="string">"cust_name"</span> <span class="attr">length</span>=<span class="string">"32"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_source"</span> <span class="attr">column</span>=<span class="string">"cust_source"</span> <span class="attr">length</span>=<span class="string">"32"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_industry"</span> <span class="attr">column</span>=<span class="string">"cust_industry"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_level"</span> <span class="attr">column</span>=<span class="string">"cust_level"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_phone"</span> <span class="attr">column</span>=<span class="string">"cust_phone"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_mobile"</span> <span class="attr">column</span>=<span class="string">"cust_mobile"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>注意：</em></p><p><em>(1)该配置文件的DTD 在hibernate-core-5.0.7.Final.jar包下的/org/hibernate/hibernate-mapping-3.0.dtd</em></p><p><em>(2)在eclipse中设置xml自动提示，需要告诉eclipse相应的DTD文件位置具体设置可以自行百度</em></p><p><strong>（6）创建Hibernate的核心配置文件</strong></p><ul><li>Hibernate的核心配置文件的名称：hibernate.cfg.xml</li><li>放置在src目录下</li><li>该配置文件的DTD 在hibernate-core-5.0.7.Final.jar包下的/org/hibernate/hibernate-configuration-3.0.dtd</li><li>具体怎么写可以参考步骤1中project文件夹下的/etc/hibernate.properties</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-configuration PUBLIC</span></span><br><span class="line"><span class="meta">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 连接数据库的基本参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql:///hibernate<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.password"</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置Hibernate的方言 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 可选配置================ --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 打印SQL --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 格式化SQL ，使得打印出来的SQL语句更加美观--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">&lt;!-- 映射文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"com/example/hibernate/demo1/Customer.hbm.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>（7）编写测试代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">// 保存客户的案例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 1.加载Hibernate的核心配置文件</span></span><br><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line"><span class="comment">// 手动加载映射</span></span><br><span class="line"><span class="comment">// configuration.addResource("com/example/hibernate/demo1/Customer.hbm.xml");</span></span><br><span class="line"><span class="comment">// 2.创建一个SessionFactory对象：类似于JDBC中连接池 </span></span><br><span class="line">SessionFactory sessionFactory = configuration.buildSessionFactory();</span><br><span class="line"><span class="comment">// 3.通过SessionFactory获取到Session对象：类似于JDBC中Connection</span></span><br><span class="line">Session session = sessionFactory.openSession();</span><br><span class="line"><span class="comment">// 4.手动开启事务：</span></span><br><span class="line">Transaction transaction = session.beginTransaction();</span><br><span class="line"><span class="comment">// 5.编写代码</span></span><br><span class="line"></span><br><span class="line">Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">customer.setCust_name(<span class="string">"王西"</span>);</span><br><span class="line"></span><br><span class="line">session.save(customer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.事务提交</span></span><br><span class="line">transaction.commit();</span><br><span class="line"><span class="comment">// 7.资源释放</span></span><br><span class="line">session.close();</span><br><span class="line">sessionFactory.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="映射的配置"><a href="#映射的配置" class="headerlink" title="映射的配置"></a>映射的配置</h2><ul><li><p>【class标签的配置】建立类与表的映射关系</p><p>属性：</p><ul><li>name                ：类的全路径</li><li>table                 ：表名（类名与表名一致，table可以省略）</li><li>catalog              ：数据库名</li></ul></li><li><p>【id标签的配置】类中的属性与表中的主键的对应关系</p><p>属性：</p><ul><li>name                ：类中的属性名</li><li>column             ：表中的字段名（类中的属性名和表中的字段名如果一致，column可以省略）</li><li>length               ：长度</li><li>type                  ：类型</li></ul></li><li><p>【property标签的配置】类中的普通属性与表的字段的对应关系</p><p> 属性：</p><ul><li>name                ：类中的属性名</li><li>column              ：表中的字段名</li><li>length               ：长度</li><li>type                   ：类型</li><li>not-null             ：设置非空</li><li>unique              ：设置唯一</li></ul></li></ul><h2 id="核心配置"><a href="#核心配置" class="headerlink" title="核心配置"></a>核心配置</h2><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载Hibernate的核心配置文件</span></span><br><span class="line">Configuration configuration = <span class="keyword">new</span> <span class="type">Configuration</span>().configure();</span><br><span class="line"><span class="comment">// 该语句默认会到src/hibernate.cfg.xml加载核心配置文件</span></span><br></pre></td></tr></table></figure><ul><li><p>必须的配置</p><ul><li>连接数据库的基本的参数<ul><li>驱动类</li><li>url路径</li><li>用户名 </li><li>密码</li><li>方言</li></ul></li></ul></li><li><p>可选的配置</p><ul><li>显示SQL         ：hibernate.show_sql</li><li>格式化SQL     ：hibernate.format_sql</li><li>自动建表        ：hibernate.hbm2ddl.auto<ul><li>none                 ：不使用hibernate的自动建表</li><li>create               ：如果数据库中已经有表，<strong>删除原有表</strong>，重新创建，如果没有表，新建表。（测试）</li><li>create-drop     ：如果数据库中已经有表，<strong>删除原有表，执行操作，删除这个表</strong>。如果没有表，新建一个，使用完了删除该表。（测试）</li><li>update             ：如果数据库中有表，使用原有表，如果没有表，创建新表（<strong>更新表结构</strong>）</li><li>validate            ：如果没有表，不会创建表。只会使用数据库中原有的表。（校验映射和表结构）。</li></ul></li></ul></li><li><p>映射文件的引入     </p><p>引入映射文件的位置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"com/example/hibernate/demo1/Customer.hbm.xml"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>例子：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-configuration PUBLIC</span></span><br><span class="line"><span class="meta">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 连接数据库的基本参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql:///hibernate<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.password"</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置Hibernate的方言 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 可选配置================ --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 打印SQL --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 格式化SQL ，使得打印出来的SQL语句更加美观--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">&lt;!-- 自动创建表 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">         <span class="comment">&lt;!-- 映射文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"com/example/hibernate/demo1/Customer.hbm.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><ul><li><p>Configuration</p><ul><li>用来加载配置文件</li></ul></li><li><p>SessionFactory</p><ul><li>用来创建Session</li><li>内部维护连接池</li><li>比较重量级，一般一个应用只创建一个对象</li><li>线程安全</li></ul></li><li><p>Session</p><ul><li>与数据库进行交互</li><li>线程不安全</li></ul></li><li><p>Transaction</p><p>​    事务commit()  rollback()</p></li></ul><h2 id="主键生成策略"><a href="#主键生成策略" class="headerlink" title="主键生成策略"></a>主键生成策略</h2><ul><li><p>主键的分类</p><ul><li><p>自然主键：主键本身就是表中的一个字段</p><p>eg:学生表中，学号就是自然属性</p></li><li><p>代理主键：不是表的字段，比如设置一个自增长的id字段</p><p><strong>尽量使用代理主键</strong></p></li></ul></li><li><p><strong>hibernate主键生成策略</strong></p><ul><li><strong>increment</strong> :hibernate中提供的自动增长机制<ul><li>实现原理，首先发送一条语句select max(id) from 表，然后以id+1作为下一条记录的主键</li><li>线程不安全，原因见实现原理</li></ul></li><li><strong>indentity</strong> 使用数据库底层的自动增长机制<ul><li><em>Oracle不支持自动增长机制</em></li></ul></li><li><strong>sequence</strong> 采用序列的方式<ul><li><em>Oracle支持，但MySQL不支持</em></li></ul></li><li><strong>uuid</strong> 适用于字符串类型的主键<ul><li><em>与上述三种进行区分，上述increment ，indentity ，sequence适用于short,int,long类型的主键</em></li></ul></li><li><strong>native</strong> 会根据底层数据库自动选择identity 或者 sequence</li><li><strong>assigened</strong> 该生成策略的主键值来自程序员手工设置，即通过setId()方法设置。属性类型可以是String、Int，但一般为String。此生成策略用于业务相关主键。例如学号、身份证号做主键</li></ul></li></ul><h2 id="持久化类的三种状态"><a href="#持久化类的三种状态" class="headerlink" title="持久化类的三种状态"></a>持久化类的三种状态</h2><ul><li>瞬时态（transient）没有唯一的标识OID,没有被session管理</li><li>持久态（persister）有唯一标识OID,被session管理</li><li>托管态（detached）有唯一标识OID,没有被session管理</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Session session = HibernateUtil.openSession();<span class="comment">// 自定义工具类</span></span><br><span class="line">Transaction transaction = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">Customer customer = <span class="keyword">new</span> Customer();<span class="comment">// 瞬时态对象</span></span><br><span class="line">customer.setCust_name(<span class="string">"小明"</span>);</span><br><span class="line"></span><br><span class="line">session.save(customer); <span class="comment">// 持久态对象 </span></span><br><span class="line">customer.setCust_mobile(<span class="string">"110"</span>); <span class="comment">// 持久态对象，对customer的更改会同时更改数据库</span></span><br><span class="line"></span><br><span class="line">transaction.commit();</span><br><span class="line">session.close();</span><br><span class="line"></span><br><span class="line">System.out.println(customer); <span class="comment">// 脱管态对象 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="Hiberbate持久化类三种状态转换图.gif" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><ul><li><p>为了减少与数据库交互的次数，session内部维护了一个缓存</p></li><li><p>所有对javabean的更改，不会立即发送sql语句到数据库，而是先更改一级缓存</p></li><li><p>跟session一样的生命周期</p><p><img src="hibernate_cache.jpg" alt>———-</p></li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ul><li><h3 id="事务的四个特性"><a href="#事务的四个特性" class="headerlink" title="事务的四个特性"></a>事务的四个特性</h3><ul><li><p><strong>原子性（Atomicity）</strong>：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</p></li><li><p><strong>一致性（Consistency）</strong>：保证事务只能把数据库从一个有效（正确）的状态“转移”到另一个有效（正确）的状态 </p><blockquote><p><em>那么，什么是数据库的有效(正确）的状态？满足给这个数据库pred-defined的一些规则的状态都是 valid 的。这些规则有哪些呢，比如说constraints, cascade,triggers及它们的组合等。具体到某个表的某个字段，比如你在定义表的时候，给这个字段的类型是number类型，并且它的值不能小于0，那么你在某个 transaction 中给这个字段插入（更改）为一个 String 值或者是负值是不可以的，这不是一个“合法”的transaction，也就是说它不满足我们给数据库定义的一些规则（约束条件）。</em></p></blockquote></li><li><p><strong>隔离性（Isolation）</strong>：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</p></li><li><p><strong>持久性（Durability）</strong>：已被提交的事务对数据库的修改应该永久保存在数据库中。</p></li></ul></li><li><h3 id="并发事务会产生的问题"><a href="#并发事务会产生的问题" class="headerlink" title="并发事务会产生的问题"></a>并发事务会产生的问题</h3><ul><li><p><strong>丢失更新</strong></p><ul><li><p>第一类丢失更新 </p><p>​    定义：A事务撤销时，把已经提交的B事务的更新数据覆盖了。</p></li><li><p>第二类丢失更新</p><p>​    定义： A事务提交时，把已经提交的B事务的更新数据覆盖了。<em>（属于不可重复读的一个特例）</em></p></li></ul></li><li><p><strong>脏读</strong>：读到未提交更新的数据 </p></li><li><p><strong>不可重复读</strong>：读到已经提交更新的数据，但一个事务范围内两个相同的查询却返回了不同数据。 </p></li><li><p><strong>幻读</strong>：读到已提交插入数据，幻读与不可重复读类似，幻读是查询到了另一个事务已提交的新插入数据，而不可重复读是查询到了另一个事务已提交的更新数据。 </p></li></ul></li><li><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ul><li>未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据</li><li>提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)</li><li>可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读</li><li>串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞</li></ul></li><li><h3 id="隔离级别与并发问题"><a href="#隔离级别与并发问题" class="headerlink" title="隔离级别与并发问题"></a>隔离级别与并发问题</h3><p>| 隔离级别                     | 脏读     | 不可重复读 | 幻读     |<br>| —————————- | ——– | ———- | ——– |<br>| SERIALIZABLE （串行化）      | 不会发生 | 不会发生   | 不会发生 |<br>| REPEATABLE READ（可重复读）  | 不会发生 | 不会发生   | 可能发生 |<br>| READ COMMITTED （读已提交）  | 不会发生 | 可能发生   | 可能发生 |<br>| READ UNCOMMITTED（读未提交） | 可能发生 | 可能发生   | 可能发生 |</p></li></ul><h2 id="Hibernate-一对多关系"><a href="#Hibernate-一对多关系" class="headerlink" title="Hibernate 一对多关系"></a>Hibernate 一对多关系</h2><p>以一个例子来说明：</p><p>两个实体类：一个客户可以有多个联系人</p><ul><li><p>客户表</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// sql语句</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`cst_customer`</span> (</span><br><span class="line">  <span class="string">`cust_id`</span> <span class="built_in">bigint</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'客户编号(主键)'</span>,</span><br><span class="line">  <span class="string">`cust_name`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'客户名称(公司名称)'</span>,</span><br><span class="line">  <span class="string">`cust_source`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'客户信息来源'</span>,</span><br><span class="line">  <span class="string">`cust_industry`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'客户所属行业'</span>,</span><br><span class="line">  <span class="string">`cust_level`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'客户级别'</span>,</span><br><span class="line">  <span class="string">`cust_phone`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'固定电话'</span>,</span><br><span class="line">  <span class="string">`cust_mobile`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'移动电话'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`cust_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure></li><li><p>Customer实体类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户的实体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Long cust_id;</span><br><span class="line"><span class="keyword">private</span> String cust_name;</span><br><span class="line"><span class="keyword">private</span> String cust_source;</span><br><span class="line"><span class="keyword">private</span> String cust_industry;</span><br><span class="line"><span class="keyword">private</span> String cust_level;</span><br><span class="line"><span class="keyword">private</span> String cust_phone;</span><br><span class="line"><span class="keyword">private</span> String cust_mobile;</span><br><span class="line"><span class="comment">// 通过ORM方式表示：一个客户对应多个联系人。</span></span><br><span class="line"><span class="comment">// 放置的多的一方的集合。Hibernate默认使用的是Set集合。</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;LinkMan&gt; linkMans = <span class="keyword">new</span> HashSet&lt;LinkMan&gt;();</span><br><span class="line"><span class="comment">//省略getter,setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户表和客户类映射文件 Customer.hbm.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC </span></span><br><span class="line"><span class="meta">    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"com.example.hibernate.domain.Customer"</span> <span class="attr">table</span>=<span class="string">"cst_customer"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 建立OID与主键映射 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"cust_id"</span> <span class="attr">column</span>=<span class="string">"cust_id"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 建立普通属性与数据库表字段映射 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_name"</span> <span class="attr">column</span>=<span class="string">"cust_name"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_source"</span> <span class="attr">column</span>=<span class="string">"cust_source"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_industry"</span> <span class="attr">column</span>=<span class="string">"cust_industry"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_level"</span> <span class="attr">column</span>=<span class="string">"cust_level"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_phone"</span> <span class="attr">column</span>=<span class="string">"cust_phone"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_mobile"</span> <span class="attr">column</span>=<span class="string">"cust_mobile"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置一对多的映射：放置的多的一方的集合 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">set标签 ：</span></span><br><span class="line"><span class="comment">* name：多的一方的对象集合的属性名称。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"linkMans"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> key标签</span></span><br><span class="line"><span class="comment">* column：多的一方的外键的名称。</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">"lkm_cust_id"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">one-to-many标签</span></span><br><span class="line"><span class="comment">* class:多的一方的类的全路径</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">"com.example.hibernate.domain.LinkMan"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>LinkMan实体类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkMan</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Long lkm_id;</span><br><span class="line"><span class="keyword">private</span> String lkm_name;</span><br><span class="line"><span class="keyword">private</span> String lkm_gender;</span><br><span class="line"><span class="keyword">private</span> String lkm_phone;</span><br><span class="line"><span class="keyword">private</span> String lkm_mobile;</span><br><span class="line"><span class="keyword">private</span> String lkm_email;</span><br><span class="line"><span class="keyword">private</span> String lkm_qq;</span><br><span class="line"><span class="keyword">private</span> String lkm_position;</span><br><span class="line"><span class="keyword">private</span> String lkm_memo;</span><br><span class="line"><span class="comment">// 通过ORM方式表示：一个联系人只能属于某一个客户。</span></span><br><span class="line"><span class="comment">// 放置的是一的一方的对象。</span></span><br><span class="line"><span class="keyword">private</span> Customer customer;</span><br><span class="line"><span class="comment">// 省略getter,setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>联系人表</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`cst_linkman`</span> (</span><br><span class="line">  <span class="string">`lkm_id`</span> <span class="built_in">bigint</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'联系人编号(主键)'</span>,</span><br><span class="line">  <span class="string">`lkm_name`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'联系人姓名'</span>,</span><br><span class="line">  <span class="string">`lkm_cust_id`</span> <span class="built_in">bigint</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'客户id'</span>,</span><br><span class="line">  <span class="string">`lkm_gender`</span> <span class="built_in">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'联系人性别'</span>,</span><br><span class="line">  <span class="string">`lkm_phone`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'联系人办公电话'</span>,</span><br><span class="line">  <span class="string">`lkm_mobile`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'联系人手机'</span>,</span><br><span class="line">  <span class="string">`lkm_email`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'联系人邮箱'</span>,</span><br><span class="line">  <span class="string">`lkm_qq`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'联系人qq'</span>,</span><br><span class="line">  <span class="string">`lkm_position`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'联系人职位'</span>,</span><br><span class="line">  <span class="string">`lkm_memo`</span> <span class="built_in">varchar</span>(<span class="number">512</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'联系人备注'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`lkm_id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`FK_cst_linkman_lkm_cust_id`</span> (<span class="string">`lkm_cust_id`</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`FK_cst_linkman_lkm_cust_id`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`lkm_cust_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`cst_customer`</span> (<span class="string">`cust_id`</span>) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> <span class="keyword">ACTION</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">NO</span> <span class="keyword">ACTION</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure></li><li><p>联系人表和联系人实体类映射文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC </span></span><br><span class="line"><span class="meta">    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"com.example.hibernate.domain.LinkMan"</span> <span class="attr">table</span>=<span class="string">"cst_linkman"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 建立OID与主键映射 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"lkm_id"</span> <span class="attr">column</span>=<span class="string">"lkm_id"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 建立普通属性与表字段映射 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lkm_name"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lkm_gender"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lkm_phone"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lkm_mobile"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lkm_email"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lkm_qq"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lkm_position"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lkm_memo"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置多对一的关系：放置的是一的一方的对象 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">many-to-one标签</span></span><br><span class="line"><span class="comment">* name:一的一方的对象的属性名称。</span></span><br><span class="line"><span class="comment">* class:一的一方的类的全路径。</span></span><br><span class="line"><span class="comment">* column:在多的一方的表的外键的名称。</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">"customer"</span> <span class="attr">class</span>=<span class="string">"com.example.hibernate.domain.Customer"</span> <span class="attr">column</span>=<span class="string">"lkm_cust_id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Session session = HibernateUtil.openSession();</span><br><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line">tx.begin();</span><br><span class="line"></span><br><span class="line">Customer customer1 = <span class="keyword">new</span> Customer(); <span class="comment">// 新建一个客户对象</span></span><br><span class="line">customer1.setCust_name(<span class="string">"客户1"</span>);</span><br><span class="line"></span><br><span class="line">LinkMan linkman1_1 = <span class="keyword">new</span> LinkMan();<span class="comment">// 新建一个联系人</span></span><br><span class="line">linkman1_1.setLkm_name(<span class="string">"联系人1，属于客户1"</span>);</span><br><span class="line">linkman1_1.setCustomer(customer1);</span><br><span class="line"></span><br><span class="line">LinkMan linkMan1_2 = <span class="keyword">new</span> LinkMan();<span class="comment">// 新建一个联系人</span></span><br><span class="line">linkMan1_2.setLkm_name(<span class="string">"联系人2，属于客户1"</span>);</span><br><span class="line">linkMan1_2.setCustomer(customer1);</span><br><span class="line"></span><br><span class="line">customer1.getLinkMans().add(linkman1_1);</span><br><span class="line">customer1.getLinkMans().add(linkMan1_2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联系人和客户对象都需要保存</span></span><br><span class="line">session.save(customer1);</span><br><span class="line">session.save(linkman1_1);</span><br><span class="line">session.save(linkMan1_2);</span><br><span class="line"></span><br><span class="line">tx.commit();</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="一对多级联操作"><a href="#一对多级联操作" class="headerlink" title="一对多级联操作"></a>一对多级联操作</h2><ul><li><h3 id="什么叫级联："><a href="#什么叫级联：" class="headerlink" title="什么叫级联："></a>什么叫级联：</h3><p>​    级联指的是，操作一个对象的时候，是否会同时操作其关联的对象。 </p></li><li><h3 id="级联是有方向性"><a href="#级联是有方向性" class="headerlink" title="级联是有方向性"></a>级联是有方向性</h3><ul><li>操作一的一方的时候，是否操作到多的一方</li><li>操作多的一方的时候，是否操作到一的一方</li></ul></li><li><h3 id="级联保存或者更新"><a href="#级联保存或者更新" class="headerlink" title="级联保存或者更新"></a>级联保存或者更新</h3><blockquote><p> <strong>保存客户级联联系人</strong>,需要在Customer.hbm.xml进行配置</p></blockquote><ul><li><p>配置映射文件Customer.hbm.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--cascade = "save-update"--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"linkMans"</span> <span class="attr">cascade</span>=<span class="string">"save-update"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">"lkm_cust_id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">"com.example.hibernate.domain.LinkMan"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Session session = HibernateUtil.openSession();</span><br><span class="line">    Transaction tx = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">    Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">    customer.setCust_name(<span class="string">"阿里巴巴"</span>);</span><br><span class="line"></span><br><span class="line">    LinkMan linkman1 = <span class="keyword">new</span> LinkMan();</span><br><span class="line">    linkman1.setLkm_name(<span class="string">"阿里巴巴技术总监"</span>);</span><br><span class="line"></span><br><span class="line">    LinkMan linkman2 = <span class="keyword">new</span> LinkMan();</span><br><span class="line">    linkman2.setLkm_name(<span class="string">"阿里巴巴开发组长"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存一边</span></span><br><span class="line">    customer.getLinkMans().add(linkman1);</span><br><span class="line">    customer.getLinkMans().add(linkman2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存一边</span></span><br><span class="line">    session.save(customer);</span><br><span class="line"></span><br><span class="line">    tx.commit();</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>保存联系人级联客户</strong></p></blockquote><ul><li><p>与上述差不多的操作</p></li><li><p>修改LinkMan.hbm.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">"customer"</span> <span class="attr">cascade</span>=<span class="string">"save-update"</span> <span class="attr">class</span>=<span class="string">"com.example.hibernate.domain.Customer"</span> <span class="attr">column</span>=<span class="string">"lkm_cust_id"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><h3 id="级联删除"><a href="#级联删除" class="headerlink" title="级联删除"></a>级联删除</h3><ul><li><p>级联删除：删除一边的时候，同时将另一方的数据也一并删除。</p></li><li><p>下面以一个具体的例子来说明：</p><blockquote><p>1、删除客户，级联删除联系人 </p></blockquote><ul><li><p>第一步，修改映射文件Customer.hbm.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"linkMans"</span> <span class="attr">cascade</span>=<span class="string">"delete"</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>第二步，编写测试代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Session session = HibernateUtil.openSession();</span><br><span class="line">    Transaction tx = session.beginTransaction();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * (1)级联删除</span></span><br><span class="line"><span class="comment"> * &lt;set name="linkMans" cascade="delete"&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    Customer customer1 = session.get(Customer.class, <span class="number">1L</span>);</span><br><span class="line">    session.delete(customer1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * (2)如果没有设置cascade="delete"</span></span><br><span class="line"><span class="comment"> * 运行下面的结果为：只删除了一的一方，多的一方不会被删除</span></span><br><span class="line"><span class="comment"> * 但是多的一方的外键会被设置为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    Customer customer2 = session.get(Customer.class, <span class="number">2L</span>);</span><br><span class="line">    session.delete(customer2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  (3)如果customer不是持久态度</span></span><br><span class="line"><span class="comment"> *  这种方式不会删除多的一方</span></span><br><span class="line"><span class="comment"> *  但是会把多的一方的外键设置为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    Customer customer3 = <span class="keyword">new</span> Customer();</span><br><span class="line">    customer3.setCust_id(<span class="number">3L</span>);</span><br><span class="line">    session.delete(customer3);</span><br><span class="line"></span><br><span class="line">    tx.commit();</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><ol start="2"><li>删除联系人，级联删除客户</li></ol></blockquote><ul><li><p>在一对多中一般不会出现这种情况：没有说删除多的一方，然后把一的一方删除的，因此下面只是测试使用</p><ul><li><p>第一步,修改映射文件LinkMan.hbm.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">"customer"</span> <span class="attr">cascade</span>=<span class="string">"delete"</span> <span class="attr">class</span>=<span class="string">"com.example.hibernate.domain.Customer"</span> <span class="attr">column</span>=<span class="string">"lkm_cust_id"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>第二步,编写测试代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Session session = HibernateUtil.openSession();</span><br><span class="line">    Transaction tx = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除联系人，级联删除客户</span></span><br><span class="line"><span class="comment"> * 在多的一方设置cascade="delete"</span></span><br><span class="line"><span class="comment"> * &lt;many-to-one name="customer" cascade="delete" class="com.example.hibernate.domain.Customer" column="lkm_cust_id"/&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 运行结果：</span></span><br><span class="line"><span class="comment"> * 联系人和联系人关联的客户均被删除</span></span><br><span class="line"><span class="comment"> * 和客户有关联的其他联系人的外键被设置为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    LinkMan linkMan = session.get(LinkMan.class, <span class="number">1L</span>);</span><br><span class="line">    session.delete(linkMan);</span><br><span class="line"></span><br><span class="line">    tx.commit();</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li><p><strong>cascade</strong> 和 <strong>inverse</strong></p><ul><li>cascade:级联<ul><li>save</li><li>update</li><li>save-update</li><li>delete</li></ul></li><li>inverse : 外键维护权<ul><li>true 放弃外键维护权</li><li>false 拥有外键维护权，默认值</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; title=&quot;是什么&quot;&gt;&lt;/a&gt;是什么&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Hibernate是一种ORM(Object Relational Mapping ）框架&lt;/li&gt;
&lt;li&gt;它对JDBC进行了非常轻量级的对象封装 &lt;/li&gt;
&lt;li&gt;hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库 &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://chsobin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://chsobin.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
