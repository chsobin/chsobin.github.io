<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>chsobin&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/0c2c72616bf80099b623b68335f8b810</icon>
  <subtitle>coding</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chsobin.github.io/"/>
  <updated>2019-04-27T05:14:18.881Z</updated>
  <id>https://chsobin.github.io/</id>
  
  <author>
    <name>陈松彬</name>
    <email>1748681439@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>maven使用</title>
    <link href="https://chsobin.github.io/2019/04/27/maven%E4%BD%BF%E7%94%A8/"/>
    <id>https://chsobin.github.io/2019/04/27/maven使用/</id>
    <published>2019-04-27T05:12:56.000Z</published>
    <updated>2019-04-27T05:14:18.881Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol><li><p>下载安装包</p></li><li><p>配置环境变量MAVEN_HOME</p></li><li>修改系统环境变量PATH，加入%MAVEN_HOME%/bin;</li></ol><p><em>注意：由于maven是使用Java开发的，因此其运行需要jre，因此必须安装jdk，然后配置环境变量JAVA_HOME</em></p><ol start="4"><li>测试：在cmd中输入mvn -v查看maven版本</li></ol><h1 id="Maven工程目录"><a href="#Maven工程目录" class="headerlink" title="Maven工程目录"></a>Maven工程目录</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="maven工程目录.png" alt="maven工程目录" title>                </div>                <div class="image-caption">maven工程目录</div>            </figure><ul><li>src/main/java  项目源代码</li><li>src/main/resources 项目资源文件，比如Spring配置文件</li><li>src/main/webapp   web项目必备</li></ul><h1 id="maven命令"><a href="#maven命令" class="headerlink" title="maven命令"></a>maven命令</h1><ul><li>mvn compile 编译src/main中的源文件，输出到target目录下</li><li>mvn clean 清除target目录</li><li>mvn test 编译src/main中的源文件，编译src/test中的测试类并运行单元测试</li><li>mvn pakage 将项目打包</li><li>mvn install 将项目打包并发布到本地仓库</li></ul><h1 id="修改JDK版本"><a href="#修改JDK版本" class="headerlink" title="修改JDK版本"></a>修改JDK版本</h1><p>新建maven项目后默认是jre1.5</p><p>解决办法：</p><ol><li><p>添加插件，修改pom.xml</p><ul><li>步骤1</li></ul><p><img src="添加插件.png" alt="添加插件"></p><ul><li>步骤2</li></ul><p><img src="查找插件.png" alt="查找插件"></p><ul><li>步骤三，在pom.xml中添加jdk版本信息</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 源码版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 编译目标版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定编码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置完之后可能工程还是jre1.5，这时只需要maven update一下即可</p></li></ol><h1 id="依赖的作用范围"><a href="#依赖的作用范围" class="headerlink" title="依赖的作用范围"></a>依赖的作用范围</h1><p>通过<scope></scope>标签配置</p><p>eg:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>取值：</p><ul><li><p>compile  依赖会用在编译，测试，运行</p></li><li><p>provided 依赖只有在当JDK或者一个容器已经提供该依赖时使用。provided依赖在编译和测试时需要，在运行时不需要，比如servlet api ，tomcat容器已经提供该jar包</p></li><li><p>runtime 依赖在运行和测试系统时候需要，但在编译的时候不需要。比如：jdbc的驱动包</p></li><li><p>test 依赖在编译和运行的时候都不需要，只有在测试编译和测试运行阶段可用，比如junit</p></li></ul><h1 id="使用Maven-tomcat-插件运行项目"><a href="#使用Maven-tomcat-插件运行项目" class="headerlink" title="使用Maven tomcat 插件运行项目"></a>使用Maven tomcat 插件运行项目</h1><blockquote><p><strong>配置插件</strong></p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">path</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uriEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">uriEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>右键点击项目</strong></p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="maven-tomcat插件.png" alt="maven-tomcat插件" title>                </div>                <div class="image-caption">maven-tomcat插件</div>            </figure><blockquote><p><strong>运行命令</strong></p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="运行命令.png" alt="运行命令" title>                </div>                <div class="image-caption">运行命令</div>            </figure><p>参考：<a href="http://my.oschina.net/lilw/blog/168667" target="_blank" rel="noopener">http://my.oschina.net/lilw/blog/168667</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载安装包&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置环境变量MAVEN_HOME&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;修改系统环境变
      
    
    </summary>
    
      <category term="工具" scheme="https://chsobin.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="maven" scheme="https://chsobin.github.io/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC学习笔记</title>
    <link href="https://chsobin.github.io/2019/04/23/SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://chsobin.github.io/2019/04/23/SpringMVC学习笔记/</id>
    <published>2019-04-23T12:18:01.000Z</published>
    <updated>2019-04-23T12:22:08.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><ol><li><p>创建项目</p></li><li><p>导入jar包</p></li><li><p>编写控制类TestController</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"hello springmvc...."</span>);</span><br><span class="line"><span class="comment">//创建ModelAndView对象</span></span><br><span class="line">ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line"><span class="comment">//设置模型数据</span></span><br><span class="line">mav.addObject(<span class="string">"msg"</span>, <span class="string">"hello springmvc..."</span>);</span><br><span class="line"><span class="comment">//设置视图名字</span></span><br><span class="line">mav.setViewName(<span class="string">"/WEB-INF/jsp/hello.jsp"</span>);</span><br><span class="line"><span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建hello.jsp页面</p></li><li><p>创建配置SpringMVC核心配置文件springmvc.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 扫描步骤3中被注解@Controller修饰的类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.example.springmvc.controller"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在web.xml中配置前端控制器</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置前端控制器 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加载springmvc核心配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 配置拦截路径 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.action<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p></li></ol><h1 id="SpringMVC核心类"><a href="#SpringMVC核心类" class="headerlink" title="SpringMVC核心类"></a>SpringMVC核心类</h1><h2 id="SpringMVC工作流程"><a href="#SpringMVC工作流程" class="headerlink" title="SpringMVC工作流程"></a>SpringMVC工作流程</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="SpringMVC架构.png" alt="SpringMVC架构" title>                </div>                <div class="image-caption">SpringMVC架构</div>            </figure><p>其工作流程为:<br>1、用户发送请求至前端控制器DispatcherServlet<br>2、DispatcherServlet收到请求调用HandlerMapping处理器映射器。<br>3、处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(二者组成HandlerExecutionChain),并将其一并返回给DispatcherServlet。<br>4、DispatcherServlet通过HandlerAdapter处理器适配器调用处理器<br>5、执行处理器(Controller，也叫后端控制器)。<br>6、Controller执行完成返回ModelAndView<br>7、HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet<br>8、DispatcherServlet将ModelAndView传给ViewReslover视图解析器<br>9、ViewReslover解析后返回具体View<br>10、DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。<br>11、DispatcherServlet对用户进行响应</p><p>【参考】<a href="https://blog.csdn.net/James_shu/article/details/54616120" target="_blank" rel="noopener">https://blog.csdn.net/James_shu/article/details/54616120</a></p><h2 id="SpringMVC中的重要组件"><a href="#SpringMVC中的重要组件" class="headerlink" title="SpringMVC中的重要组件"></a>SpringMVC中的重要组件</h2><h3 id="一、中央控制器-DispatcherServlet"><a href="#一、中央控制器-DispatcherServlet" class="headerlink" title="一、中央控制器(DispatcherServlet)"></a>一、中央控制器(DispatcherServlet)</h3><ul><li>中央控制器</li><li>作用：拦截请求</li><li>在web.xml中配置</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置前端控制器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置springmvc核心配置文件位置 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 看源码发现public class DispatcherServlet extends FrameworkServlet</span></span><br><span class="line"><span class="comment">        然后FrameworkServlet 中拥有属性 private String contextConfigLocation; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.action<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="二、处理器映射器-HandlerMapping-和处理器适配器-HandlerAdapter"><a href="#二、处理器映射器-HandlerMapping-和处理器适配器-HandlerAdapter" class="headerlink" title="二、处理器映射器(HandlerMapping )和处理器适配器(HandlerAdapter)"></a>二、处理器映射器(HandlerMapping )和处理器适配器(HandlerAdapter)</h3><p><strong>接口HandlerMapping</strong> </p><ul><li>处理器映射器</li><li>绑定url请求由哪个方法来处理，也就是说根据url可以找到处理这个请求的方法</li></ul><p><strong>接口HandlerAdapter</strong> </p><ul><li>处理器适配器</li><li>负责调用url请求所对应的方法</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 处理器映射器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 处理器适配器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置注解驱动，相当于同时使用最新处理器映射器和处理器适配器，对json数据x响应提供支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="三、视图解析器-ViewResolver"><a href="#三、视图解析器-ViewResolver" class="headerlink" title="三、视图解析器(ViewResolver)"></a>三、视图解析器(ViewResolver)</h3><p><strong>接口ViewResolver</strong></p><ul><li>视图解析器<ul><li>prefix配置路径前缀</li><li>suffix配置路径后缀</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 视图解析器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="获取前端传来的参数"><a href="#获取前端传来的参数" class="headerlink" title="获取前端传来的参数"></a>获取前端传来的参数</h1><h2 id="传统方式"><a href="#传统方式" class="headerlink" title="传统方式"></a>传统方式</h2><p>默认参数，可以当作方法参数，传递到被@RequestMapping修饰的方法中 </p><ul><li>HttpServletRequest</li><li>HttpServletResponse</li><li>HttpSession</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * 使用HttpServletRequest传递参数</span></span><br><span class="line"><span class="comment">    * 使用HttpServletResponse响应请求</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"test"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">itemEdit</span><span class="params">(HttpServletRequest request, HttpServletResponse response, HttpSession session)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String name = request.getParameter(<span class="string">"name"</span>);</span><br><span class="line">    response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">    response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">    response.getWriter().print(<span class="string">"前端传过来的参数name="</span>+name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringMVC提供的支持"><a href="#SpringMVC提供的支持" class="headerlink" title="SpringMVC提供的支持"></a>SpringMVC提供的支持</h2><h3 id="1、简单参数的传递："><a href="#1、简单参数的传递：" class="headerlink" title="1、简单参数的传递："></a>1、简单参数的传递：</h3><p>eg:比如请求中有参数  <a href="http://localhost:8080/demoe?id=1" target="_blank" rel="noopener">http://localhost:8080/demoe?id=1</a></p><p>（1）在方法中设置Integer id</p><p>（2）如果参数名不同，需要使用@RequestParam注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">itemEdit</span><span class="params">(Model model, @RequestParam(name=<span class="string">"id"</span>,required=<span class="keyword">true</span>,defaultValue=<span class="string">"1"</span>)</span>Integer num) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、使用实体类来封装请求传过来的参数"><a href="#2、使用实体类来封装请求传过来的参数" class="headerlink" title="2、使用实体类来封装请求传过来的参数"></a>2、使用实体类来封装请求传过来的参数</h3><p>其中前端传过来的数据的name要和实体类的属性名一致</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double price;</span><br><span class="line">    <span class="keyword">private</span> String detail;</span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line">    <span class="keyword">private</span> Date createtime;</span><br><span class="line"><span class="comment">// getter()</span></span><br><span class="line"><span class="comment">// setter()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">updateItem</span><span class="params">(Model model, Item item)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、普通数据类型数组参数"><a href="#3、普通数据类型数组参数" class="headerlink" title="3、普通数据类型数组参数"></a>3、普通数据类型数组参数</h3><p>注意 参数名（如例子中的 names） 需要与前端一致</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"getArray"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getArray</span><span class="params">(String[] names, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">    response.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">    PrintWriter writer = response.getWriter();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;names.length;++i) &#123;</span><br><span class="line">        writer.println(<span class="string">"第"</span> + i + <span class="string">"个参数 = "</span> + names[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    writer.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、List参数"><a href="#4、List参数" class="headerlink" title="4、List参数"></a>4、List参数</h3><p>如果前端</p><h3 id="5、日期参数"><a href="#5、日期参数" class="headerlink" title="5、日期参数"></a>5、日期参数</h3><p>（1）创建转换器，需要实现Converter</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.convert.converter.Converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateConvert</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        Date date = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            date = simpleDateFormat.parse(str);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）配置Converter</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置注解驱动，相当于同时使用最新处理器映射器和处理器适配器，对json数据x响应提供支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">"myConversion"</span>/&gt;</span> <span class="comment">&lt;!-- 注意 需要在此处配置conversion-service--&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 配置自定义转化器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myConversion"</span> <span class="attr">class</span>=<span class="string">"org.springframework.format.support.FormattingConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 自定义转化器 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"utils.DateConvert"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="响应请求"><a href="#响应请求" class="headerlink" title="响应请求"></a>响应请求</h1><h2 id="1、直接返回ModelAndView"><a href="#1、直接返回ModelAndView" class="headerlink" title="1、直接返回ModelAndView"></a>1、直接返回ModelAndView</h2><ul><li>设置 数据,即addObject()方法</li><li>设置 视图的路径，即setViewName()方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示所有商品</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value= &#123;<span class="string">"itemList"</span>,<span class="string">"itemList2"</span>&#125;,method= &#123;RequestMethod.POST, RequestMethod.GET&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">itemList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Item&gt; itemList = itemService.getItemList();</span><br><span class="line">        ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        modelAndView.addObject(<span class="string">"itemList"</span>, itemList);</span><br><span class="line">        modelAndView.setViewName(<span class="string">"/WEB-INF/itemList.jsp"</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2、直接返回String"><a href="#2、直接返回String" class="headerlink" title="2、直接返回String"></a>2、直接返回String</h2><p>改造上述方法，该方式就是简化了直接返回ModelAndView</p><ul><li>将返回值改为String</li><li>不需要使用ModelAndView.setViewName()方法，直接return视图的路径</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示所有商品</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value= &#123;<span class="string">"itemList"</span>,<span class="string">"itemList2"</span>&#125;,method= &#123;RequestMethod.POST, RequestMethod.GET&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">itemList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Item&gt; itemList = itemService.getItemList();</span><br><span class="line">        ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        modelAndView.addObject(<span class="string">"itemList"</span>, itemList);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/WEB-INF/itemList.jsp"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3、请求转发"><a href="#3、请求转发" class="headerlink" title="3、请求转发"></a>3、请求转发</h2><p>return “forward:要转发的路径”</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"updateItem"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">updateItem</span><span class="params">(Model model, Item item)</span> </span>&#123;</span><br><span class="line"><span class="comment">//model.addAttribute();</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"forward:itemList.action"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、请求重定向"><a href="#4、请求重定向" class="headerlink" title="4、请求重定向"></a>4、请求重定向</h2><p>return “redirect:重定向的路径”</p><p><em>注意：redirect会将request作用域的数据清除，但是会将参数加在url后面</em></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="redirect请求重定向参数问题.png" alt="redirect请求重定向参数问题" title>                </div>                <div class="image-caption">redirect请求重定向参数问题</div>            </figure><h1 id="SpringMVC中常用注解"><a href="#SpringMVC中常用注解" class="headerlink" title="SpringMVC中常用注解"></a>SpringMVC中常用注解</h1><h2 id="1、-Controller"><a href="#1、-Controller" class="headerlink" title="1、@Controller"></a>1、@Controller</h2><p>在SpringMVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。</p><p>在SpringMVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller ，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。</p><p>此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。</p><p>@Controller 用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。</p><p>@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。单单使用@Controller 标记在一个类上还不能真正意义上的说它就是SpringMVC 的一个控制器类，因为这个时候Spring 还不认识它。那么要如何做Spring 才能认识它呢？这个时候就需要我们把这个控制器类交给Spring 来管理。有两种方式：</p><p>　　（1）在SpringMVC 的配置文件中定义MyController 的bean 对象。</p><p>　　（2）在SpringMVC 的配置文件中告诉Spring 该到哪里去找标记为@Controller 的Controller 控制器。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--方式一--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"类的全路径"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方式二--&gt;</span></span><br><span class="line"><span class="tag">&lt; <span class="attr">context:component-scan</span> <span class="attr">base-package</span> = <span class="string">"类所在包名"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2、-RequestMapping"><a href="#2、-RequestMapping" class="headerlink" title="2、@RequestMapping"></a>2、@RequestMapping</h2><ul><li><p>在类上</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"example"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Controller</span></span>&#123;</span><br><span class="line">    <span class="meta">@RequstMapping</span>(<span class="string">"save"</span>) <span class="comment">// 访问该方法的路径为 example/save</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>value</strong>属性</p><p>指定多个匹配路径</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value= &#123;<span class="string">"save"</span>,<span class="string">"save1"</span>&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>method</strong>属性</p><p>限制提交方式，<em>不指定时，默认接收全部提交方式</em></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(method=&#123;RequestMethod.GET, RequestMethod.POST&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>consumes</strong></p><p>指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;</p></li><li><p><strong>produces</strong></p><p>指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</p></li><li><p><strong>params</strong></p><p>指定request中必须包含某些参数值是，才让该方法处理。</p></li><li><p><strong>headers</strong></p><p>指定request中必须包含某些指定的header值，才能让该方法处理请求。</p></li></ul><h2 id="3、-PathVariable"><a href="#3、-PathVariable" class="headerlink" title="3、@PathVariable"></a>3、@PathVariable</h2><p>用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数。如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;  </span><br><span class="line">     <span class="meta">@RequestMapping</span>(value=<span class="string">"/user/&#123;userId&#125;/roles/&#123;roleId&#125;"</span>,method = RequestMethod.GET)  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getLogin</span><span class="params">(@PathVariable(<span class="string">"userId"</span>)</span> String userId,  </span></span><br><span class="line"><span class="function">         @<span class="title">PathVariable</span><span class="params">(<span class="string">"roleId"</span>)</span> String roleId)</span>&#123;  </span><br><span class="line">         System.out.println(<span class="string">"User Id : "</span> + userId);  </span><br><span class="line">         System.out.println(<span class="string">"Role Id : "</span> + roleId);  </span><br><span class="line">         <span class="keyword">return</span> <span class="string">"hello"</span>;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="meta">@RequestMapping</span>(value=<span class="string">"/product/&#123;productId&#125;"</span>,method = RequestMethod.GET)  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getProduct</span><span class="params">(@PathVariable(<span class="string">"productId"</span>)</span> String productId)</span>&#123;  </span><br><span class="line">           System.out.println(<span class="string">"Product Id : "</span> + productId);  </span><br><span class="line">           <span class="keyword">return</span> <span class="string">"hello"</span>;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="meta">@RequestMapping</span>(value=<span class="string">"/javabeat/&#123;regexp1:[a-z-]+&#125;"</span>,  </span><br><span class="line">           method = RequestMethod.GET)  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getRegExp</span><span class="params">(@PathVariable(<span class="string">"regexp1"</span>)</span> String regexp1)</span>&#123;  </span><br><span class="line">           System.out.println(<span class="string">"URI Part 1 : "</span> + regexp1);  </span><br><span class="line">           <span class="keyword">return</span> <span class="string">"hello"</span>;  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细可以参考<a href="https://blog.csdn.net/qian_ch/article/details/73826663" target="_blank" rel="noopener">https://blog.csdn.net/qian_ch/article/details/73826663</a></p><h1 id="SpringMVC异常处理"><a href="#SpringMVC异常处理" class="headerlink" title="SpringMVC异常处理"></a>SpringMVC异常处理</h1><ol><li><p>自定义异常处理器，实现接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptionResolver</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">            Exception ex)</span> </span>&#123;</span><br><span class="line">        ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        modelAndView.addObject(<span class="string">"msg"</span>, <span class="string">"系统发生故障，请联系管理员"</span>);</span><br><span class="line">        modelAndView.setViewName(<span class="string">"msg"</span>); <span class="comment">//对应 msg.jsp页面</span></span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在配置文件中配置异常处理器</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置异常处理类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"MyExceptionResolver"</span>/&gt;</span> <span class="comment">&lt;!--自定义类的全路径--&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><ol><li><p><strong>配置tomcat虚拟目录，也就是设置图片库的路径</strong></p><ul><li><p>方式一</p><p><img src="配置虚拟目录.png" alt="配置虚拟目录"></p></li><li><p>方式二：在tomcat配置文件server的Host标签中添加context标签</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">docBase</span>=<span class="string">"D:\pictures"</span> <span class="attr">path</span>=<span class="string">"/pic"</span> <span class="attr">reloadable</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>导入上传功能需要的jar包</strong></p><ul><li>commons-fileupload-1.2.2.jar</li><li>commons-io-2.0.1.jar</li></ul></li><li><p><strong>配置多媒体解析器</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置多媒体解析器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultEncoding"</span> <span class="attr">value</span>=<span class="string">"utf-8"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--限制上传大小为100KB--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxUploadSize"</span> <span class="attr">value</span>=<span class="string">"102400"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>注意id不能改，必须为</em>multipartResolver</p></li><li><p><strong>前端页面关于文件上传相关配置</strong></p><p><em>注意：</em></p><p><em>(1)method=”POST”</em></p><p><em>(2)enctype=”multipart/form-data”</em></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"file"</span>&gt;</span>文件<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"uploadfile"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>上传<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span>        </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>编写文件上传处理代码</strong></p><p><em>注意：方法需要声明参数MultipartFile uploadfile表示文件，其中uploadfile要与前端的name值相对应</em></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"uploadFile"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">uploadFile</span><span class="params">(Model model, MultipartFile uploadfile)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 文件新名字，这里使用随机数</span></span><br><span class="line">    String name = UUID.randomUUID().toString();</span><br><span class="line">    <span class="comment">// 文件原名字</span></span><br><span class="line">    String oldName = uploadfile.getOriginalFilename();</span><br><span class="line">    <span class="comment">// 后缀名</span></span><br><span class="line">    String exeName = oldName.substring(oldName.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line"></span><br><span class="line">    File pic = <span class="keyword">new</span> File(<span class="string">"H:\\pic\\"</span> + name + exeName);</span><br><span class="line">    <span class="comment">// 保存文件到本地磁盘</span></span><br><span class="line">    uploadfile.transferTo(pic); </span><br><span class="line"></span><br><span class="line">    model.addAttribute(<span class="string">"msg"</span>, <span class="string">"保存文件成功"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"uploadFile"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="JSON-数据"><a href="#JSON-数据" class="headerlink" title="JSON 数据"></a>JSON 数据</h1><ul><li><p>导入jar包</p><ul><li>jackson-annotations-2.4.0.ja</li><li>jackson-core-2.4.2.jar</li><li>jackson-databind-2.4.2.jar</li></ul></li><li><p>发送json数据</p><p>使用@ResponseBody</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"getJson"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span>   <span class="comment">// 使用该注解之后，直接返回实体类，不用手动生成json格式数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Item <span class="title">getJson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个实体类</span></span><br><span class="line">    Item item = <span class="keyword">new</span> Item();</span><br><span class="line">    item.setId(<span class="number">111</span>);</span><br><span class="line">    item.setName(<span class="string">"手机"</span>);</span><br><span class="line">    item.setPrice(<span class="number">1000</span>d);</span><br><span class="line">    <span class="keyword">return</span> item; <span class="comment">// 直接返回实体对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"id"</span>: <span class="number">111</span>,</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"手机"</span>,</span><br><span class="line"><span class="attr">"price"</span>: <span class="number">1000</span>,</span><br><span class="line"><span class="attr">"detail"</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">"pic"</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">"createtime"</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接收json数据</p><p>使用@RequestBody</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"getFromClient"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Item <span class="title">getFromClient</span><span class="params">(@RequestBody Item item)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> item; <span class="comment">// 直接返回前端发来的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><p>请求</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">POST /SpringMVCMybatis/getFromClient.action HTTP/<span class="number">1.1</span></span><br><span class="line">HOST: localhost:<span class="number">8080</span></span><br><span class="line">content-type: application/json</span><br><span class="line">cookie: JSESSIONID=<span class="number">97E417</span>BE428C05EDE13D011D8D77CFC6</span><br><span class="line">content-length: <span class="number">82</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="string">"id"</span>:<span class="number">111</span>,<span class="string">"name"</span>:<span class="string">"手机"</span>,<span class="string">"price"</span>:<span class="number">1000</span>,<span class="string">"detail"</span>:<span class="keyword">null</span>,<span class="string">"pic"</span>:<span class="keyword">null</span>,<span class="string">"createtime"</span>:<span class="keyword">null</span>&#125;</span><br></pre></td></tr></table></figure><p>返回结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"id"</span>:<span class="number">111</span>,<span class="string">"name"</span>:<span class="string">"手机"</span>,<span class="string">"price"</span>:<span class="number">1000.0</span>,<span class="string">"detail"</span>:<span class="keyword">null</span>,<span class="string">"pic"</span>:<span class="keyword">null</span>,<span class="string">"createtime"</span>:<span class="keyword">null</span>&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* RESTful风格演示</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//RESTful风格url上的参数通过&#123;&#125;点位符绑定</span></span><br><span class="line"><span class="comment">//点位符参数名与方法参数名不一致时，通过@PathVariable绑定</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/item/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRest</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer ids, Model model) </span>&#123;</span><br><span class="line">Item item = itemServices.getItemById(ids);</span><br><span class="line">model.addAttribute(<span class="string">"item"</span>, item);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"itemEdit"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><h4 id="1-自定义拦截器，实现接口org-springframework-web-servlet-HandlerInterceptor"><a href="#1-自定义拦截器，实现接口org-springframework-web-servlet-HandlerInterceptor" class="headerlink" title="1. 自定义拦截器，实现接口org.springframework.web.servlet.HandlerInterceptor"></a>1. 自定义拦截器，实现接口org.springframework.web.servlet.HandlerInterceptor</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在Controller方法执行后被执行</span></span><br><span class="line">    <span class="comment">//处理异常、记录日志</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object arg2, Exception arg3)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"afterCompletion....."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在Controller方法执行后，返回ModelAndView之前被执行</span></span><br><span class="line">    <span class="comment">//设置或者清理页面共用参数等等</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object arg2, ModelAndView arg3)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"postHandle......."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在Controller方法执行前被执行</span></span><br><span class="line">    <span class="comment">//登录拦截、权限认证等等</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object arg2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 返回true不拦截，返回false拦截</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-配置文件中配置拦截器"><a href="#2-配置文件中配置拦截器" class="headerlink" title="2.配置文件中配置拦截器"></a>2.配置文件中配置拦截器</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- /**拦截所有请求，包括二级以上目录，/*拦截所有请求，不包括二级以上目录 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/**"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 不拦截的请求 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;mvc:exclude-mapping path=""/&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 自定义拦截器全路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"interceptor.MyInterceptor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;入门&quot;&gt;&lt;a href=&quot;#入门&quot; class=&quot;headerlink&quot; title=&quot;入门&quot;&gt;&lt;/a&gt;入门&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建项目&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;导入jar包&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;编写控制类TestContro
      
    
    </summary>
    
      <category term="Java" scheme="https://chsobin.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://chsobin.github.io/tags/Java/"/>
    
      <category term="Spring" scheme="https://chsobin.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC乱码问题总结</title>
    <link href="https://chsobin.github.io/2019/04/23/SpringMVC%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>https://chsobin.github.io/2019/04/23/SpringMVC乱码问题总结/</id>
    <published>2019-04-23T11:02:30.000Z</published>
    <updated>2019-04-23T11:30:51.717Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC乱码问题总结"><a href="#SpringMVC乱码问题总结" class="headerlink" title="SpringMVC乱码问题总结"></a>SpringMVC乱码问题总结</h1><h3 id="POST请求乱码"><a href="#POST请求乱码" class="headerlink" title="POST请求乱码"></a>POST请求乱码</h3><p>解决：在web.xml中添加过滤器</p><p>解释：CharacterEncodingFilter有两个属性</p><ul><li><p>encoding</p></li><li><p>forceEncoding</p><blockquote><p>源码注释：</p><p>Default is “false”, i.e. do not modify the encoding if</p><p>javax.servlet.http.HttpServletRequest.getCharacterEncoding()</p><p>returns a non-null value. Switch this to “true” to enforce the specified</p><p>encoding in any case, applying it as default response encoding as well.</p><p>中文解释：默认值为false，表示当request.getCharacterEncoding()返回非空时，不修改request的字符集</p><p>当设置为true时，强制执行</p><p>request.setCharacterEncoding()和</p><p>response.setCharacterEncoding();     </p></blockquote></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 解决post乱码问题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="GET请求乱码"><a href="#GET请求乱码" class="headerlink" title="GET请求乱码"></a>GET请求乱码</h3><p><em>注意：get请求方式在tomcat7之前处理tomcat服务器都是用ISO-8859-1处理数据，之后的版本默认UTF-8</em></p><p><strong>方法一：</strong></p><p>修改tomcat的server.xml配置文件，添加URIEncoding=”utf-8”</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> <span class="attr">URIEncoding</span>=<span class="string">"utf-8"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>方法二：</strong></p><p>手动更改：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(request.getParameter(<span class="string">"username"</span>).getBytes(<span class="string">"ISO-8859-1"</span>),<span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure><h3 id="返回响应乱码"><a href="#返回响应乱码" class="headerlink" title="返回响应乱码"></a>返回响应乱码</h3><h4 id="情况一：使用-ResponseBody直接返回对象"><a href="#情况一：使用-ResponseBody直接返回对象" class="headerlink" title="情况一：使用@ResponseBody直接返回对象"></a>情况一：使用@ResponseBody直接返回对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"testResponseBodyEncoding"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Item <span class="title">testResponseBodyEncoding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Item item = <span class="keyword">new</span> Item();</span><br><span class="line">item.setId(<span class="number">333</span>);</span><br><span class="line">item.setCreatetime(<span class="keyword">new</span> Date());</span><br><span class="line">item.setDetail(<span class="string">"使用ResponseBody返回json数据会乱码吗"</span>);</span><br><span class="line">item.setName(<span class="string">"陈松彬"</span>);</span><br><span class="line">item.setPrice(<span class="number">1000</span>d);</span><br><span class="line"><span class="keyword">return</span> item; <span class="comment">// 直接返回对象，不需要我们手动转为json格式数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述案例测试不会产生乱码，这是由于使用的转换器默认编码是UTF-8</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="AbstractJackson2HttpMessageConverter默认编码.JPG" alt="AbstractJackson2HttpMessageConverter默认编码" title>                </div>                <div class="image-caption">AbstractJackson2HttpMessageConverter默认编码</div>            </figure><h4 id="情况二：使用-ResponseBody返回字符串"><a href="#情况二：使用-ResponseBody返回字符串" class="headerlink" title="情况二：使用@ResponseBody返回字符串"></a>情况二：使用@ResponseBody返回字符串</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"testResponseBodyEncoding"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testResponseBodyEncoding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Item item = <span class="keyword">new</span> Item();</span><br><span class="line">item.setId(<span class="number">333</span>);</span><br><span class="line">item.setCreatetime(<span class="keyword">new</span> Date());</span><br><span class="line">item.setDetail(<span class="string">"使用ResponseBody返回json数据会乱码吗"</span>);</span><br><span class="line">item.setName(<span class="string">"陈松彬"</span>);</span><br><span class="line">item.setPrice(<span class="number">1000</span>d);</span><br><span class="line"><span class="keyword">return</span> item.toString();<span class="comment">// 直接返回字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况会产生乱码，这是由于使用的转换器默认编码是ISO-8859-1</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="StringHttpMessageConverter默认编码.JPG" alt="StringHttpMessageConverter默认编码" title>                </div>                <div class="image-caption">StringHttpMessageConverter默认编码</div>            </figure><p><strong>解决办法：</strong></p><p>这里提供一个简单的解决办法：</p><p>在注解种设置produces的值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"testGet"</span>, produces = <span class="string">"application/json; charset=utf-8"</span>)</span><br></pre></td></tr></table></figure><p>其他解决办法<a href="https://www.cnblogs.com/striver-zhu/p/7158623.html" target="_blank" rel="noopener">https://www.cnblogs.com/striver-zhu/p/7158623.html</a></p><h4 id="情况三：直接使用HttpServletResponse返回数据"><a href="#情况三：直接使用HttpServletResponse返回数据" class="headerlink" title="情况三：直接使用HttpServletResponse返回数据"></a>情况三：直接使用HttpServletResponse返回数据</h4><p>这种情况需要手动设置</p><p>response.setContentType(“text/html;charset=UTF-8”);<br>response.setCharacterEncoding(“UTF-8”);</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"getArray"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getArray</span><span class="params">(String[] names, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">    response.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">    PrintWriter writer = response.getWriter();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;names.length;++i) &#123;</span><br><span class="line">        writer.println(<span class="string">"第"</span> + i + <span class="string">"个参数 = "</span> + names[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    writer.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringMVC乱码问题总结&quot;&gt;&lt;a href=&quot;#SpringMVC乱码问题总结&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC乱码问题总结&quot;&gt;&lt;/a&gt;SpringMVC乱码问题总结&lt;/h1&gt;&lt;h3 id=&quot;POST请求乱码&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="Java" scheme="https://chsobin.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://chsobin.github.io/tags/Java/"/>
    
      <category term="Spring" scheme="https://chsobin.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring学习笔记</title>
    <link href="https://chsobin.github.io/2019/04/15/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://chsobin.github.io/2019/04/15/Spring学习笔记/</id>
    <published>2019-04-15T15:20:43.000Z</published>
    <updated>2019-04-15T15:22:38.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring是什么："><a href="#Spring是什么：" class="headerlink" title="Spring是什么："></a>Spring是什么：</h1><p>如果单独讲概念的话，直接看百科就行。这里主要列出了Spring的两个核心概念：</p><ul><li>IoC 控制反转</li><li>AOP 面向切面编程</li></ul><h2 id="IoC控制反转"><a href="#IoC控制反转" class="headerlink" title="IoC控制反转"></a>IoC控制反转</h2><blockquote><p><strong>IoC(Inversion of Control) 控制反转</strong></p></blockquote><p>把创建对象的这个工作，由程序员转交给“容器”</p><p>当需要某个对象的时候，不是通过new硬编码实现，而是通过容器获取需要的对象</p><p>Ioc不仅仅是创建对象，而且还管理着对象的生命周期</p><blockquote><p><strong>DI(Dependency Injection) 依赖注入</strong></p></blockquote><p>Class A中用到了Class B的对象b，一般情况下，需要在A的代码中显式的new一个B的对象。</p><p>采用依赖注入技术之后，A的代码只需要定义一个私有的B对象，不需要直接new来获得这个对象，而是通过相关的容器控制程序来将B对象在外部new出来并注入到A类里的引用中。</p><p><em>什么是依赖：</em></p><p><em>一个类A的实现需要依赖于类B，也就是要用到类B提供的方法</em></p><p><em>因为大多数应用程序都是由两个或是更多的类通过彼此的合作来实现企业逻辑，这使得每个对象都需要获取与其合作的对象（也就是它所依赖的对象）的引用</em></p><p>为了更好理解DI，我们先来看看通过硬编码来使用依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Hardcoded dependency</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> MyDependency myDependency = <span class="keyword">new</span> MyDependency(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看依赖注入的方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Injected dependency</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> MyDependency myDependency;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">(MyDependency myDependency)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myDependency = myDependency;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以有多种方式实现把依赖注入，常见是通过构造器或者setter方法</p><blockquote><p><strong>IoC和DI</strong></p></blockquote><p>通过IoC容器来创建对象，并自动把相关的依赖对象注入进去，我们程序员只需要定义类之间的依赖即可，依赖注入这件事交给IoC容器即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span><span class="comment">// IoC容器会自动生成好myClass2对象</span></span><br><span class="line">    <span class="keyword">private</span> MyClass2 myClass2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        myClass2.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">// IoC容器会自动生成好对象,并将引用赋值给myclass3</span></span><br><span class="line">    <span class="keyword">private</span> MyClass3 myClass3;</span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">// IoC容器会自动生成好对象,并将引用赋值给myclass4</span></span><br><span class="line">    <span class="keyword">private</span> MyClass4 myClass4;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        myClass3.doSomething();</span><br><span class="line">        myClass4.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>个人理解：</p><p>一个应用程序一般都是多个类相互合作</p><p>（1）传统开发方式：如果类A需要用到类B提供的功能，那么需要在类A中创建类B(也就是new 对象)，如果发生需求变更，也就是现在有了C类，我们发现他能实现和B类一样的功能，但是性能更加出色，于是如果我们想要用C类的功能，那么就需要更改原系统的代码，把那些用到B类的地方，全部换掉。这样很麻烦</p><p>（2）现在有了Spring提供的IoC容器，相当于在类A和类B之间加了一个中间层（这里我们称为Container）,由我们的Container利用反射去生成我们需要的对象。现在A类需要B类，那么只需要从Container里面拿。那么如果要用类C替换类B呢，只需要更改Container的配置文件，把B类改为C类，那么容器利用反射，生成的就是C类的对象。这样就可以做到无需要更改源代码。</p></blockquote><p>参考：</p><p><a href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/1158025?fromtitle=%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5&amp;fromid=5177233" target="_blank" rel="noopener">https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/1158025?fromtitle=%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5&amp;fromid=5177233</a></p><p><a href="https://dzone.com/articles/ioc-vs-di" target="_blank" rel="noopener">https://dzone.com/articles/ioc-vs-di</a></p><h2 id="AOP面向切面编程"><a href="#AOP面向切面编程" class="headerlink" title="AOP面向切面编程"></a>AOP面向切面编程</h2><p>基本概念：</p><ul><li><p>面向对象编程的基本单位是类，而面向切面编程的基本单位是切面</p></li><li><p>[具体可以看看这篇博文章：Spring AOP就是这么简单]: <a href="https://juejin.im/post/5b06bf2df265da0de2574ee1" target="_blank" rel="noopener">https://juejin.im/post/5b06bf2df265da0de2574ee1</a>    “Spring AOP就是这么简单”</p></li></ul><p>底层实现：动态代理</p><ul><li>JDK动态代理，需要实现接口</li><li>Cglib动态代理，通过继承，产生子类</li></ul><blockquote><p>个人理解：</p><p>（1）比如我们在业务层有多个方法需要开启关闭事务，可以看到以下代码有很多重复代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service1</span><span class="params">()</span></span>&#123;</span><br><span class="line">&gt;  openTransaction(); <span class="comment">// 开启事务</span></span><br><span class="line">&gt;  <span class="comment">// 业务逻辑代码</span></span><br><span class="line">&gt;  closeTransaction();<span class="comment">// 关闭事务</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service2</span><span class="params">()</span></span>&#123;</span><br><span class="line">&gt;  openTransaction(); <span class="comment">// 开启事务</span></span><br><span class="line">&gt;  <span class="comment">// 业务逻辑代码</span></span><br><span class="line">&gt;  closeTransaction();<span class="comment">// 关闭事务</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service3</span><span class="params">()</span></span>&#123;</span><br><span class="line">&gt;  openTransaction(); <span class="comment">// 开启事务</span></span><br><span class="line">&gt;  <span class="comment">// 业务逻辑代码</span></span><br><span class="line">&gt;  closeTransaction();<span class="comment">// 关闭事务</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; .....</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>（2）采用面向切面编程，我们将进行横向切割， 把不是业务逻辑的代码抽取出来，形成一个模块，单独进行维护</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Aspect</span></span>&#123;</span><br><span class="line">&gt;  openTransaction()&#123;</span><br><span class="line">&gt;      </span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt;  closeTransaction()&#123;</span><br><span class="line">&gt;      </span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>（3）最后 通过动态代理的方式  将<strong>横切出来的逻辑代码</strong>，<strong>融合到业务逻辑</strong>中</p></blockquote><h1 id="使用XML管理Bean"><a href="#使用XML管理Bean" class="headerlink" title="使用XML管理Bean"></a>使用XML管理Bean</h1><h2 id="Bean配置方式"><a href="#Bean配置方式" class="headerlink" title="Bean配置方式"></a>Bean配置方式</h2><p>将bean交给Spring管理，那么Spring是怎么创建对象的呢？</p><p>三种方法：</p><ul><li>无参构造方法的方式</li><li>静态工厂实例化的方式:对象通过工厂类的静态方法获得目标对象</li><li>实例工厂实例化的方式:需要实例化工厂，调用工厂对象的方法获取目标对象</li></ul><h3 id="1-无参构造方法的方式（常用）"><a href="#1-无参构造方法的方式（常用）" class="headerlink" title="1.无参构造方法的方式（常用）"></a>1.无参构造方法的方式（常用）</h3><ol><li><p>编写类Bean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bean的构造函数"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在xml文件中配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过无参构造函数 获取Bean对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean1"</span> <span class="attr">class</span>=<span class="string">"BeanXML.Bean"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"BeanXML.xml"</span>);</span><br><span class="line">    Bean bean = (Bean)context.getBean(<span class="string">"bean1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-静态工厂实例化的方式"><a href="#2-静态工厂实例化的方式" class="headerlink" title="2.静态工厂实例化的方式"></a>2.静态工厂实例化的方式</h3><ol><li><p>编写工厂类，Bean类同上</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> Bean <span class="title">getBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"通过BeanFactory静态方法获取Bean对象"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在xml文件中进行配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过BeanFactory静态方法获取Bean对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean2"</span> <span class="attr">class</span>=<span class="string">"BeanXML.BeanFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getBean"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="3-实例工厂实例化的方式"><a href="#3-实例工厂实例化的方式" class="headerlink" title="3.实例工厂实例化的方式"></a>3.实例工厂实例化的方式</h3><ol><li><p>编写工厂类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bean <span class="title">getBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"先获得BeanFactory1的对象，再调用对象中的方法获得Bean对象"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在xml文件需要配置两个bean标签,一个是工厂类对象，一个是Bean类对象</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 先获得BeanFactory1的对象，再调用对象中的方法获得Bean对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanFactory1"</span> <span class="attr">class</span>=<span class="string">"BeanXML.BeanFactory1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean3"</span> <span class="attr">class</span>=<span class="string">"BeanXML.Bean"</span> <span class="attr">factory-bean</span>=<span class="string">"beanFactory1"</span> <span class="attr">factory-method</span>=<span class="string">"getBean"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h2><h3 id="1-通过构造方法进行属性注入"><a href="#1-通过构造方法进行属性注入" class="headerlink" title="1. 通过构造方法进行属性注入"></a>1. 通过构造方法进行属性注入</h3><p><em>注意：类person需要实现相应的构造函数</em></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"pojo.Person"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"雄"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"2"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-Set方法的属性注入"><a href="#2-Set方法的属性注入" class="headerlink" title="2.Set方法的属性注入"></a>2.Set方法的属性注入</h3><p><em>注意：类中需要实现相应的setter方法</em></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- name表示对象中的属性名 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- value注入普通属性 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ref注入对象属性，前提是该对象需要交给IoC容器管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"phone"</span> <span class="attr">class</span>=<span class="string">"pojo.Phone"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"小米"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"money"</span> <span class="attr">value</span>=<span class="string">"1999"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"pojo.Person"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"雄"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"2"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"phone"</span> <span class="attr">ref</span>=<span class="string">"phone"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-通过引入p名称空间完成属性的注入"><a href="#3-通过引入p名称空间完成属性的注入" class="headerlink" title="3.通过引入p名称空间完成属性的注入"></a>3.通过引入p名称空间完成属性的注入</h3><p>（1）需要引入p名称空间</p><ul><li>写法：<ul><li>普通属性        p:属性名=”值”</li><li>对象属性        p:属性名-ref=”配置bean标签的id”</li></ul></li></ul><p>（2）配置如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line">    xmlns:p="http://www.springframework.org/schema/p" &lt;!-- 引入p名称空间 --&gt;</span><br><span class="line">    xsi:schemaLocation="http://www.springframework.org/schema/beans</span><br><span class="line">        https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"phone"</span> <span class="attr">class</span>=<span class="string">"pojo.Phone"</span> <span class="attr">p:id</span>=<span class="string">"1"</span> <span class="attr">p:name</span>=<span class="string">"小米"</span> <span class="attr">p:money</span>=<span class="string">"1999"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"pojo.Person"</span> <span class="attr">p:id</span>=<span class="string">"1"</span> <span class="attr">p:name</span>=<span class="string">"雄"</span> <span class="attr">p:age</span>=<span class="string">"2"</span> <span class="attr">p:phone-ref</span>=<span class="string">"phone"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-SpEL的属性注入（Spring3-0以后）"><a href="#4-SpEL的属性注入（Spring3-0以后）" class="headerlink" title="4.SpEL的属性注入（Spring3.0以后）"></a>4.SpEL的属性注入（Spring3.0以后）</h3><p>（1）SpEL：Spring Expression Language，Spring的表达式语言</p><p>（2）使用见例子：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- phoneinfo有个name属性还有一个 calculateMonney()方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"phoneinfo"</span> <span class="attr">class</span>=<span class="string">"pojo.PhoneInfo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"小米"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 通过SpEL 可以调用其他bean的方法和属性 --&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"phone"</span> <span class="attr">class</span>=<span class="string">"pojo.Phone"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"#&#123;phoneinfo.name&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"money"</span> <span class="attr">value</span>=<span class="string">"#&#123;phoneinfo.calculateMonney()&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 通过SpEL 也可以注入基本类型数据，字符串用单引号 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"pojo.Person"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"#&#123;'雄'&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"#&#123;2&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"phone"</span> <span class="attr">ref</span>=<span class="string">"phone"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-集合类型属性注入"><a href="#5-集合类型属性注入" class="headerlink" title="5.集合类型属性注入"></a>5.集合类型属性注入</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"collectionBean"</span> <span class="attr">class</span>=<span class="string">"pojo.CollectionBean"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数组类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"array"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 注入list集合 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lists"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>雄<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>俊<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>彬<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 注入set集合 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"set"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>肥熊雄<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>肥俊<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>彬<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 注入Map集合 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"111"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"2"</span> <span class="attr">value</span>=<span class="string">"222"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"3"</span> <span class="attr">value</span>=<span class="string">"333"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>在一个配置文件中引入其他配置文件</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">""</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>bean标签中的其他属性<ul><li>scope取值：<ul><li>singleton 单例模式（默认）</li><li>prototype 多例</li></ul></li><li>lazy-init取值：<ul><li>true 使用到bean对象时才创建</li><li>false（默认）IoC容器创建好之后，就创建好所有管理的bean对象</li></ul></li><li>init-method ：对象在创建后，执行某个方法</li><li>destroy-method：</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"User"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span> <span class="attr">lazy-init</span>=<span class="string">"true"</span> <span class="attr">init-method</span>=<span class="string">""</span> <span class="attr">destroy-method</span>=<span class="string">""</span>/&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Spring-中IoC注解方式的使用"><a href="#Spring-中IoC注解方式的使用" class="headerlink" title="Spring 中IoC注解方式的使用"></a>Spring 中IoC注解方式的使用</h1><p>相关注解：</p><ul><li>@ComponentScan扫描器</li><li>@Configuration表明该类是配置类</li><li>@Component 指定把一个对象加入IOC容器—&gt;@Name也可以实现相同的效果【一般少用】</li><li>@Repository 作用同@Component； 在持久层使用</li><li>@Service 作用同@Component； 在业务逻辑层使用</li><li>@Controller 作用同@Component； 在控制层使用</li><li>@Resource 依赖关系<ul><li>如果@Resource不指定值，那么就根据类型来找，相同的类型在IOC容器中不能有两个</li><li>如果@Resource指定了值，那么就根据名字来找</li></ul></li></ul><p>直接上例子：</p><p>（0）配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 指定包名，spring就会到包里扫描，需要被Spring管理的对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"IoC_annotation"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 如果类上没有注解标记被Spring管理，但是需要使用属性注入的相关注解，就设置该注解 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>（1）接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）实现类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"userDao"</span>) <span class="comment">// 相当于在xml中配置bean标签  其中id为"userDao"</span></span><br><span class="line"><span class="comment">// @Component修饰一个类，将这个类交给Spring管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImp</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"小熊"</span>)    <span class="comment">// 设置属性值</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"100"</span>)   <span class="comment">// 也可以在setter方法使用注解设置属性的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"UserDaoImp---save() name="</span>+name + <span class="string">" age="</span>+age);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>(<span class="string">"userService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImp</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入UserDao</span></span><br><span class="line">    <span class="comment">//@Autowired  // 这种方式Spring自动去找符合类型的对象，该对象必须被Spring管理</span></span><br><span class="line">    <span class="comment">//private UserDao userDao;</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"userDao"</span>) <span class="comment">// 按名称查找对象并注入</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.save();</span><br><span class="line">        System.out.println(<span class="string">"UserServiceImp.save()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring-AOP-利用注解方式"><a href="#Spring-AOP-利用注解方式" class="headerlink" title="Spring AOP  利用注解方式"></a>Spring AOP  利用注解方式</h1><ol><li><p><strong>编写目标类（需要被增强的类，也就是被代理的类）</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果不使用接口，Spring底层会使用Cglib动态代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"保存订单"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"删除订单"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"更新订单"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"查找订单"</span>);</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>/<span class="number">0</span>; <span class="comment">// 为了抛出异常</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>配置文件中配置目标类</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置目标对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"orderDao"</span> <span class="attr">class</span>=<span class="string">"aop_annotation.OrderDao"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>编写切面类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspectAnnotation</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>配置文件中配置切面类</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置切面类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myAspect"</span> <span class="attr">class</span>=<span class="string">"aop_annotation.MyAspectAnnotation"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>在配置文件中开启注解的AOP开发</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>在切面类上使用注解</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspectAnnotation</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前置通知</span></span><br><span class="line">    <span class="meta">@Before</span>(value=<span class="string">"execution(* aop_annotation.OrderDao.save(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置增强....."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后置通知</span></span><br><span class="line">    <span class="meta">@AfterReturning</span>(value=<span class="string">"execution(* aop_annotation.OrderDao.delete(..))"</span>,returning=<span class="string">"result"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置增强。。。"</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 环绕通知</span></span><br><span class="line">    <span class="meta">@Around</span>(value=<span class="string">"execution(* aop_annotation.OrderDao.update(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"环绕增强前======"</span>);</span><br><span class="line">        Object proceed = joinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">"环绕增强后======"</span>);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 异常抛出通知</span></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(value=<span class="string">"execution(* aop_annotation.OrderDao.find(..))"</span>, throwing=<span class="string">"e"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"#####异常抛出增强"</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最终通知</span></span><br><span class="line">    <span class="meta">@After</span>(value=<span class="string">"execution(* aop_annotation.OrderDao.find(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalNotice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"最终通知*********"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注意：如果切入点更改，那么需要改很多处地方。比如OderDao里面的find方法改名了（见下面的代码），改成了search，那么下面代码中的注解都要进行更改</em></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异常抛出通知</span></span><br><span class="line"><span class="meta">@AfterThrowing</span>(value=<span class="string">"execution(* aop_annotation.OrderDao.find(..))"</span>, throwing=<span class="string">"e"</span>)</span><br><span class="line"><span class="comment">// 最终通知</span></span><br><span class="line"><span class="meta">@After</span>(value=<span class="string">"execution(* aop_annotation.OrderDao.find(..))"</span>)</span><br></pre></td></tr></table></figure><p><em>可以使用注解配置切入点，解决上面的问题</em></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异常抛出通知</span></span><br><span class="line"><span class="comment">//注意切入点写法:类名.方法名()</span></span><br><span class="line"><span class="meta">@AfterThrowing</span>(value=<span class="string">"MyAspectAnnotation.pointCnt1()"</span>, throwing=<span class="string">"e"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"#####异常抛出增强"</span> + e.getMessage());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终通知</span></span><br><span class="line"><span class="comment">//注意切入点写法:类名.方法名()</span></span><br><span class="line"><span class="meta">@After</span>(value=<span class="string">"MyAspectAnnotation.pointCnt1()"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalNotice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"最终通知*********"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut</span>(value=<span class="string">"execution(* aop_annotation.OrderDao.find(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pointCnt1</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@RunWith</span>(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ContextConfiguration</span>("classpath:aopAnnotation.xml") 配置文件路径</span></span><br><span class="line"><span class="comment"> * 这两个注解是spring整合JUnit</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(<span class="string">"classpath:aopAnnotation.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"orderDao"</span>)</span><br><span class="line">    <span class="keyword">private</span> OrderDao orderDao;</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        orderDao.save();</span><br><span class="line">        orderDao.delete();</span><br><span class="line">        orderDao.update();</span><br><span class="line">        orderDao.find();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 运行结果：</span></span><br><span class="line"><span class="comment">前置增强.....</span></span><br><span class="line"><span class="comment">保存订单</span></span><br><span class="line"><span class="comment">删除订单</span></span><br><span class="line"><span class="comment">后置增强。。。操作员：小雄</span></span><br><span class="line"><span class="comment">环绕增强前======</span></span><br><span class="line"><span class="comment">更新订单</span></span><br><span class="line"><span class="comment">环绕增强后======</span></span><br><span class="line"><span class="comment">查找订单</span></span><br><span class="line"><span class="comment">最终通知</span></span><br><span class="line"><span class="comment">#####异常抛出增强/ by zero</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="Spring-AOP-xml方式"><a href="#Spring-AOP-xml方式" class="headerlink" title="Spring AOP xml方式"></a>Spring AOP xml方式</h1><ol><li><p>将需要被增强的对象交给IoC容器管理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductDaoImp</span> <span class="keyword">implements</span> <span class="title">ProductDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"保存商品"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"更新商品"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"查找商品"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           System.out.println(<span class="string">"删除商品"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置被增强的对象 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"productDao"</span> <span class="attr">class</span>=<span class="string">"aop.ProductDaoImp"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写切面类，并将切面类交给IoC容器管理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 切面类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspectXML</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 可以通过参数里面设置 Joinpoint joinPoint 传入切入点信息</span></span><br><span class="line">    <span class="comment">// 切入点就是，我们要增强的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkPri</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"权限检测-----"</span> + joinPoint);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 可以通过后置通知获取切入点返回的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"日志记录--------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"环绕前通知-----"</span>);</span><br><span class="line">        Object object = joinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">"环绕后通知-----"</span>);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将切面交给Spring管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myAspect"</span> <span class="attr">class</span>=<span class="string">"aop.MyAspectXML"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在xml中进行aop配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过AOP配置，完成对目标类产生代理 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- expression 配置哪些类的哪些方法需要增强  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 切面 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"myAspect"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 切入点 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* aop.ProductDaoImp.save(..))"</span> <span class="attr">id</span>=<span class="string">"pointcut1"</span>/&gt;</span> </span><br><span class="line">      <span class="comment">&lt;!-- 前置通知 --&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"checkPri"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut1"</span>/&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">&lt;!-- 切入点 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* aop.ProductDaoImp.update(..))"</span> <span class="attr">id</span>=<span class="string">"pointcut2"</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 后置通知 --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 如果后置通知需要获取返回值，那么需要在 method里设置参数Object retVal --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"writeLog"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut2"</span> <span class="attr">returning</span>=<span class="string">"retVal"</span>/&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">&lt;!-- 切入点 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* aop.ProductDaoImp.find(..))"</span> <span class="attr">id</span>=<span class="string">"pointcut3"</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 环绕通知 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">"around"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut3"</span> /&gt;</span> </span><br><span class="line">      </span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:a</span> <span class="attr">spect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="Spring的JDBC模板"><a href="#Spring的JDBC模板" class="headerlink" title="Spring的JDBC模板"></a>Spring的JDBC模板</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Spring JDBC模板的使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Saber</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCDemo1</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">// JDBC模板的使用类似JbUtil</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建连接池</span></span><br><span class="line">        DriverManagerDataSource dataSource = <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">"root"</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">"jdbc:mysql:///aa"</span>);</span><br><span class="line">        <span class="comment">// 创建jdbc模板</span></span><br><span class="line">        JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">        jdbcTemplate.update(<span class="string">"insert into person values (null, ?, ?)"</span>, <span class="string">"雄"</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们观察上面的代码发现：DriverManagerDataSource和JdbcTemplate这两个类需要我们自己创建，我们可以将他们交给Spring容器管理</p><p>(1)配置文件 spring_jdbc.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span> = <span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span> = <span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:aop</span> = <span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span> = <span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">&lt;!--   将Spring内置的JDBC连接池(org.springframework.jdbc.datasource.DriverManagerDataSource)交给Spring管理 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">        dataSource.setDriverClassName("com.mysql.jdbc.Driver");</span></span><br><span class="line"><span class="comment">        dataSource.setUsername("root");</span></span><br><span class="line"><span class="comment">        dataSource.setPassword("123456");</span></span><br><span class="line"><span class="comment">        dataSource.setUrl("jdbc:mysql:///aa");</span></span><br><span class="line"><span class="comment">                    依赖注入</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///aa"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">&lt;!-- 将org.springframework.jdbc.core.JdbcTemplate交由Spring容器管理 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(2)测试代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">// 使用IoC修改demo1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring_jdbc.xml"</span>);</span><br><span class="line"><span class="comment">// 从Spring容器中获取jdbc模板对象</span></span><br><span class="line">JdbcTemplate jdbcTemplate = (JdbcTemplate)context.getBean(<span class="string">"jdbcTemplate"</span>);</span><br><span class="line">jdbcTemplate.update(<span class="string">"insert into person values (null, ?, ?)"</span>, <span class="string">"肥雄"</span>, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用第三方连接池"><a href="#使用第三方连接池" class="headerlink" title="使用第三方连接池"></a>使用第三方连接池</h2><blockquote><p>常用第三方连接池有dbcp 和 c3p0，下面以dbcp为例子</p></blockquote><ol><li>引入jar包</li><li>配置文件中配置</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 如果需要使用dpcp连接池  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dbcpDataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///aa"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 将org.springframework.jdbc.core.JdbcTemplate交由Spring容器管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dbcpDataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>测试代码</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring_jdbc.xml"</span>);</span><br><span class="line"><span class="comment">// 从Spring容器中获取jdbc模板对象</span></span><br><span class="line">JdbcTemplate jdbcTemplate = (JdbcTemplate)context.getBean(<span class="string">"jdbcTemplate"</span>);</span><br><span class="line">jdbcTemplate.update(<span class="string">"insert into person values (null, ?, ?)"</span>, <span class="string">"大肥雄"</span>, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>观察上方配置文件中的对连接池对象的属性注入，如果配置有多个连接池，如果要对username这个属性进行更改，那么需要改很多处地方。</strong></p><p>解决办法：引入外部属性文件</p><ol><li><p>创建一个属性文件 jdbc.properties</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">jdbc.driverClass=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql:///aa</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=123456</span><br></pre></td></tr></table></figure></li><li><p>在spring配置文件中引入属性文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">   <span class="comment">&lt;!-- 引入属性文件================================== --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 第一种方式通过一个bean标签引入的（很少） --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    </span></span><br><span class="line"><span class="comment">    &lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;</span></span><br><span class="line"><span class="comment">        &lt;property name="location" value="classpath:jdbc.properties"/&gt;</span></span><br><span class="line"><span class="comment">    &lt;/bean&gt; </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 第二种方式通过context标签引入的 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:jdbc.properties"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通过${key} 就可以获取属性文件中的value值</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置C3P0连接池=============================== --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driverClass&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span> <span class="comment">&lt;!-- 注意C3p0的url有些不同 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="CRUD操作"><a href="#CRUD操作" class="headerlink" title="CRUD操作"></a>CRUD操作</h2><ol start="0"><li><p>创建数据库表</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `person` (</span><br><span class="line">  `id` BIGINT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  `name` VARCHAR(<span class="number">50</span>),</span><br><span class="line">  `age` INT</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>整合JUnit 和 Spring，方便进行测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(<span class="string">"classpath:spring_jdbc.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CRUD</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"jdbcTemplate"</span>)</span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 直接使用jdbcTemplate进行测试</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>保存操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">// 保存操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">jdbcTemplate.update(<span class="string">"insert into person values(null, ?, ?)"</span>, <span class="string">"西伯利亚雄"</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">// 修改操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">jdbcTemplate.update(<span class="string">"update person set name = ? where id = ?"</span>, <span class="string">"希伯里"</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">// 删除操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    jdbcTemplate.update(<span class="string">"delete from person where id = ?"</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查询某个字段，并把结果进行封装成相应的对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">// 查询操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Long count = jdbcTemplate.queryForObject(<span class="string">"select count(*) from person"</span>, Long.class);</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查询一条记录，将结果封装到实体类中，需要实现RowMapper<t>接口，将结果集的字段与对象属性对应</t></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">// 封装到一个对象中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 自定义的RowMapper，具有一定的通用性</span></span><br><span class="line">    MyRowMapper&lt;Person&gt; rowMapper = <span class="keyword">new</span> MyRowMapper&lt;&gt;(Person.class);</span><br><span class="line">    Person person = (Person) jdbcTemplate.queryForObject(<span class="string">"select * from person where id = ?"</span>, rowMapper,<span class="number">2</span>);</span><br><span class="line">    System.out.println(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RowMapper<t> 通用实现，利用反射</t></strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRowMapper</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">RowMapper</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; targetClazz;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存属性名与Field对象的映射，方便从数据库字段名定位Field对象</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Field&gt; fieldMap;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRowMapper</span><span class="params">(Class&lt;?&gt; targetClazz)</span></span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.targetClazz = targetClazz;</span><br><span class="line">       </span><br><span class="line">       fieldMap = <span class="keyword">new</span> HashMap&lt;String, Field&gt;();</span><br><span class="line">       <span class="comment">// 获取类的全部属性，包括私有属性</span></span><br><span class="line">       Field[] declaredFields = <span class="keyword">this</span>.targetClazz.getDeclaredFields();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;declaredFields.length;++i) &#123;</span><br><span class="line">           <span class="comment">// 存储时，将属性名称全部化为小写，方便比较</span></span><br><span class="line">           String name = declaredFields[i].getName().toLowerCase();</span><br><span class="line">           fieldMap.put(name, declaredFields[i]);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> rowNumber)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        ResultSetMetaData metaData = rs.getMetaData();</span><br><span class="line">        <span class="keyword">int</span> columnCount = metaData.getColumnCount();</span><br><span class="line">            </span><br><span class="line">        Object obj = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj = targetClazz.newInstance();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;columnCount;++i) &#123;</span><br><span class="line">                String colName = metaData.getColumnName(i+<span class="number">1</span>);<span class="comment">// ColumnName下标从1开始</span></span><br><span class="line">                <span class="comment">// 去除数据库字段名的下划线</span></span><br><span class="line">                colName = colName.replaceAll(<span class="string">"_"</span>, <span class="string">""</span>);</span><br><span class="line">                <span class="comment">// 转化为小写</span></span><br><span class="line">                colName = colName.toLowerCase();</span><br><span class="line">                Field field = fieldMap.get(colName);</span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                field.set(obj, rs.getObject(i+<span class="number">1</span>));  <span class="comment">// 下标从1开始</span></span><br><span class="line">                field.setAccessible(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T)obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查询多条记录</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">// 查询多条记录</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyRowMapper&lt;Person&gt; rowMapper = <span class="keyword">new</span> MyRowMapper&lt;&gt;(Person.class);</span><br><span class="line">    List&lt;Person&gt; persons = jdbcTemplate.query(<span class="string">"select * from person"</span>, rowMapper);</span><br><span class="line">    System.out.println(persons);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring是什么：&quot;&gt;&lt;a href=&quot;#Spring是什么：&quot; class=&quot;headerlink&quot; title=&quot;Spring是什么：&quot;&gt;&lt;/a&gt;Spring是什么：&lt;/h1&gt;&lt;p&gt;如果单独讲概念的话，直接看百科就行。这里主要列出了Spring的两个核心概念
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://chsobin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://chsobin.github.io/tags/Java/"/>
    
      <category term="Spring" scheme="https://chsobin.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存划分</title>
    <link href="https://chsobin.github.io/2019/04/08/JVM%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/"/>
    <id>https://chsobin.github.io/2019/04/08/JVM内存划分/</id>
    <published>2019-04-08T15:25:21.000Z</published>
    <updated>2019-04-08T15:29:31.483Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是笔者阅读《深入理解Java虚拟机》的读书笔记</p></blockquote><h1 id="Java虚拟机规范"><a href="#Java虚拟机规范" class="headerlink" title="Java虚拟机规范"></a>Java虚拟机规范</h1><p>根据Java虚拟机规范，运行时数据区域可以划分为如下：</p><ol><li><p>由所有线程共享的数据区：</p><ul><li>方法区</li><li>堆</li></ul></li><li><p>线程隔离的数据区：</p><ul><li><p>虚拟机栈</p></li><li><p>本地方法栈</p></li><li>程序计数器</li></ul></li></ol><p>规范是这样划分的，但具体的虚拟机实现不一样，不同版本的虚拟机也不一样</p><p>下面以JDK8的HotSpot虚拟机为例，进行划分</p><h1 id="HotSpot虚拟机内存划分"><a href="#HotSpot虚拟机内存划分" class="headerlink" title="HotSpot虚拟机内存划分"></a>HotSpot虚拟机内存划分</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="jvm内存划分.JPG" alt="jvm内存划分" title>                </div>                <div class="image-caption">jvm内存划分</div>            </figure><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。</p><h2 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h2><p>是什么？</p><ul><li><p>Java方法执行的内存模型</p></li><li><p>每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。</p></li><li><p>从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p></li></ul><p>如何设置大小？</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 设置一个线程的栈大小</span><br><span class="line">java -Xss128K Class文件</span><br></pre></td></tr></table></figure><p>该区域可能抛出以下异常：</p><ul><li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；</li><li>栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。</li></ul><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>所有对象都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</span><br><span class="line">java -Xms1M -Xmx2M HackTheJava</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p>永久代是HotSpot对方法区的实现</p><ul><li>永久代物理是是堆的一部分，和新生代，老年代地址是连续的</li></ul></li><li><p>HotSpot在1.8之后取消了永久代，改为元空间</p><ul><li><p>元空间使用本地内存</p></li><li><p>元空间存储类的元信息</p></li><li><p>静态变量和常量池等并入堆中</p></li><li>相当于永久代的数据被分到了堆和元空间中。</li></ul></li></ul><h1 id="HotSpot虚拟机对象"><a href="#HotSpot虚拟机对象" class="headerlink" title="HotSpot虚拟机对象"></a>HotSpot虚拟机对象</h1><h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="堆对象内存布局.JPG" alt="堆对象内存布局" title>                </div>                <div class="image-caption">堆对象内存布局</div>            </figure><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><ul><li><p><strong>Mark Word</strong></p><ul><li><p>这部分数据长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit</p></li><li><p>对象需要存储的运行时数据很多，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储更多的信息</p><p>也就是说，对象在不同的状态下，这个Mark Word各个字段代表的意思也会跟着改变</p><p>eg:下面举个例子说明，具体应该结合jvm中锁的实现来理解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (1)normal object正常对象 </span></span><br><span class="line"><span class="comment">// hash:25bit    age:4bit     biased_lock:1bit lock:2bit</span></span><br><span class="line"><span class="comment">// (2)biased object</span></span><br><span class="line"><span class="comment">// JavaThread*:23bit   epoch:2bit    age:4bit   biased_lock:1bit   lock:2bit</span></span><br><span class="line"><span class="comment">// 还有其他状态的对象</span></span><br></pre></td></tr></table></figure><p><em>具体可以参考<a href="https://blog.csdn.net/zhoufanyang_china/article/details/54601311" target="_blank" rel="noopener">https://blog.csdn.net/zhoufanyang_china/article/details/54601311</a></em></p><p><em><a href="https://www.cnblogs.com/duanxz/p/4967042.html" target="_blank" rel="noopener">https://www.cnblogs.com/duanxz/p/4967042.html</a></em></p></li></ul></li><li><p><strong>类型指针</strong></p><p>指向对象所属类的元数据，（如果是使用句柄的方式定位对象，则不需要）</p><p><em>下文会具体展开通过句柄来定位对象在堆中的位置</em></p></li><li><p>如果对象是一个<strong>数组</strong>，那么对象头还需要存储数组的大小</p></li></ul><h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>各种类型字段的内容，也就是类的普通属性成员</p><h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>由于HotSpot VM 的自动内存管理系统要求对象起始地址必须是8字节的整数倍，因此需要将对象大小补充为8的倍数</p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>我们一般使用的是对象的引用，那么引用是如何定位堆中的对象的呢？</p><ul><li><p>通过句柄访问对象</p><p><img src="通过句柄访问对象.JPG" alt="通过句柄访问对象"></p></li><li><p>通过直接指针访问对象</p><p><img src="通过直接指针访问对象.JPG" alt="通过直接指针访问对象"></p></li></ul><p>对比</p><ul><li>使用句柄，应用类型存储的是稳定的句柄地址，在垃圾回收时，对象被移动，不用更改引用类型的值</li><li>使用直接指针，速度更快，减少了一次指针定位的开销</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文是笔者阅读《深入理解Java虚拟机》的读书笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Java虚拟机规范&quot;&gt;&lt;a href=&quot;#Java虚拟机规范&quot; class=&quot;headerlink&quot; title=&quot;Java虚拟机规范&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://chsobin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://chsobin.github.io/tags/Java/"/>
    
      <category term="jvm" scheme="https://chsobin.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>hexo搭建博客遇到的问题汇总</title>
    <link href="https://chsobin.github.io/2019/04/03/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>https://chsobin.github.io/2019/04/03/hexo搭建博客遇到的问题汇总/</id>
    <published>2019-04-03T01:31:11.000Z</published>
    <updated>2019-04-03T04:44:33.181Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>代码块必须指明语言，不然运行hexo g 命令会报错：</p></blockquote><p>TypeError: Cannot set property ‘lastIndex’ of undefined<br>解决方法：</p><ol><li><p>在 _config.yml 中设置 auto_detect: false</p></li><li><p>确保你的代码块有指定语言:</p><p>为了找到是哪一个post产生问题，可以移除所有的post,一个个添加回去，然后运行”hexo g”,看是否会报错</p></li></ol><blockquote><p>markdown 中的表格，开头不能有空格，不然会渲染失败</p></blockquote><p>这个问题，我提过issue，后来发现问题就关闭了，详情可以看：</p><p><a href="https://github.com/yscoder/hexo-theme-indigo/issues/467" target="_blank" rel="noopener">https://github.com/yscoder/hexo-theme-indigo/issues/467</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;代码块必须指明语言，不然运行hexo g 命令会报错：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;TypeError: Cannot set property ‘lastIndex’ of undefined&lt;br&gt;解决方法：&lt;/p&gt;
&lt;ol&gt;
&lt;
      
    
    </summary>
    
      <category term="hexo" scheme="https://chsobin.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://chsobin.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Java知识点总结</title>
    <link href="https://chsobin.github.io/2019/04/02/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://chsobin.github.io/2019/04/02/Java知识点总结/</id>
    <published>2019-04-02T14:01:21.000Z</published>
    <updated>2019-04-29T00:59:14.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>这篇文章是对Java相关知识点的简要总结，主要记录了我个人之前所忽略的知识点</p></li><li><p>对于每个工具类的使用，这里不做详细探讨，具体可以参照官方文档，<a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/</a></p></li></ul><h1 id="入门基础"><a href="#入门基础" class="headerlink" title="入门基础"></a>入门基础</h1><ul><li><p><strong>Java程序运行机制</strong></p><p>编译和解释结合</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">*.java 源文件   编译成  *.class 字节码文件</span><br><span class="line"></span><br><span class="line">jvm解释执行字节码文件</span><br></pre></td></tr></table></figure><blockquote><p>面试题：Java是解释执行的，对吗？</p><p>解答：</p><p>Java引进JIT技术之后，能将一些热点代码直接编译成机器语言</p><p>JIT 是 just in time 的缩写, 也就是即时编译编译器。使用即时编译器技术，能够加速 Java 程序的执行速度。下面，就对该编译器技术做个简单的讲解。</p><p>首先，我们大家都知道，通常通过 javac 将程序源代码编译，转换成 java 字节码，JVM 通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢很多。为了提高执行速度，引入了 JIT 技术。</p><p>在运行时 JIT 会把翻译过的机器码保存起来，以备下次使用，因此从理论上来说，采用该 JIT 技术可以接近以前纯编译技术。</p></blockquote></li><li><p><strong>jvm、jre、jdk</strong></p><p><img src="jdk.png" alt="jdk"></p></li><li><p>jar 包 就是一些字节码文件进行打包    </p></li><li><p><strong>成员变量 与 局部变量</strong></p><p>成员变量会自动初始化为默认值；局部变量必须先赋值才能使用</p></li><li><p><strong>常量命名规范</strong>：大写+下划线 如 MAX_VALUE</p></li><li><p><strong>int范围</strong>  -2^31 到 2^31-1</p></li><li><p><strong>java浮点常量 可以用科学计数法表示</strong></p><p>eg: 314e2=31400 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">314E2</span>=<span class="number">31400</span> </span><br><span class="line">  </span><br><span class="line"><span class="number">314E-2</span>=<span class="number">3.14</span></span><br></pre></td></tr></table></figure></li><li><p><strong>switch语句中case标签</strong>在JDK1.5之前必须是整数(long类型除外)或者枚举，不能是字符串，在JDK1.7之后允许使用字符串(String)。 </p></li><li><p><strong>重载</strong>：方法名相同，参数类型，个数，顺序不同</p></li></ul><h1 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h1><ul><li><p>java 内存模型</p><p><img src="jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="1551831947938">-</p></li><li><p><strong>静态导入</strong></p><p>jdk5之后的新特性 </p><p>其作用是用于导入指定类的静态属性，这样我们可以直接使用静态属性。 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;<span class="comment">//导入Math类的所有静态属性</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.PI;<span class="comment">//导入Math类的PI属性</span></span><br></pre></td></tr></table></figure></li><li><p><strong>方法的重写需要符合下面的三个要点：</strong></p><p>​      1.“==”： 方法名、形参列表相同。</p><p>​      2.“≤”：返回值类型和声明异常类型，子类小于等于父类。</p><p>​      3.“≥”： 访问权限，子类大于等于父类。</p></li><li><p><strong>访问权限修饰符 </strong></p></li></ul><table><thead><tr><th>修饰符</th><th>同一个类</th><th>同一个包</th><th>子类</th><th>所有类</th></tr></thead><tbody><tr><td>private</td><td>Y</td><td>不可访问</td><td>不可访问</td><td>不可访问</td></tr><tr><td>default</td><td>Y</td><td>Y</td><td>不可访问</td><td>不可访问</td></tr><tr><td>protected</td><td>Y</td><td>Y</td><td>Y</td><td>不可访问</td></tr><tr><td>public</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr></tbody></table><ul><li><p><strong>抽象类</strong></p><p>有抽象方法的类，abstract关键字修饰</p></li><li><p><strong>接口</strong></p><ul><li>interface可以继承多个接口，class可以实现多个接口</li><li>接口所有方法都是抽象，默认是 public abstract</li><li>接口里面的变量，默认都是 public static final,(也即是接口里面只能定义常量)</li></ul></li><li><p><strong>匿名内部类</strong></p><ul><li>不会生成.class文件。只能使用一次</li><li>匿名内部类中不能存在任何的静态成员变量和静态方法。</li><li>匿名内部类没有<em>构造器</em>，可以使用<em>构造代码块</em>代替</li></ul></li></ul><h1 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="Java异常类层次结构图.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>–<br><br>- Exception和Error的区别：Exception能被程序本身可以处理，Error是程序无法处理<br><br>- 需要注意的是，一旦某个catch捕获到匹配的异常类型，将进入异常处理代码。一经处理结束，就意味着整个try-catch语句结束。其他的catch子句不再有匹配和捕获异常类型的机会。<br><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkZero</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&gt;=-<span class="number">1</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">10</span>/i;</span><br><span class="line">            System.out.println(<span class="string">"i="</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkZero();    <span class="comment">// 一个异常只会被一个catch捕捉</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (ArithmeticException mathException)&#123;</span><br><span class="line">            System.out.println(<span class="string">"catch ArithmeticException"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception exception)&#123;</span><br><span class="line">            System.out.println(<span class="string">"catch Exception"</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.print(<span class="string">"finally"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行结果：</span></span><br><span class="line"><span class="comment"> * i=3</span></span><br><span class="line"><span class="comment"> * i=2</span></span><br><span class="line"><span class="comment"> * i=1</span></span><br><span class="line"><span class="comment"> * catch ArithmeticException</span></span><br><span class="line"><span class="comment"> * finally</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="Java%E9%9B%86%E5%90%88.webp" alt="Java集合" title>                </div>                <div class="image-caption">Java集合</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%9B%BE.webp" alt="Java集合框架图" title>                </div>                <div class="image-caption">Java集合框架图</div>            </figure><p>1、所有集合类都位于<code>java.util</code>包下。Java的集合类主要由两个接口派生而出：Collection和Map，Collection和Map是Java集合框架的根接口，这两个接口又包含了一些子接口或实现类。</p><p>2、集合接口：6个接口（短虚线表示），表示不同集合类型，是集合框架的基础。</p><p>3、抽象类：5个抽象类（长虚线表示），对集合接口的部分实现。可扩展为自定义集合类。</p><p>4、实现类：8个实现类（实线表示），对接口的具体实现。</p><p>5、Collection 接口是一组允许重复的对象。</p><p>6、Set 接口继承 Collection，集合元素不重复。</p><p>7、List 接口继承 Collection，允许重复，维护元素插入顺序。</p><p>8、Map接口是键－值对象，与Collection接口没有什么关系。</p><p>9、Set、List和Map可以看做集合的三大类：</p><ul><li>List集合是有序集合，集合中的元素可以重复，访问集合中的元素可以根据元素的索引来访问。</li><li>Set集合是无序集合，集合中的元素不可以重复，访问集合中的元素只能根据元素本身来访问（也是集合里元素不允许重复的原因）。</li><li>Map集合中保存Key-value对形式的元素，访问时只能根据每项元素的key来访问其value。</li></ul><h1 id="IO流技术"><a href="#IO流技术" class="headerlink" title="IO流技术"></a>IO流技术</h1><ul><li><p><strong>如何理解流？</strong></p><blockquote><p>流是个抽象的概念，是对输入输出设备的抽象，Java程序中，对于数据的输入/输出操作都是以“流”的方式进行。设备可以是文件，网络，内存等。</p></blockquote><blockquote><p>摘自Oracle官方文档：<a href="https://docs.oracle.com/javase/tutorial/essential/io/streams.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/essential/io/streams.html</a></p><p>An <em>I/O Stream</em> represents an input source or an output destination. A stream can represent many different kinds of sources and destinations, including disk files, devices, other programs, and memory arrays.</p><p>Streams support many different kinds of data, including simple bytes, primitive data types, localized characters, and objects. Some streams simply pass on data; others manipulate and transform the data in useful ways.</p><p>No matter how they work internally, all streams present the same simple model to programs that use them: A stream is a sequence of data. </p></blockquote></li><li><p><strong>常用类</strong> （学习使用的最好方法就是jdk api 文档）</p><ul><li><p>File 表示数据源</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文件路径建议</span></span><br><span class="line">String path = <span class="string">"D:/dir/a.txt"</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">String path2 = <span class="string">"D:"</span> + File.separator + <span class="string">"dir"</span> + File.separator + <span class="string">"a.txt"</span>;</span><br></pre></td></tr></table></figure></li><li><p>四大抽象类</p><ul><li>InputStream</li><li>OutputStream</li><li>Reader</li><li>Writer</li></ul></li><li><p>FileInputStream FileOutputStream 文件字节流 ，数据在硬盘</p></li><li><p>ByteArrayInputStream ByteArrayOutputStream 字节数组流，数据源在虚拟机内存</p></li></ul></li><li><p><strong>解码、编码</strong></p><ul><li>编码： 字符  ——– 使用特定字符集（如UTF-8 ）——-&gt; 字节 </li><li>解码： 字节 ———-使用特定字符集 ———&gt;字符</li><li>出现乱码的原因</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String msg = <span class="string">"你好啊"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] datas = msg.getBytes();<span class="comment">// 默认使用工程的字符集进行编码，此处假设为UTF-8</span></span><br><span class="line"><span class="comment">//(1) 字节数不够</span></span><br><span class="line">msg = <span class="keyword">new</span> String(datas, <span class="number">0</span>, datas.length-<span class="number">1</span>, <span class="string">"utf8"</span>);</span><br><span class="line">System.out.println(msg);</span><br><span class="line"><span class="comment">//(2) 编码解码的字符集不同</span></span><br><span class="line">msg = <span class="keyword">new</span> String(datas, <span class="string">"gbk"</span>);</span><br><span class="line">System.out.println(msg);</span><br></pre></td></tr></table></figure></li><li><p>IO操作基本步骤</p><ul><li>选择数据源</li><li>选择数据流</li><li>读或者写操作</li><li>释放资源</li></ul></li><li><p>IO相关类 很多利用了 装饰者模式</p><p><img src="%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F.JPG" alt></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);<span class="comment">// 将FileInputStream对象作为参数传入</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><ul><li><p>java多线程三种实现方法</p><ul><li>继承Thread类</li><li>实现Runnable接口</li><li>实现Callable接口</li></ul></li><li><p>实现Runnable接口这种方式用到了<strong>静态代理</strong>这个设计模式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(实现了Runnable接口的对象).start();</span><br></pre></td></tr></table></figure></li><li><p><strong>静态代理设计模式</strong>：</p><p><img src="静态代理.png" alt="静态代理"></p><p>代理模式主要包含三个角色，即抽象主题角色(Subject)、委托类角色(被代理角色，Proxied)以及代理类角色(Proxy)，如上图所示：</p><p>抽象主题角色:可以是接口，也可以是抽象类；<br>委托类角色：真实主题角色，业务逻辑的具体执行者；<br>代理类角色：内部含有对真实对象RealSubject的引用，负责对真实主题角色的调用，并在真实主题角色处理<strong>前后</strong>做预处理和后处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Driverable</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 被代理角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Driverable</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"moving..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartCar</span> <span class="keyword">implements</span> <span class="title">Driverable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Driverable target;<span class="comment">// 持有被代理对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SmartCar</span><span class="params">(Driverable target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.target = target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">begin(); <span class="comment">// 增强功能</span></span><br><span class="line">target.drive();</span><br><span class="line">end();<span class="comment">// 增强功能</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"启动智能系统"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"关闭智能系统"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>线程五种状态</strong></p><p><img src="线程五种状态.jpg" alt="线程五种状态"></p><ol><li><p>新建状态(New) : 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。</p></li><li><p>就绪状态(Runnable): 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。 </p></li><li><p>运行状态(Running): 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。 </p></li><li><p>阻塞状态(Blocked)  : 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：   </p><p>（1） 等待阻塞 – 通过调用线程的wait()方法，让线程等待某工作的完成。    </p><p>（2） 同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。</p><p>（3）其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。 </p></li><li><p>死亡状态(Dead)    : 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 </p></li></ol></li><li><p><strong>同步块</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// obj称之为同步监视器</span></span><br><span class="line"><span class="keyword">synchronized</span>(obj)&#123; 代码 &#125;</span><br></pre></td></tr></table></figure><ul><li>obj可以是任何对象，推荐使用共享资源作为同步监视器</li><li>同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this(即该对象本身)，或class(即类的模子)</li></ul></li></ul><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><ul><li><p>是什么：</p><p>Java注解又称Java标注 </p><p>Java语言中的类、方法、变量、参数和包等都可以被标注。</p><p>和Javadoc不同，Java标注可以通过反射获取标注内容。</p><p>在编译器生成类文件时，标注可以被嵌入到字节码中。Java虚拟机可以保留标注内容，在运行时可以获取到标注内容。</p></li><li><p>元注解</p><ul><li><p>是用于修饰注解的注解，通常用在注解的定义上，例如： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@Target：注解的作用目标</li><li>@Retention：注解的生命周期</li><li>@Documented：注解是否应当被包含在 JavaDoc 文档中</li><li>@Inherited：是否允许子类继承该注解</li></ul></li></ul></li><li><p>自定义注解</p><ul><li>定义一个用于数据库表的注解</li><li>注解里面可以定义注解元素，格式为类型 元素名() [default 元素值] </li><li>如果不指明default值，使用时必须传入元素值</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)<span class="comment">//只能应用于类上</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="comment">//保存到运行时</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DBTable &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在类上使用该注解</span></span><br><span class="line"><span class="meta">@DBTable</span>(name = <span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">// javabean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><ul><li><p>自动装箱，自动拆箱</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a = <span class="number">1</span>; <span class="comment">// 自动装箱，编译器会转化为 Integer a = Integer.valueOf(1)</span></span><br><span class="line"><span class="keyword">int</span> b = a; <span class="comment">// 自动拆箱 int b = a.intValue();</span></span><br></pre></td></tr></table></figure></li><li><p>缓存机制，缓存[-128, 127]之间的数字，具体查看Integer.valueOf()源码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer x = -<span class="number">128</span>;</span><br><span class="line">Integer y = Integer.valueOf(-<span class="number">128</span>);</span><br><span class="line">System.out.println(x==y);<span class="comment">// true</span></span><br><span class="line">System.out.println(x.equals(y));<span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="字符串相关类"><a href="#字符串相关类" class="headerlink" title="字符串相关类"></a>字符串相关类</h1><ul><li>StringBuffer  线程安全</li><li>StringBuilder 线程不安全</li></ul><h1 id="时间处理相关类"><a href="#时间处理相关类" class="headerlink" title="时间处理相关类"></a>时间处理相关类</h1><ul><li><p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3%E7%B1%BB.png" alt="时间日期相关类" title>                </div>                <div class="image-caption">时间日期相关类</div>            </figure>时间处理类之间的关系</p></li><li><p>DateFormat 抽象类 与 SimpleDateFormat 使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">    <span class="comment">// new出SimpleDateFormat对象</span></span><br><span class="line">    SimpleDateFormat s1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>);</span><br><span class="line">    <span class="comment">// 将时间对象转换成字符串</span></span><br><span class="line">    String daytime = s1.format(<span class="keyword">new</span> Date());</span><br><span class="line">    System.out.println(daytime);</span><br><span class="line">    <span class="comment">// 将符合指定格式的字符串转成成时间对象.字符串格式需要和指定格式一致。</span></span><br><span class="line">    String time = <span class="string">"2007-10-7 20:15:30"</span>;</span><br><span class="line">    Date date = s1.parse(time);</span><br><span class="line">    System.out.println(date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="文件类"><a href="#文件类" class="headerlink" title="文件类"></a>文件类</h1><ul><li><p>常用方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">"d:/c.txt"</span>);</span><br><span class="line">f.createNewFile(); <span class="comment">// 会在d盘下面生成c.txt文件</span></span><br><span class="line">f.delete(); <span class="comment">// 将该文件或目录从硬盘上删除</span></span><br><span class="line">System.out.println(<span class="string">"File是否存在："</span>+f.exists());</span><br><span class="line">System.out.println(<span class="string">"File是否是目录："</span>+f.isDirectory());</span><br><span class="line">System.out.println(<span class="string">"File是否是文件："</span>+f.isFile());</span><br><span class="line">System.out.println(<span class="string">"File最后修改时间："</span>+<span class="keyword">new</span> Date(f.lastModified()));</span><br><span class="line">System.out.println(<span class="string">"File的大小："</span>+f.length());</span><br><span class="line">System.out.println(<span class="string">"File的文件名："</span>+f.getName());</span><br><span class="line">System.out.println(<span class="string">"File的目录路径："</span>+f.getPath());</span><br></pre></td></tr></table></figure></li><li><p>创建目录</p><ul><li><p>mkdir</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File f2 = <span class="keyword">new</span> File(<span class="string">"d:/电影/华语/大陆"</span>);</span><br><span class="line"><span class="keyword">boolean</span> flag = f2.mkdir(); <span class="comment">//目录结构中有一个不存在，则不会创建整个目录树</span></span><br><span class="line">System.out.println(flag);<span class="comment">//创建失败</span></span><br></pre></td></tr></table></figure></li><li><p>mkdirs</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File f2 = <span class="keyword">new</span> File(<span class="string">"d:/电影/华语/大陆"</span>);</span><br><span class="line"><span class="keyword">boolean</span> flag = f2.mkdirs();<span class="comment">//目录结构中有一个不存在也没关系；创建整个目录树</span></span><br><span class="line">System.out.println(flag);<span class="comment">//创建成功</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><ul><li><p>所有的枚举类型隐性地继承自 java.lang.Enum。</p></li><li><p>枚举实质上还是类，而每个被枚举的成员实质就是一个枚举类型的实例，他们默认都是public static final修饰的。可以直接通过枚举类型名使用它们。 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**季节*/</span></span><br><span class="line"><span class="keyword">enum</span> Season &#123;</span><br><span class="line">    SPRING, SUMMER, AUTUMN, WINDTER</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**星期*/</span></span><br><span class="line"><span class="keyword">enum</span> Week &#123;</span><br><span class="line">    星期一, 星期二, 星期三, 星期四, 星期五, 星期六, 星期日</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要深入理解枚举实现得原理可以参考<a href="https://blog.csdn.net/javazejian/article/details/71333103" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/71333103</a></p></li></ul><h1 id="如何去学习框架"><a href="#如何去学习框架" class="headerlink" title="如何去学习框架"></a>如何去学习框架</h1><ul><li><p>是什么</p></li><li><p>为什么用</p></li><li><p>怎么做  小实例，最好跟着官方文档的示例做</p></li><li><p>框架提供的api ( 相关类的使用 )</p></li><li><p>框架相关配置文件</p><blockquote><p>个人理解，配置文件使得我们的系统解耦</p><p>一旦需求有变，只需要修改配置文件即可，无需更改源代码</p></blockquote></li></ul><p>以上为快速入门一个框架，说到底就是先学会怎么用工具，但是仅仅学会用是不够的。在会用的基础上，要站在高位去审视整个框架，去理解框架的架构，去更好地利用框架。如果框架本身提供的功能不能满足我们的需求，我们完全可以修改框架或者创造一个框架出来</p><h1 id="高级主题"><a href="#高级主题" class="headerlink" title="高级主题"></a>高级主题</h1><ul><li>反射<ul><li>动态代理</li></ul></li><li>jdbc</li><li>网络</li><li>多线程</li><li>JVM</li><li>设计模式</li></ul><p>对于高级主题推荐的书籍：</p><p>《java 并发编程实战》</p><p>《深入理解 java 虚拟机》</p><p>《mysql 必知必会》</p><p>《大话设计模式》</p><p>计算机网络：《TCP/IP详解卷一：协议》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;这篇文章是对Java相关知识点的简要总结，主要记录了我个人之前所忽略的知识点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于每个工
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://chsobin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://chsobin.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>测试代码块缩进问题</title>
    <link href="https://chsobin.github.io/2019/04/02/%E4%BB%A3%E7%A0%81%E5%9D%97%E7%BC%A9%E8%BF%9B%E9%97%AE%E9%A2%98/"/>
    <id>https://chsobin.github.io/2019/04/02/代码块缩进问题/</id>
    <published>2019-04-01T18:28:30.000Z</published>
    <updated>2019-04-01T19:19:38.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><p>使用Typora写文章时，发现从eclipse粘贴过来的代码经过hexo转化之后，缩进出现了错误</p><p>如下：明明是四个空格，却显示了8个</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Session session = HibernateUtil.openSession();</span><br><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line">tx.begin();</span><br><span class="line"></span><br><span class="line">Customer customer1 = <span class="keyword">new</span> Customer(); <span class="comment">// 新建一个客户对象</span></span><br><span class="line">customer1.setCust_name(<span class="string">"客户1"</span>);</span><br><span class="line"></span><br><span class="line">LinkMan linkman1_1 = <span class="keyword">new</span> LinkMan();<span class="comment">// 新建一个联系人</span></span><br><span class="line">linkman1_1.setLkm_name(<span class="string">"联系人1，属于客户1"</span>);</span><br><span class="line">linkman1_1.setCustomer(customer1);</span><br><span class="line"></span><br><span class="line">LinkMan linkMan1_2 = <span class="keyword">new</span> LinkMan();<span class="comment">// 新建一个联系人</span></span><br><span class="line">linkMan1_2.setLkm_name(<span class="string">"联系人2，属于客户1"</span>);</span><br><span class="line">linkMan1_2.setCustomer(customer1);</span><br><span class="line"></span><br><span class="line">customer1.getLinkMans().add(linkman1_1);</span><br><span class="line">customer1.getLinkMans().add(linkMan1_2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联系人和客户对象都需要保存</span></span><br><span class="line">session.save(customer1);</span><br><span class="line">session.save(linkman1_1);</span><br><span class="line">session.save(linkMan1_2);</span><br><span class="line"></span><br><span class="line">tx.commit();</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>详情参考：<a href="https://blog.csdn.net/qq_37932863/article/details/73611785" target="_blank" rel="noopener">https://blog.csdn.net/qq_37932863/article/details/73611785</a></p><p>解决之后，再次粘贴代码：可以看到缩进正常了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Session session = HibernateUtil.openSession();</span><br><span class="line">        Transaction tx = session.beginTransaction();</span><br><span class="line">        tx.begin();</span><br><span class="line">        </span><br><span class="line">        Customer customer1 = <span class="keyword">new</span> Customer(); <span class="comment">// 新建一个客户对象</span></span><br><span class="line">        customer1.setCust_name(<span class="string">"客户1"</span>);</span><br><span class="line">        </span><br><span class="line">        LinkMan linkman1_1 = <span class="keyword">new</span> LinkMan(); <span class="comment">// 新建一个联系人</span></span><br><span class="line">        linkman1_1.setLkm_name(<span class="string">"联系人1，属于客户1"</span>);</span><br><span class="line">        linkman1_1.setCustomer(customer1);</span><br><span class="line">        </span><br><span class="line">        LinkMan linkMan1_2 = <span class="keyword">new</span> LinkMan(); <span class="comment">// 新建一个联系人</span></span><br><span class="line">        linkMan1_2.setLkm_name(<span class="string">"联系人2，属于客户1"</span>);</span><br><span class="line">        linkMan1_2.setCustomer(customer1);</span><br><span class="line">        </span><br><span class="line">        customer1.getLinkMans().add(linkman1_1);</span><br><span class="line">        customer1.getLinkMans().add(linkMan1_2);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 联系人和客户对象都需要保存</span></span><br><span class="line">        session.save(customer1);</span><br><span class="line">        session.save(linkman1_1);</span><br><span class="line">        session.save(linkMan1_2);</span><br><span class="line">        </span><br><span class="line">        tx.commit();</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题：&quot;&gt;&lt;a href=&quot;#问题：&quot; class=&quot;headerlink&quot; title=&quot;问题：&quot;&gt;&lt;/a&gt;问题：&lt;/h1&gt;&lt;p&gt;使用Typora写文章时，发现从eclipse粘贴过来的代码经过hexo转化之后，缩进出现了错误&lt;/p&gt;
&lt;p&gt;如下：明明是四个空格
      
    
    </summary>
    
      <category term="问题集" scheme="https://chsobin.github.io/categories/%E9%97%AE%E9%A2%98%E9%9B%86/"/>
    
    
      <category term="hexo" scheme="https://chsobin.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate学习笔记</title>
    <link href="https://chsobin.github.io/2019/04/01/Hibernate%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://chsobin.github.io/2019/04/01/Hibernate学习笔记/</id>
    <published>2019-04-01T15:52:36.000Z</published>
    <updated>2019-04-15T11:33:54.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><ul><li>Hibernate是一种ORM(Object Relational Mapping ）框架</li><li>它对JDBC进行了非常轻量级的对象封装 </li><li>hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库 </li></ul><a id="more"></a><h2 id="为什么要用"><a href="#为什么要用" class="headerlink" title="为什么要用"></a>为什么要用</h2><ul><li>传统基于JDBC的开发，代码重复性过多</li><li>使用Hibernate框架，简化了Dao层的编码工作，不用我们写很多繁琐的SQL语句</li></ul><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>注意：此案例基于hibernate-release-5.0.7.Final</p><p><strong>（1）下载Hibernate 开发环境，解压后有三个主要文件夹</strong></p><ul><li>documentation          :Hibernate开发的文档</li><li>lib                                  :Hibernate开发包<ul><li>required                       :Hibernate开发的必须的依赖</li><li>optional                         :Hibernate开发的可选的jar包</li></ul></li><li>project                          :Hibernate提供的项目</li></ul><p><strong>（2）创建一个项目，引入jar包</strong></p><ul><li>数据库驱动包  mysql-connector-java-5.1.7-bin.jar</li><li>Hibernate开发的必须的jar包。  步骤1中required中所有的包</li><li>日志记录包<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="log4j.png" alt title>                </div>                <div class="image-caption"></div>            </figure></li></ul><p><strong>（3）创建表</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`cst_customer`</span> (</span><br><span class="line">  <span class="string">`cust_id`</span> <span class="built_in">bigint</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'客户编号(主键)'</span>,</span><br><span class="line">  <span class="string">`cust_name`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'客户名称(公司名称)'</span>,</span><br><span class="line">  <span class="string">`cust_source`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'客户信息来源'</span>,</span><br><span class="line">  <span class="string">`cust_industry`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'客户所属行业'</span>,</span><br><span class="line">  <span class="string">`cust_level`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'客户级别'</span>,</span><br><span class="line">  <span class="string">`cust_phone`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'固定电话'</span>,</span><br><span class="line">  <span class="string">`cust_mobile`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'移动电话'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`cust_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><p><strong>（4）创建实体类</strong></p><p>​    com.example.hibernate.demo1.Customer.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Long cust_id;</span><br><span class="line"><span class="keyword">private</span> String cust_name;</span><br><span class="line"><span class="keyword">private</span> String cust_source;</span><br><span class="line"><span class="keyword">private</span> String cust_industry;</span><br><span class="line"><span class="keyword">private</span> String cust_level;</span><br><span class="line"><span class="keyword">private</span> String cust_phone;</span><br><span class="line"><span class="keyword">private</span> String cust_mobile;</span><br><span class="line"><span class="comment">// 省略getter setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（5）创建实体类Customer 与表cst_customer的映射</strong></p><p>src/com/example/hibernate/demo1/Customer.hbm.xml</p><p>命名格式一般为：类名.hbm.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC </span></span><br><span class="line"><span class="meta">    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 建立类与表的映射 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"com.example.hibernate.demo1.Customer"</span> <span class="attr">table</span>=<span class="string">"cst_customer"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 建立类中的属性与表中的主键对应 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"cust_id"</span> <span class="attr">column</span>=<span class="string">"cust_id"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 建立类中的普通的属性和表的字段的对应 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_name"</span> <span class="attr">column</span>=<span class="string">"cust_name"</span> <span class="attr">length</span>=<span class="string">"32"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_source"</span> <span class="attr">column</span>=<span class="string">"cust_source"</span> <span class="attr">length</span>=<span class="string">"32"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_industry"</span> <span class="attr">column</span>=<span class="string">"cust_industry"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_level"</span> <span class="attr">column</span>=<span class="string">"cust_level"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_phone"</span> <span class="attr">column</span>=<span class="string">"cust_phone"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_mobile"</span> <span class="attr">column</span>=<span class="string">"cust_mobile"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>注意：</em></p><p><em>(1)该配置文件的DTD 在hibernate-core-5.0.7.Final.jar包下的/org/hibernate/hibernate-mapping-3.0.dtd</em></p><p><em>(2)在eclipse中设置xml自动提示，需要告诉eclipse相应的DTD文件位置具体设置可以自行百度</em></p><p><strong>（6）创建Hibernate的核心配置文件</strong></p><ul><li>Hibernate的核心配置文件的名称：hibernate.cfg.xml</li><li>放置在src目录下</li><li>该配置文件的DTD 在hibernate-core-5.0.7.Final.jar包下的/org/hibernate/hibernate-configuration-3.0.dtd</li><li>具体怎么写可以参考步骤1中project文件夹下的/etc/hibernate.properties</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-configuration PUBLIC</span></span><br><span class="line"><span class="meta">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 连接数据库的基本参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql:///hibernate<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.password"</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置Hibernate的方言 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 可选配置================ --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 打印SQL --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 格式化SQL ，使得打印出来的SQL语句更加美观--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">&lt;!-- 映射文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"com/example/hibernate/demo1/Customer.hbm.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>（7）编写测试代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">// 保存客户的案例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 1.加载Hibernate的核心配置文件</span></span><br><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line"><span class="comment">// 手动加载映射</span></span><br><span class="line"><span class="comment">// configuration.addResource("com/example/hibernate/demo1/Customer.hbm.xml");</span></span><br><span class="line"><span class="comment">// 2.创建一个SessionFactory对象：类似于JDBC中连接池 </span></span><br><span class="line">SessionFactory sessionFactory = configuration.buildSessionFactory();</span><br><span class="line"><span class="comment">// 3.通过SessionFactory获取到Session对象：类似于JDBC中Connection</span></span><br><span class="line">Session session = sessionFactory.openSession();</span><br><span class="line"><span class="comment">// 4.手动开启事务：</span></span><br><span class="line">Transaction transaction = session.beginTransaction();</span><br><span class="line"><span class="comment">// 5.编写代码</span></span><br><span class="line"></span><br><span class="line">Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">customer.setCust_name(<span class="string">"王西"</span>);</span><br><span class="line"></span><br><span class="line">session.save(customer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.事务提交</span></span><br><span class="line">transaction.commit();</span><br><span class="line"><span class="comment">// 7.资源释放</span></span><br><span class="line">session.close();</span><br><span class="line">sessionFactory.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="映射的配置"><a href="#映射的配置" class="headerlink" title="映射的配置"></a>映射的配置</h2><ul><li><p>【class标签的配置】建立类与表的映射关系</p><p>属性：</p><ul><li>name                ：类的全路径</li><li>table                 ：表名（类名与表名一致，table可以省略）</li><li>catalog              ：数据库名</li></ul></li><li><p>【id标签的配置】类中的属性与表中的主键的对应关系</p><p>属性：</p><ul><li>name                ：类中的属性名</li><li>column             ：表中的字段名（类中的属性名和表中的字段名如果一致，column可以省略）</li><li>length               ：长度</li><li>type                  ：类型</li></ul></li><li><p>【property标签的配置】类中的普通属性与表的字段的对应关系</p><p> 属性：</p><ul><li>name                ：类中的属性名</li><li>column              ：表中的字段名</li><li>length               ：长度</li><li>type                   ：类型</li><li>not-null             ：设置非空</li><li>unique              ：设置唯一</li></ul></li></ul><h2 id="核心配置"><a href="#核心配置" class="headerlink" title="核心配置"></a>核心配置</h2><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载Hibernate的核心配置文件</span></span><br><span class="line">Configuration configuration = <span class="keyword">new</span> <span class="type">Configuration</span>().configure();</span><br><span class="line"><span class="comment">// 该语句默认会到src/hibernate.cfg.xml加载核心配置文件</span></span><br></pre></td></tr></table></figure><ul><li><p>必须的配置</p><ul><li>连接数据库的基本的参数<ul><li>驱动类</li><li>url路径</li><li>用户名 </li><li>密码</li><li>方言</li></ul></li></ul></li><li><p>可选的配置</p><ul><li>显示SQL         ：hibernate.show_sql</li><li>格式化SQL     ：hibernate.format_sql</li><li>自动建表        ：hibernate.hbm2ddl.auto<ul><li>none                 ：不使用hibernate的自动建表</li><li>create               ：如果数据库中已经有表，<strong>删除原有表</strong>，重新创建，如果没有表，新建表。（测试）</li><li>create-drop     ：如果数据库中已经有表，<strong>删除原有表，执行操作，删除这个表</strong>。如果没有表，新建一个，使用完了删除该表。（测试）</li><li>update             ：如果数据库中有表，使用原有表，如果没有表，创建新表（<strong>更新表结构</strong>）</li><li>validate            ：如果没有表，不会创建表。只会使用数据库中原有的表。（校验映射和表结构）。</li></ul></li></ul></li><li><p>映射文件的引入     </p><p>引入映射文件的位置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"com/example/hibernate/demo1/Customer.hbm.xml"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>例子：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-configuration PUBLIC</span></span><br><span class="line"><span class="meta">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 连接数据库的基本参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql:///hibernate<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.password"</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置Hibernate的方言 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 可选配置================ --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 打印SQL --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 格式化SQL ，使得打印出来的SQL语句更加美观--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">&lt;!-- 自动创建表 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">         <span class="comment">&lt;!-- 映射文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"com/example/hibernate/demo1/Customer.hbm.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><ul><li><p>Configuration</p><ul><li>用来加载配置文件</li></ul></li><li><p>SessionFactory</p><ul><li>用来创建Session</li><li>内部维护连接池</li><li>比较重量级，一般一个应用只创建一个对象</li><li>线程安全</li></ul></li><li><p>Session</p><ul><li>与数据库进行交互</li><li>线程不安全</li></ul></li><li><p>Transaction</p><p>​    事务commit()  rollback()</p></li></ul><h2 id="主键生成策略"><a href="#主键生成策略" class="headerlink" title="主键生成策略"></a>主键生成策略</h2><ul><li><p>主键的分类</p><ul><li><p>自然主键：主键本身就是表中的一个字段</p><p>eg:学生表中，学号就是自然属性</p></li><li><p>代理主键：不是表的字段，比如设置一个自增长的id字段</p><p><strong>尽量使用代理主键</strong></p></li></ul></li><li><p><strong>hibernate主键生成策略</strong></p><ul><li><strong>increment</strong> :hibernate中提供的自动增长机制<ul><li>实现原理，首先发送一条语句select max(id) from 表，然后以id+1作为下一条记录的主键</li><li>线程不安全，原因见实现原理</li></ul></li><li><strong>indentity</strong> 使用数据库底层的自动增长机制<ul><li><em>Oracle不支持自动增长机制</em></li></ul></li><li><strong>sequence</strong> 采用序列的方式<ul><li><em>Oracle支持，但MySQL不支持</em></li></ul></li><li><strong>uuid</strong> 适用于字符串类型的主键<ul><li><em>与上述三种进行区分，上述increment ，indentity ，sequence适用于short,int,long类型的主键</em></li></ul></li><li><strong>native</strong> 会根据底层数据库自动选择identity 或者 sequence</li><li><strong>assigened</strong> 该生成策略的主键值来自程序员手工设置，即通过setId()方法设置。属性类型可以是String、Int，但一般为String。此生成策略用于业务相关主键。例如学号、身份证号做主键</li></ul></li></ul><h2 id="持久化类的三种状态"><a href="#持久化类的三种状态" class="headerlink" title="持久化类的三种状态"></a>持久化类的三种状态</h2><ul><li>瞬时态（transient）没有唯一的标识OID,没有被session管理</li><li>持久态（persister）有唯一标识OID,被session管理</li><li>托管态（detached）有唯一标识OID,没有被session管理</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Session session = HibernateUtil.openSession();<span class="comment">// 自定义工具类</span></span><br><span class="line">Transaction transaction = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">Customer customer = <span class="keyword">new</span> Customer();<span class="comment">// 瞬时态对象</span></span><br><span class="line">customer.setCust_name(<span class="string">"小明"</span>);</span><br><span class="line"></span><br><span class="line">session.save(customer); <span class="comment">// 持久态对象 </span></span><br><span class="line">customer.setCust_mobile(<span class="string">"110"</span>); <span class="comment">// 持久态对象，对customer的更改会同时更改数据库</span></span><br><span class="line"></span><br><span class="line">transaction.commit();</span><br><span class="line">session.close();</span><br><span class="line"></span><br><span class="line">System.out.println(customer); <span class="comment">// 脱管态对象 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="Hiberbate持久化类三种状态转换图.gif" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><ul><li><p>为了减少与数据库交互的次数，session内部维护了一个缓存</p></li><li><p>所有对javabean的更改，不会立即发送sql语句到数据库，而是先更改一级缓存</p></li><li><p>跟session一样的生命周期</p><p><img src="hibernate_cache.jpg" alt>———-</p></li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ul><li><h3 id="事务的四个特性"><a href="#事务的四个特性" class="headerlink" title="事务的四个特性"></a>事务的四个特性</h3><ul><li><p><strong>原子性（Atomicity）</strong>：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</p></li><li><p><strong>一致性（Consistency）</strong>：保证事务只能把数据库从一个有效（正确）的状态“转移”到另一个有效（正确）的状态 </p><blockquote><p><em>那么，什么是数据库的有效(正确）的状态？满足给这个数据库pred-defined的一些规则的状态都是 valid 的。这些规则有哪些呢，比如说constraints, cascade,triggers及它们的组合等。具体到某个表的某个字段，比如你在定义表的时候，给这个字段的类型是number类型，并且它的值不能小于0，那么你在某个 transaction 中给这个字段插入（更改）为一个 String 值或者是负值是不可以的，这不是一个“合法”的transaction，也就是说它不满足我们给数据库定义的一些规则（约束条件）。</em></p></blockquote></li><li><p><strong>隔离性（Isolation）</strong>：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</p></li><li><p><strong>持久性（Durability）</strong>：已被提交的事务对数据库的修改应该永久保存在数据库中。</p></li></ul></li><li><h3 id="并发事务会产生的问题"><a href="#并发事务会产生的问题" class="headerlink" title="并发事务会产生的问题"></a>并发事务会产生的问题</h3><ul><li><p><strong>丢失更新</strong></p><ul><li><p>第一类丢失更新 </p><p>​    定义：A事务撤销时，把已经提交的B事务的更新数据覆盖了。</p></li><li><p>第二类丢失更新</p><p>​    定义： A事务提交时，把已经提交的B事务的更新数据覆盖了。<em>（属于不可重复读的一个特例）</em></p></li></ul></li><li><p><strong>脏读</strong>：读到未提交更新的数据 </p></li><li><p><strong>不可重复读</strong>：读到已经提交更新的数据，但一个事务范围内两个相同的查询却返回了不同数据。 </p></li><li><p><strong>幻读</strong>：读到已提交插入数据，幻读与不可重复读类似，幻读是查询到了另一个事务已提交的新插入数据，而不可重复读是查询到了另一个事务已提交的更新数据。 </p></li></ul></li><li><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ul><li>未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据</li><li>提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)</li><li>可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读</li><li>串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞</li></ul></li><li><h3 id="隔离级别与并发问题"><a href="#隔离级别与并发问题" class="headerlink" title="隔离级别与并发问题"></a>隔离级别与并发问题</h3></li></ul><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>SERIALIZABLE （串行化）</td><td>不会发生</td><td>不会发生</td><td>不会发生</td></tr><tr><td>REPEATABLE READ（可重复读）</td><td>不会发生</td><td>不会发生</td><td>可能发生</td></tr><tr><td>READ COMMITTED （读已提交）</td><td>不会发生</td><td>可能发生</td><td>可能发生</td></tr><tr><td>READ UNCOMMITTED（读未提交）</td><td>可能发生</td><td>可能发生</td><td>可能发生</td></tr></tbody></table><h2 id="Hibernate-一对多关系"><a href="#Hibernate-一对多关系" class="headerlink" title="Hibernate 一对多关系"></a>Hibernate 一对多关系</h2><p>以一个例子来说明：</p><p>两个实体类：一个客户可以有多个联系人</p><ul><li><p>客户表</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// sql语句</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`cst_customer`</span> (</span><br><span class="line">  <span class="string">`cust_id`</span> <span class="built_in">bigint</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'客户编号(主键)'</span>,</span><br><span class="line">  <span class="string">`cust_name`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'客户名称(公司名称)'</span>,</span><br><span class="line">  <span class="string">`cust_source`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'客户信息来源'</span>,</span><br><span class="line">  <span class="string">`cust_industry`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'客户所属行业'</span>,</span><br><span class="line">  <span class="string">`cust_level`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'客户级别'</span>,</span><br><span class="line">  <span class="string">`cust_phone`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'固定电话'</span>,</span><br><span class="line">  <span class="string">`cust_mobile`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'移动电话'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`cust_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure></li><li><p>Customer实体类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户的实体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Long cust_id;</span><br><span class="line"><span class="keyword">private</span> String cust_name;</span><br><span class="line"><span class="keyword">private</span> String cust_source;</span><br><span class="line"><span class="keyword">private</span> String cust_industry;</span><br><span class="line"><span class="keyword">private</span> String cust_level;</span><br><span class="line"><span class="keyword">private</span> String cust_phone;</span><br><span class="line"><span class="keyword">private</span> String cust_mobile;</span><br><span class="line"><span class="comment">// 通过ORM方式表示：一个客户对应多个联系人。</span></span><br><span class="line"><span class="comment">// 放置的多的一方的集合。Hibernate默认使用的是Set集合。</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;LinkMan&gt; linkMans = <span class="keyword">new</span> HashSet&lt;LinkMan&gt;();</span><br><span class="line"><span class="comment">//省略getter,setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户表和客户类映射文件 Customer.hbm.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC </span></span><br><span class="line"><span class="meta">    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"com.example.hibernate.domain.Customer"</span> <span class="attr">table</span>=<span class="string">"cst_customer"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 建立OID与主键映射 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"cust_id"</span> <span class="attr">column</span>=<span class="string">"cust_id"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 建立普通属性与数据库表字段映射 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_name"</span> <span class="attr">column</span>=<span class="string">"cust_name"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_source"</span> <span class="attr">column</span>=<span class="string">"cust_source"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_industry"</span> <span class="attr">column</span>=<span class="string">"cust_industry"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_level"</span> <span class="attr">column</span>=<span class="string">"cust_level"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_phone"</span> <span class="attr">column</span>=<span class="string">"cust_phone"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_mobile"</span> <span class="attr">column</span>=<span class="string">"cust_mobile"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置一对多的映射：放置的多的一方的集合 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">set标签 ：</span></span><br><span class="line"><span class="comment">* name：多的一方的对象集合的属性名称。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"linkMans"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> key标签</span></span><br><span class="line"><span class="comment">* column：多的一方的外键的名称。</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">"lkm_cust_id"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">one-to-many标签</span></span><br><span class="line"><span class="comment">* class:多的一方的类的全路径</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">"com.example.hibernate.domain.LinkMan"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>LinkMan实体类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkMan</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Long lkm_id;</span><br><span class="line"><span class="keyword">private</span> String lkm_name;</span><br><span class="line"><span class="keyword">private</span> String lkm_gender;</span><br><span class="line"><span class="keyword">private</span> String lkm_phone;</span><br><span class="line"><span class="keyword">private</span> String lkm_mobile;</span><br><span class="line"><span class="keyword">private</span> String lkm_email;</span><br><span class="line"><span class="keyword">private</span> String lkm_qq;</span><br><span class="line"><span class="keyword">private</span> String lkm_position;</span><br><span class="line"><span class="keyword">private</span> String lkm_memo;</span><br><span class="line"><span class="comment">// 通过ORM方式表示：一个联系人只能属于某一个客户。</span></span><br><span class="line"><span class="comment">// 放置的是一的一方的对象。</span></span><br><span class="line"><span class="keyword">private</span> Customer customer;</span><br><span class="line"><span class="comment">// 省略getter,setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>联系人表</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`cst_linkman`</span> (</span><br><span class="line">  <span class="string">`lkm_id`</span> <span class="built_in">bigint</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'联系人编号(主键)'</span>,</span><br><span class="line">  <span class="string">`lkm_name`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'联系人姓名'</span>,</span><br><span class="line">  <span class="string">`lkm_cust_id`</span> <span class="built_in">bigint</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'客户id'</span>,</span><br><span class="line">  <span class="string">`lkm_gender`</span> <span class="built_in">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'联系人性别'</span>,</span><br><span class="line">  <span class="string">`lkm_phone`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'联系人办公电话'</span>,</span><br><span class="line">  <span class="string">`lkm_mobile`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'联系人手机'</span>,</span><br><span class="line">  <span class="string">`lkm_email`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'联系人邮箱'</span>,</span><br><span class="line">  <span class="string">`lkm_qq`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'联系人qq'</span>,</span><br><span class="line">  <span class="string">`lkm_position`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'联系人职位'</span>,</span><br><span class="line">  <span class="string">`lkm_memo`</span> <span class="built_in">varchar</span>(<span class="number">512</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'联系人备注'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`lkm_id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`FK_cst_linkman_lkm_cust_id`</span> (<span class="string">`lkm_cust_id`</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`FK_cst_linkman_lkm_cust_id`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`lkm_cust_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`cst_customer`</span> (<span class="string">`cust_id`</span>) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> <span class="keyword">ACTION</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">NO</span> <span class="keyword">ACTION</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure></li><li><p>联系人表和联系人实体类映射文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC </span></span><br><span class="line"><span class="meta">    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"com.example.hibernate.domain.LinkMan"</span> <span class="attr">table</span>=<span class="string">"cst_linkman"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 建立OID与主键映射 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"lkm_id"</span> <span class="attr">column</span>=<span class="string">"lkm_id"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 建立普通属性与表字段映射 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lkm_name"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lkm_gender"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lkm_phone"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lkm_mobile"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lkm_email"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lkm_qq"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lkm_position"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lkm_memo"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置多对一的关系：放置的是一的一方的对象 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">many-to-one标签</span></span><br><span class="line"><span class="comment">* name:一的一方的对象的属性名称。</span></span><br><span class="line"><span class="comment">* class:一的一方的类的全路径。</span></span><br><span class="line"><span class="comment">* column:在多的一方的表的外键的名称。</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">"customer"</span> <span class="attr">class</span>=<span class="string">"com.example.hibernate.domain.Customer"</span> <span class="attr">column</span>=<span class="string">"lkm_cust_id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Session session = HibernateUtil.openSession();</span><br><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line">tx.begin();</span><br><span class="line"></span><br><span class="line">Customer customer1 = <span class="keyword">new</span> Customer(); <span class="comment">// 新建一个客户对象</span></span><br><span class="line">customer1.setCust_name(<span class="string">"客户1"</span>);</span><br><span class="line"></span><br><span class="line">LinkMan linkman1_1 = <span class="keyword">new</span> LinkMan();<span class="comment">// 新建一个联系人</span></span><br><span class="line">linkman1_1.setLkm_name(<span class="string">"联系人1，属于客户1"</span>);</span><br><span class="line">linkman1_1.setCustomer(customer1);</span><br><span class="line"></span><br><span class="line">LinkMan linkMan1_2 = <span class="keyword">new</span> LinkMan();<span class="comment">// 新建一个联系人</span></span><br><span class="line">linkMan1_2.setLkm_name(<span class="string">"联系人2，属于客户1"</span>);</span><br><span class="line">linkMan1_2.setCustomer(customer1);</span><br><span class="line"></span><br><span class="line">customer1.getLinkMans().add(linkman1_1);</span><br><span class="line">customer1.getLinkMans().add(linkMan1_2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联系人和客户对象都需要保存</span></span><br><span class="line">session.save(customer1);</span><br><span class="line">session.save(linkman1_1);</span><br><span class="line">session.save(linkMan1_2);</span><br><span class="line"></span><br><span class="line">tx.commit();</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="一对多级联操作"><a href="#一对多级联操作" class="headerlink" title="一对多级联操作"></a>一对多级联操作</h2><ul><li><h3 id="什么叫级联："><a href="#什么叫级联：" class="headerlink" title="什么叫级联："></a>什么叫级联：</h3><p>​    级联指的是，操作一个对象的时候，是否会同时操作其关联的对象。 </p></li><li><h3 id="级联是有方向性"><a href="#级联是有方向性" class="headerlink" title="级联是有方向性"></a>级联是有方向性</h3><ul><li>操作一的一方的时候，是否操作到多的一方</li><li>操作多的一方的时候，是否操作到一的一方</li></ul></li><li><h3 id="级联保存或者更新"><a href="#级联保存或者更新" class="headerlink" title="级联保存或者更新"></a>级联保存或者更新</h3><blockquote><p> <strong>保存客户级联联系人</strong>,需要在Customer.hbm.xml进行配置</p></blockquote><ul><li><p>配置映射文件Customer.hbm.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--cascade = "save-update"--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"linkMans"</span> <span class="attr">cascade</span>=<span class="string">"save-update"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">"lkm_cust_id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">"com.example.hibernate.domain.LinkMan"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Session session = HibernateUtil.openSession();</span><br><span class="line">    Transaction tx = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">    Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">    customer.setCust_name(<span class="string">"阿里巴巴"</span>);</span><br><span class="line"></span><br><span class="line">    LinkMan linkman1 = <span class="keyword">new</span> LinkMan();</span><br><span class="line">    linkman1.setLkm_name(<span class="string">"阿里巴巴技术总监"</span>);</span><br><span class="line"></span><br><span class="line">    LinkMan linkman2 = <span class="keyword">new</span> LinkMan();</span><br><span class="line">    linkman2.setLkm_name(<span class="string">"阿里巴巴开发组长"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存一边</span></span><br><span class="line">    customer.getLinkMans().add(linkman1);</span><br><span class="line">    customer.getLinkMans().add(linkman2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存一边</span></span><br><span class="line">    session.save(customer);</span><br><span class="line"></span><br><span class="line">    tx.commit();</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>保存联系人级联客户</strong></p></blockquote><ul><li><p>与上述差不多的操作</p></li><li><p>修改LinkMan.hbm.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">"customer"</span> <span class="attr">cascade</span>=<span class="string">"save-update"</span> <span class="attr">class</span>=<span class="string">"com.example.hibernate.domain.Customer"</span> <span class="attr">column</span>=<span class="string">"lkm_cust_id"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><h3 id="级联删除"><a href="#级联删除" class="headerlink" title="级联删除"></a>级联删除</h3><ul><li><p>级联删除：删除一边的时候，同时将另一方的数据也一并删除。</p></li><li><p>下面以一个具体的例子来说明：</p><blockquote><p>1、删除客户，级联删除联系人 </p></blockquote><ul><li><p>第一步，修改映射文件Customer.hbm.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"linkMans"</span> <span class="attr">cascade</span>=<span class="string">"delete"</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>第二步，编写测试代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Session session = HibernateUtil.openSession();</span><br><span class="line">    Transaction tx = session.beginTransaction();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * (1)级联删除</span></span><br><span class="line"><span class="comment"> * &lt;set name="linkMans" cascade="delete"&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    Customer customer1 = session.get(Customer.class, <span class="number">1L</span>);</span><br><span class="line">    session.delete(customer1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * (2)如果没有设置cascade="delete"</span></span><br><span class="line"><span class="comment"> * 运行下面的结果为：只删除了一的一方，多的一方不会被删除</span></span><br><span class="line"><span class="comment"> * 但是多的一方的外键会被设置为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    Customer customer2 = session.get(Customer.class, <span class="number">2L</span>);</span><br><span class="line">    session.delete(customer2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  (3)如果customer不是持久态度</span></span><br><span class="line"><span class="comment"> *  这种方式不会删除多的一方</span></span><br><span class="line"><span class="comment"> *  但是会把多的一方的外键设置为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    Customer customer3 = <span class="keyword">new</span> Customer();</span><br><span class="line">    customer3.setCust_id(<span class="number">3L</span>);</span><br><span class="line">    session.delete(customer3);</span><br><span class="line"></span><br><span class="line">    tx.commit();</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><ol start="2"><li>删除联系人，级联删除客户</li></ol></blockquote><ul><li><p>在一对多中一般不会出现这种情况：没有说删除多的一方，然后把一的一方删除的，因此下面只是测试使用</p><ul><li><p>第一步,修改映射文件LinkMan.hbm.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">"customer"</span> <span class="attr">cascade</span>=<span class="string">"delete"</span> <span class="attr">class</span>=<span class="string">"com.example.hibernate.domain.Customer"</span> <span class="attr">column</span>=<span class="string">"lkm_cust_id"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>第二步,编写测试代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Session session = HibernateUtil.openSession();</span><br><span class="line">    Transaction tx = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除联系人，级联删除客户</span></span><br><span class="line"><span class="comment"> * 在多的一方设置cascade="delete"</span></span><br><span class="line"><span class="comment"> * &lt;many-to-one name="customer" cascade="delete" class="com.example.hibernate.domain.Customer" column="lkm_cust_id"/&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 运行结果：</span></span><br><span class="line"><span class="comment"> * 联系人和联系人关联的客户均被删除</span></span><br><span class="line"><span class="comment"> * 和客户有关联的其他联系人的外键被设置为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    LinkMan linkMan = session.get(LinkMan.class, <span class="number">1L</span>);</span><br><span class="line">    session.delete(linkMan);</span><br><span class="line"></span><br><span class="line">    tx.commit();</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li><p><strong>cascade</strong> 和 <strong>inverse</strong></p><ul><li>cascade:级联<ul><li>save</li><li>update</li><li>save-update</li><li>delete</li></ul></li><li>inverse : 外键维护权<ul><li>true 放弃外键维护权</li><li>false 拥有外键维护权，默认值</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; title=&quot;是什么&quot;&gt;&lt;/a&gt;是什么&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Hibernate是一种ORM(Object Relational Mapping ）框架&lt;/li&gt;
&lt;li&gt;它对JDBC进行了非常轻量级的对象封装 &lt;/li&gt;
&lt;li&gt;hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库 &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://chsobin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://chsobin.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
